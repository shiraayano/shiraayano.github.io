<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 
# 集合框架


## 1. 集合框架概述
内存层面需要针对于多个数据进行存储。">
<meta property="og:title" content="Java 学习笔记 基础篇 016 集合1">
<meta property="og:description" content="# 
# 集合框架


## 1. 集合框架概述
内存层面需要针对于多个数据进行存储。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/27.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java 学习笔记 基础篇 016 集合1</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>img{max-width:100%;height:auto;display:block;margin:1em auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);transition:transform .2s ease,box-shadow .2s ease;}img[data-src]{opacity:0;animation:fadeIn 1s forwards;}@keyframes fadeIn{to{opacity:1;}}img:hover{transform:scale(1.05);box-shadow:0 8px 12px rgba(0,0,0,.2);}@media(max-width:600px){img{margin:.5em auto;}}</style>



<body>
    <div id="header">
<h1 class="postTitle">Java 学习笔记 基础篇 016 集合1</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/27" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1></h1>
<h1>集合框架</h1>
<h2>1. 集合框架概述</h2>
<p>内存层面需要针对于多个数据进行存储。此时，可以考虑的容器有:数组、集合类</p>
<p>数组存储多个数据方面的特点:</p>
<blockquote>
<p>数组一旦初始化，其长度就是确定的。</p>
</blockquote>
<blockquote>
<p>数组中的多个元素是依次紧密排列的，有序的，可重复的</p>
</blockquote>
<blockquote>
<p>(优点)数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中</p>
</blockquote>
<pre lang="java" class="notranslate"><code class="notranslate">intllarr = new int[10];

arr[0]= 1;

arr[1]="AA";//编译报错

0bject[]arr1 = new 0bject[10];

arr1[0]= new String();

arr1[1]= new Date();
</code></pre>
<blockquote>
<p>（优点 ） 元素的类型既可以是基本数据类型，也可以是引用数据类型</p>
</blockquote>
<p>数组存储多个数据方面的弊端：</p>
<blockquote>
<p>数组一旦初始化，其长度就不可变了，</p>
</blockquote>
<blockquote>
<p>数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了</p>
</blockquote>
<blockquote>
<p>数组可用的方法，属性极少，具体的需求都需要自己组织相关的代码逻辑</p>
</blockquote>
<blockquote>
<p>针对于数组中元素的删除，插入操作性能较差</p>
</blockquote>
<p>Java集合框架体系(java.util包下)</p>
<p>java.util.Collection:存储一个-个的数据</p>
<p>-----子接口:List:存储有序的、可重复的数据(动态"数组")</p>
<p>----ArrayList、LinkedList、Vector</p>
<p>-----子接口:Set:存储无序的、不可重复的数据（高中学习的集合是一样的）</p>
<p>----HashSet、LinkedHashSet、TreeSet</p>
<p>List及其实现类特点</p>
<p>java.util.Collection:存储一个一个的数据</p>
<p>-----子接口:List:存储有序的、可重复的数据("动态"数组)</p>
<p>ArrayList:List的主要实现类;线程不安全的、效率高；底层使用 Object[] 数组存储</p>
<p>Vector:List的古老实现类;线程安全的、效率低:底层使用 Object[] 数组存储</p>
<p>LinkedList 底层使用双向链表进行存储，在对集合数据进行频繁的删除，插入操作时建议使用此类</p>
<p>java.util.Map:存储一对一对的数据（存储 key-value 键值对，（x1，y1）,（x2，y2）--&gt; y=F</p>
<p>(x)，类似于函数）</p>
<p>----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</p>
<pre lang="java" class="notranslate"><code class="notranslate">
// 向列表末尾添加一个元素

void add(int index, E element) // 在指定位置插入一个元素



// 在列表末尾添加一个元素

boolean add(E element) // 在列表末尾添加一个元素，并返回true





// 在列表末尾添加多个元素

boolean addAll(Collection&lt;? extends E&gt; c) // 将指定集合中的所有元素添加到列表末尾，并返回true如果列表被修改



// 在列表末尾添加多个元素

boolean addAll(int index, Collection&lt;? extends E&gt; c) // 在指定位置插入指定集合中的所有元素，并返回true如果列表被修改



// 清除列表中的所有元素

void clear() // 移除列表中的所有元素



// 检查列表是否包含某个元素

boolean contains(Object o) // 如果列表包含指定元素，则返回true



// 检查列表是否包含指定集合中的所有元素

boolean containsAll(Collection&lt;?&gt; c) // 如果列表包含指定集合中的所有元素，则返回true



// 获取列表中的元素

E get(int index) // 返回列表中指定位置的元素



// 获取列表中的索引

int indexOf(Object o) // 返回指定元素在列表中第一次出现的索引，如果未找到则返回-1



// 获取列表中的最后一个元素的索引

int lastIndexOf(Object o) // 返回指定元素在列表中最后一次出现的索引，如果未找到则返回-1



// 从列表中移除一个元素

E remove(int index) // 移除列表中指定位置的元素，并返回被移除的元素



// 从列表中移除一个元素

boolean remove(Object o) // 移除列表中第一次出现的指定元素，并返回true如果元素被移除



// 从列表中移除指定集合中的所有元素

boolean removeAll(Collection&lt;?&gt; c) // 移除列表中所有包含在指定集合中的元素，并返回true如果列表被修改



// 保留列表中不在指定集合中的元素

boolean retainAll(Collection&lt;?&gt; c) // 保留列表中所有包含在指定集合中的元素，并返回true如果列表被修改



// 替换列表中的元素

E set(int index, E element) // 替换列表中指定位置的元素，并返回被替换的元素



// 获取列表的大小

int size() // 返回列表中的元素数量



// 将列表转换为数组

Object[] toArray() // 返回包含列表所有元素的数组



// 将列表转换为指定类型的数组

&lt;T&gt; T[] toArray(T[] a) // 返回包含列表所有元素的指定类型的数组

</code></pre>
<p>学习的程度把握:</p>
<p>层次1:针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法</p>
<p>层次2:区分接口中不同实现类的区别</p>
<p>层次三：1，针对于常见类，需要熟悉底层源码</p>
<p>2，熟悉常见的数据结构</p>
<p>数组/集合的遍历</p>
<pre lang="java" class="notranslate"><code class="notranslate">public class Collection {
    public static void main(String[] args) {
        //创建数组
        String [] arr = new String[]{"hello","world"};
        //遍历数组
        for (String s : arr) {
            System.out.println(s);
        }
    }
}

/*
 * 
 * 格式
 * 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...};
 * for（数据类型 变量名 : 数组名）{ }
 * for(要遍历的集合 临时变量 ： 要遍历的集合或数组变量)
 * 说明
 * 
 */
</code></pre>
<p>例 2</p>
<pre lang="java" class="notranslate"><code class="notranslate">public class Collection {
    public static void main(String[] args) {
        // 创建数组
        String[] arr = new String[] { "hello", "world" };
        // 遍历数组
        for (String s : arr) {
            s = "MM";
            System.out.println(s);
        }

        for (int i = 0; i &lt; arr.length; i++) {
            // arr[i] = "MM";
            System.out.println(arr[i]);
        }
    }
}

/*
 * 
 * 格式
 * 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...};
 * for（数据类型 变量名 : 数组名）{ }
 * for(要遍历的集合 临时变量 ： 要遍历的集合或数组变量)
 * 
 * 输出
 * MM
 * MM
 * hello
 * world
 * 
 * 说明
 * 增强for循环遍历数组时，不能修改数组中元素的值，因为增强for循环遍历数组时，数组元素的值是拷贝的，不是数组中元素的引用
 * 
 */
</code></pre>
<h3>1.1 生活中的容器</h3>
<h3>1.2 数组的特点与弊端</h3>
<ul>
<li>一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。</li>
<li>另一方面，使用数组存储对象方面具有<code class="notranslate">一些弊端</code>，而Java 集合就像一种容器，可以<code class="notranslate">动态地</code>把多个对象的引用放入容器中。</li>
<li>数组在内存存储方面的<code class="notranslate">特点</code>：
<ul>
<li>数组初始化以后，长度就确定了。</li>
<li>数组中的添加的元素是依次紧密排列的，有序的，可以重复的。</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型。不是此类型的变量，就不能添加。</li>
<li>可以存储基本数据类型值，也可以存储引用数据类型的变量</li>
</ul>
</li>
<li>数组在存储数据方面的<code class="notranslate">弊端</code>：
<ul>
<li>数组初始化以后，长度就不可变了，不便于扩展</li>
<li>数组中提供的属性和方法少，不便于进行添加、删除、插入、获取元素个数等操作，且效率不高。</li>
<li>数组存储数据的特点单一，只能存储有序的、可以重复的数据</li>
</ul>
</li>
<li>Java 集合框架中的类可以用于存储多个<code class="notranslate">对象</code>，还可用于保存具有<code class="notranslate">映射关系</code>的关联数组。</li>
</ul>
<h3>1.3 Java集合框架体系</h3>
<p>Java 集合可分为 Collection 和 Map 两大体系：</p>
<ul>
<li>Collection接口：用于存储一个一个的数据，也称<code class="notranslate">单列数据集合</code>。
<ul>
<li>List子接口：用来存储有序的、可以重复的数据（主要用来替换数组，"动态"数组）
<ul>
<li>实现类：ArrayList(主要实现类)、LinkedList、Vector</li>
</ul>
</li>
</ul>
</li>
<li>Set子接口：用来存储无序的、不可重复的数据（类似于高中讲的"集合"）
<ul>
<li>实现类：HashSet(主要实现类)、LinkedHashSet、TreeSet</li>
</ul>
</li>
<li>Map接口：用于存储具有映射关系“key-value对”的集合，即一对一对的数据，也称<code class="notranslate">双列数据集合</code>。(类似于高中的函数、映射。(x1,y1),(x2,y2) ---&gt; y = f(x) )
<ul>
<li>HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul>
</li>
<li>JDK提供的集合API位于java.util包内</li>
<li>图示：集合框架全图</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%85%A8%E5%9B%BE.png"><img src="images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%85%A8%E5%9B%BE.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>简图1：<strong>Collection接口继承树</strong></li>
<li>简图2：<strong>Map接口继承树</strong></li>
</ul>
<h3>1.4 集合的使用场景</h3>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220407202630027.png"><img src="images/image-20220407202630027.png" alt="" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="images/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png"><img src="images/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="" style="max-width: 100%;"></a></p>
<h2>2. Collection接口及方法</h2>
<ul>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）去实现。</li>
<li>Collection 接口是 List和Set接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。方法如下：</li>
</ul>
<h3>2.1 添加</h3>
<p>（1）add(E obj)：添加元素对象到当前集合中<br>
（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other</p>
<p>注意：add和addAll的区别</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.collection;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class TestCollectionAdd {
    @Test
    public void testAdd(){
        //ArrayList是Collection的子接口List的实现类之一。
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        System.out.println(coll);
    }

    @Test
    public void testAddAll(){
        Collection c1 = new ArrayList();
        c1.add(1);
        c1.add(2);
        System.out.println("c1集合元素的个数：" + c1.size());//2
        System.out.println("c1 = " + c1);

        Collection c2 = new ArrayList();
        c2.add(1);
        c2.add(2);
        System.out.println("c2集合元素的个数：" + c2.size());//2
        System.out.println("c2 = " + c2);

        Collection other = new ArrayList();
        other.add(1);
        other.add(2);
        other.add(3);
        System.out.println("other集合元素的个数：" + other.size());//3
        System.out.println("other = " + other);
        System.out.println();

        c1.addAll(other);
        System.out.println("c1集合元素的个数：" + c1.size());//5
        System.out.println("c1.addAll(other) = " + c1);

        c2.add(other);
        System.out.println("c2集合元素的个数：" + c2.size());//3
        System.out.println("c2.add(other) = " + c2);
    }
}
</code></pre>
<blockquote>
<p>注意：coll.addAll(other);与coll.add(other);</p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="images/1563548078274.png"><img src="images/1563548078274.png" alt="" style="max-width: 100%;"></a></p>
<pre lang="java" class="notranslate"><code class="notranslate">import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ListTest {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {

        // List&lt;String&gt; list = new ArrayList&lt;&gt;();


        List list = new ArrayList&lt;&gt;();
        list.add("Hello");
        list.add("World");
        list.add(111);//自动装箱
        list.add(222);
        System.out.println(list);
        // [Hello, World, 111, 222]

        list.remove(1);
        System.out.println(list);
        // [Hello, 111, 222]

        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));
        System.out.println(list2);
        // [1, 2, 3]

        list.addAll(list2);
        //将list2中的所有元素添加到list中

        System.out.println(list);
        // [Hello, 111, 222, 1, 2, 3]

        list.addAll(1, list2);
        //将list2中的所有元素添加到list的索引1的位置

        System.out.println(list);
        //[Hello, 1, 2, 3, 111, 222, 1, 2, 3]

        list.remove(1);
        System.out.println(list);
        //[Hello, 2, 3, 111, 222, 1, 2, 3]

        list.add(new Person("Tom", 18));
        System.out.println(list);
        //[Hello, 2, 3, 111, 222, 1, 2, 3, Person@5caf905d]

        //删除list中所有的Person对象
        list.removeAll(Arrays.asList(new Person("Tom", 18)));
        System.out.println(list);
        //[Hello, 2, 3, 111, 222, 1, 2, 3]
    }
}
class Person{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
</code></pre>
<h3>2.2 判断</h3>
<p>（3）int size()：获取当前集合中实际存储的元素个数<br>
（4）boolean isEmpty()：判断当前集合是否为空集合<br>
（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素<br>
（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”<br>
（7）boolean equals(Object obj)：判断当前集合与obj是否相等</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.collection;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

public class TestCollectionContains {
    @Test
    public void test01() {
        Collection coll = new ArrayList();
        System.out.println("coll在添加元素之前，isEmpty = " + coll.isEmpty());
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll的元素个数" + coll.size());

        System.out.println("coll在添加元素之后，isEmpty = " + coll.isEmpty());
    }

    @Test
    public void test02() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);
        System.out.println("coll是否包含“小李广” = " + coll.contains("小李广"));
        System.out.println("coll是否包含“宋红康” = " + coll.contains("宋红康"));

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);

        System.out.println("coll.containsAll(other) = " + coll.containsAll(other));
    }

    @Test
    public void test03(){
        Collection c1 = new ArrayList();
        c1.add(1);
        c1.add(2);
        System.out.println("c1集合元素的个数：" + c1.size());//2
        System.out.println("c1 = " + c1);

        Collection c2 = new ArrayList();
        c2.add(1);
        c2.add(2);
        System.out.println("c2集合元素的个数：" + c2.size());//2
        System.out.println("c2 = " + c2);

        Collection other = new ArrayList();
        other.add(1);
        other.add(2);
        other.add(3);
        System.out.println("other集合元素的个数：" + other.size());//3
        System.out.println("other = " + other);
        System.out.println();

        c1.addAll(other);
        System.out.println("c1集合元素的个数：" + c1.size());//5
        System.out.println("c1.addAll(other) = " + c1);
        System.out.println("c1.contains(other) = " + c1.contains(other));
        System.out.println("c1.containsAll(other) = " + c1.containsAll(other));
        System.out.println();

        c2.add(other);
        System.out.println("c2集合元素的个数：" + c2.size());
        System.out.println("c2.add(other) = " + c2);
        System.out.println("c2.contains(other) = " + c2.contains(other));
        System.out.println("c2.containsAll(other) = " + c2.containsAll(other));
    }

}
</code></pre>
<h3>2.3 删除</h3>
<p>（8）void clear()：清空集合元素<br>
（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。<br>
（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll<br>
（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  = this ∩ coll；</p>
<p>注意几种删除方法的区别</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.collection;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;

public class TestCollectionRemove {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        coll.remove("小李广");
        System.out.println("删除元素\"小李广\"之后coll = " + coll);
        
        coll.clear();
        System.out.println("coll清空之后，coll = " + coll);
    }

    @Test
    public void test02() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);

        coll.removeAll(other);
        System.out.println("coll.removeAll(other)之后，coll = " + coll);
        System.out.println("coll.removeAll(other)之后，other = " + other);
    }

    @Test
    public void test03() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);

        coll.retainAll(other);
        System.out.println("coll.retainAll(other)之后，coll = " + coll);
        System.out.println("coll.retainAll(other)之后，other = " + other);
    }

}
</code></pre>
<h3>2.4 其它</h3>
<p>（12）Object[] toArray()：返回包含当前集合中所有元素的数组<br>
（13）hashCode()：获取集合对象的哈希值<br>
（14）iterator()：返回迭代器对象，用于集合遍历</p>
<pre lang="java" class="notranslate"><code class="notranslate">public class TestCollectionContains {
    @Test
    public void test01() {
        Collection coll = new ArrayList();

        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        //集合转换为数组：集合的toArray()方法
        Object[] objects = coll.toArray();
        System.out.println("用数组返回coll中所有元素：" + Arrays.toString(objects));
        
        //对应的，数组转换为集合：调用Arrays的asList(Object ...objs)
        Object[] arr1 = new Object[]{123,"AA","CC"};
        Collection list = Arrays.asList(arr1);
        System.out.println(list);
    }
}
</code></pre>
<pre lang="java" class="notranslate"><code class="notranslate">// 亲例:键盘录入学生信息，保存到集合List中。
// 1)定义学生类，属性为姓名、年龄，提供必要的getter、setter方法，构造器，toString()，equals()方法
// 使用ArrayList集合，保存录入的多个学生对象。
// 2)
// 0，结束录入。
// 3)循环录入的方式，1:继续录入，
// 4)录入结束后，用foreach遍历集合

import java.util.ArrayList;
import java.util.Scanner;

public class Student {
    private String name;
    private int age;

    public Student() {

    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        
    }
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Student student = (Student) o;

        if (age != student.age) return false;
        return name.equals(student.name);
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';

    }

    public static void main(String[] args) {
        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
        Scanner sc = new Scanner(System.in);
        while (true) {
            System.out.println("请输入学生姓名");
            String name = sc.next();
            System.out.println("请输入学生年龄");
            int age = sc.nextInt();

            Student s = new Student(name,age);
            list.add(s);

            System.out.println("是否继续录入？1/0");
            if (sc.nextInt() == 0) {
                //输出成绩
                for (Student student : list) {
                    System.out.println(student);
                }
                break;
                
            }
    }
    
}
}
</code></pre>
<pre lang="java" class="notranslate"><code class="notranslate">//音乐菜单
import java.util.ArrayList;
import java.util.Scanner;

public class Music {
    private String name;
    private String singer;

    public Music(String name, String singer) {
        this.name = name;
        this.singer = singer;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    public String getSinger() {
        return singer;
    }

    public void setSinger(String singer) {
        this.singer = singer;
    }

    @Override
    public String toString() {
        return "歌曲名:" + name + ",歌手:" + singer;
    }

    public static void main(String[] args) {
        ArrayList&lt;Music&gt; list = new ArrayList&lt;&gt;();
        Scanner sc = new Scanner(System.in);
        while (true) {
            // 输出歌曲
            for (int i = 0; i &lt; list.size(); i++) {
                System.out.println((i + 1) + "." + list.get(i).toString());
            }
            System.out.println("-欢迎来到点歌系统--");
            System.out.println("1.添加歌曲至列表");
            System.out.println("2.将歌曲置顶");
            System.out.println("3.将歌曲前移一位");
            System.out.println("4.退出");

            int choice = sc.nextInt();
            sc.nextLine(); // 清除输入缓冲区中的换行符

            switch (choice) {
                case 1:
                    System.out.println("请输入歌曲名:");
                    String name = sc.nextLine();
                    System.out.println("请输入歌手名:");
                    String singer = sc.nextLine();
                    Music music = new Music(name, singer);
                    list.add(music);
                    break;
                case 2:
                    if (list.isEmpty()) {
                        System.out.println("歌曲列表为空");
                    } else {
                        System.out.println("请输入要置顶的歌曲名:");
                        String songName = sc.nextLine();
                        for (int i = 0; i &lt; list.size(); i++) {
                            if (list.get(i).getName().equals(songName)) {
                                Music temp = list.remove(i);
                                list.add(0, temp);
                                break;
                            }
                        }
                    }
                    break;
                case 3:
                    if (list.isEmpty()) {
                        System.out.println("歌曲列表为空");
                    } else {
                        System.out.println("请输入要前移的歌曲名:");
                        String songName = sc.nextLine();
                        for (int i = 0; i &lt; list.size(); i++) {
                            if (list.get(i).getName().equals(songName)) {
                                if (i &gt; 0) {
                                    Music temp = list.remove(i);
                                    list.add(i - 1, temp);
                                } else {
                                    System.out.println("该歌曲已经在列表最前面");
                                }
                                break;
                            }
                        }
                    }
                    break;
                case 4:
                    System.out.println("退出点歌系统");
                    sc.close();
                    return;
                default:
                    System.out.println("无效的指令，请重新输入");
            }
        }
    }
}
</code></pre>
<h2>3. Iterator(迭代器)接口</h2>
<h3>3.1 Iterator接口</h3>
<ul>
<li>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code class="notranslate">java.util.Iterator</code>。<code class="notranslate">Iterator</code>接口也是Java集合中的一员，但它与<code class="notranslate">Collection</code>、<code class="notranslate">Map</code>接口有所不同。
<ul>
<li>Collection接口与Map接口主要用于<code class="notranslate">存储</code>元素</li>
<li><code class="notranslate">Iterator</code>，被称为迭代器接口，本身并不提供存储对象的能力，主要用于<code class="notranslate">遍历</code>Collection中的元素</li>
</ul>
</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。
<ul>
<li><code class="notranslate">public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li>
</ul>
</li>
<li>Iterator接口的常用方法如下：
<ul>
<li><code class="notranslate">public E next()</code>:返回迭代的下一个元素。</li>
<li><code class="notranslate">public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
</li>
<li>注意：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出<code class="notranslate">NoSuchElementException异常</code>。</li>
</ul>
<p>举例：</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.iterator;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestIterator {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");

        Iterator iterator = coll.iterator();
        System.out.println(iterator.next());
        System.out.println(iterator.next());
        System.out.println(iterator.next());
        System.out.println(iterator.next()); //报NoSuchElementException异常
    }

    @Test
    public void test02(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");

        Iterator iterator = coll.iterator();//获取迭代器对象
        while(iterator.hasNext()) {//判断是否还有元素可迭代
            System.out.println(iterator.next());//取出下一个元素
        }
    }
}

</code></pre>
<h3>3.2 迭代器的执行原理</h3>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220407235130988.png"><img src="images/image-20220407235130988.png" alt="" style="max-width: 100%;"></a></p>
<p>使用Iterator迭代器删除元素：java.util.Iterator迭代器中有一个方法：void remove() ;</p>
<pre lang="java" class="notranslate"><code class="notranslate">Iterator iter = coll.iterator();//回到起点
while(iter.hasNext()){
    Object obj = iter.next();
    if(obj.equals("Tom")){
        iter.remove();
    }
}
</code></pre>
<p>注意：</p>
<ul>
<li>Iterator可以删除集合的元素，但是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li>如果还未调用next()或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用remove()都会报IllegalStateException。</li>
<li>Collection已经有remove(xx)方法了，为什么Iterator迭代器还要提供删除方法呢？因为迭代器的remove()可以按指定的条件进行删除。</li>
</ul>
<p>例如：要删除以下集合元素中的偶数</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.iterator;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestIteratorRemove {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add(1);
        coll.add(2);
        coll.add(3);
        coll.add(4);
        coll.add(5);
        coll.add(6);

        Iterator iterator = coll.iterator();
        while(iterator.hasNext()){
            Integer element = (Integer) iterator.next();
            if(element % 2 == 0){
                iterator.remove();
            }
        }
        System.out.println(coll);
    }
}

</code></pre>
<p>在JDK8.0时，Collection接口有了removeIf 方法，即可以根据条件删除。（第18章中再讲）</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.collection;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;

public class TestCollectionRemoveIf {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        coll.removeIf(new Predicate() {
            @Override
            public boolean test(Object o) {
                String str = (String) o;
                return str.contains("地");
            }
        });
        System.out.println("删除包含\"地\"字的元素之后coll = " + coll);
    }
}
</code></pre>
<h3>3.3 foreach循环</h3>
<ul>
<li>foreach循环（也称增强for循环）是 JDK5.0 中定义的一个高级for循环，专门用来<code class="notranslate">遍历数组和集合</code>的。</li>
<li>foreach循环的语法格式：</li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">for(元素的数据类型 局部变量 : Collection集合或数组){ 
      //操作局部变量的输出操作
}
//这里局部变量就是一个临时变量，自己命名就可以
</code></pre>
<ul>
<li>举例：</li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.iterator;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class TestForeach {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        //foreach循环其实就是使用Iterator迭代器来完成元素的遍历的。
        for (Object o : coll) {
            System.out.println(o);
        }
    }
    @Test
    public void test02(){
        int[] nums = {1,2,3,4,5};
        for (int num : nums) {
            System.out.println(num);
        }
        System.out.println("-----------------");
        String[] names = {"张三","李四","王五"};
        for (String name : names) {
            System.out.println(name);
        }
    }
}
</code></pre>
<ul>
<li>对于集合的遍历，增强for的内部原理其实是个Iterator迭代器。如下图。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220128010114124.png"><img src="images/image-20220128010114124.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。
<ul>
<li>练习：判断输出结果为何？</li>
</ul>
</li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">public class ForTest {
    public static void main(String[] args) {
        String[] str = new String[5];
        for (String myStr : str) {
            myStr = "atguigu";
            System.out.println(myStr);
        }
        for (int i = 0; i &lt; str.length; i++) {
            System.out.println(str[i]);
        }
    }
}

</code></pre>
<h2>4. Collection子接口1：List</h2>
<h3>4.1 List接口特点</h3>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用<code class="notranslate">java.util.List</code>替代数组</li>
<li>List集合类中<code class="notranslate">元素有序</code>、且<code class="notranslate">可重复</code>，集合中的每个元素都有其对应的顺序索引。
<ul>
<li>举例：List集合存储数据，就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/1563549818689.png"><img src="images/1563549818689.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>JDK API中List接口的实现类常用的有：<code class="notranslate">ArrayList</code>、<code class="notranslate">LinkedList</code>和<code class="notranslate">Vector</code>。</li>
</ul>
<h3>4.2 List接口方法</h3>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些<code class="notranslate">根据索引</code>来操作集合元素的方法。</p>
<ul>
<li>插入元素
<ul>
<li><code class="notranslate">void add(int index, Object ele)</code>:在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
</ul>
</li>
<li>获取元素
<ul>
<li><code class="notranslate">Object get(int index)</code>:获取指定index位置的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
<li>获取元素索引
<ul>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
</ul>
</li>
<li>删除和替换元素
<ul>
<li><code class="notranslate">Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li>
<li><code class="notranslate">Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li>
</ul>
</li>
</ul>
<p>举例：</p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.list;

import java.util.ArrayList;
import java.util.List;

public class TestListMethod {
    public static void main(String[] args) {
        // 创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();

        // 往 尾部添加 指定元素
        list.add("图图");
        list.add("小美");
        list.add("不高兴");

        System.out.println(list);
        // add(int index,String s) 往指定位置添加
        list.add(1,"没头脑");

        System.out.println(list);
        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素
        System.out.println("删除索引位置为2的元素");
        System.out.println(list.remove(2));

        System.out.println(list);

        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改）
        // 修改指定位置元素
        list.set(0, "三毛");
        System.out.println(list);

        // String get(int index)  获取指定位置元素
        // 跟size() 方法一起用  来 遍历的
        for(int i = 0;i&lt;list.size();i++){
            System.out.println(list.get(i));
        }
        //还可以使用增强for
        for (String string : list) {
            System.out.println(string);
        }
    }
}
</code></pre>
<blockquote>
<p>注意：在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p>
</blockquote>
<h3>4.3 List接口主要实现类：ArrayList</h3>
<ul>
<li>ArrayList 是 List 接口的<code class="notranslate">主要实现类</code></li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合<a target="_blank" rel="noopener noreferrer" href="images/image-20220408210743342.png"><img src="images/image-20220408210743342.png" alt="" style="max-width: 100%;"></a></li>
</ul>
<h3>4.4 List的实现类之二：LinkedList</h3>
<ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220408225615829.png"><img src="images/image-20220408225615829.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>特有方法：
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
</ul>
<h3>4.5 List的实现类之三：Vector</h3>
<ul>
<li>Vector 是一个<code class="notranslate">古老</code>的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是<code class="notranslate">线程安全</code>的。</li>
<li>在各种List中，最好把<code class="notranslate">ArrayList作为默认选择</code>。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
<li>特有方法：
<ul>
<li>void addElement(Object obj)</li>
<li>void insertElementAt(Object obj,int index)</li>
<li>void setElementAt(Object obj,int index)</li>
<li>void removeElement(Object obj)</li>
<li>void removeAllElements()</li>
</ul>
</li>
</ul>
<h3>4.6 练习</h3>
<p><strong>面试题：</strong></p>
<pre lang="java" class="notranslate"><code class="notranslate">@Test
public void testListRemove() {
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    System.out.println(list);//[1,2]
}

private static void updateList(List list) {
    list.remove(2);  
}

</code></pre>
<p><strong>练习1：</strong></p>
<ul>
<li>定义学生类，属性为姓名、年龄，提供必要的getter、setter方法，构造器，toString()，equals()方法。</li>
<li>使用ArrayList集合，保存录入的多个学生对象。</li>
<li>循环录入的方式，1：继续录入，0：结束录入。</li>
<li>录入结束后，用foreach遍历集合。</li>
<li>代码实现，效果如图所示：<a target="_blank" rel="noopener noreferrer" href="images/1559890098509.png"><img src="images/1559890098509.png" alt="" style="max-width: 100%;"></a></li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.test01;

import java.util.ArrayList;
import java.util.Scanner;

public class StudentTest {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        ArrayList stuList = new ArrayList();

        for (;;) {

            System.out.println("选择（录入 1 ；结束 0）");
            int x = scanner.nextInt();//根据x的值，判断是否需要继续循环

            if (x == 1) {
                System.out.println("姓名");
                String name = scanner.next();
                System.out.println("年龄");
                int age = scanner.nextInt();
                Student stu = new Student(age, name);
                stuList.add(stu);

            } else if (x == 0) {
                break;

            } else {

                System.out.println("输入有误，请重新输入");
            }
        }

        for (Object stu : stuList) {
            System.out.println(stu);
        }
    }
}

public class Student {

    private int age;
    private String name;

    public Student() {
    }

    
    public Student(int age, String name) {
        super();
        this.age = age;
        this.name = name;
    }


    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;

    }

    @Override
    public String toString() {
        return "Student [age=" + age + ", name=" + name + "]";
    }

}
</code></pre>
<p><strong>练习2：</strong></p>
<pre class="notranslate"><code class="notranslate">1、请定义方法public static int listTest(Collection list,String s)统计集合中指定元素出现的次数

2、创建集合，集合存放随机生成的30个小写字母

3、用listTest统计，a、b、c、x元素的出现次数

4、效果如下
</code></pre>
<p><a target="_blank" rel="noopener noreferrer" href="images/1559896150606.png"><img src="images/1559896150606.png" alt="" style="max-width: 100%;"></a></p>
<pre lang="java" class="notranslate"><code class="notranslate">package com.atguigu.test02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;

public class Test02 {
    public static void main(String[] args) {
        Collection list = new ArrayList();
        Random rand = new Random();
        for (int i = 0; i &lt; 30; i++) {
            list.add((char)(rand.nextInt(26)+97)+"");
        }
        System.out.println(list);
        System.out.println("a:"+listTest(list, "a"));	
        System.out.println("b:"+listTest(list, "b"));	
        System.out.println("c:"+listTest(list, "c"));
        System.out.println("x:"+listTest(list, "x"));	
    }

    public static int listTest(Collection list, String string) {
        int count = 0;
        for (Object object : list) {
            if(string.equals(object)){
                count++;
            }
        }
        return count;
    }
}

</code></pre>
<p><strong>练习3：KTV点歌系统</strong></p>
<p><strong>描述</strong></p>
<p>分别使用ArrayList和LinkedList集合，编写一个**<code class="notranslate">KTV点歌系统</code>**的程序。在程序中：</p>
<ul>
<li>指令1代表添加歌曲</li>
<li>指令2代表将所选歌曲置顶</li>
<li>指令3代表将所选歌曲提前一位</li>
<li>指令4代表退出该系统</li>
</ul>
<p>要求根据用户输入的指令和歌曲名展现歌曲列表。例如输入指令1，输入歌曲名"爱你一万年"，则输出“当前歌曲列表：[爱你一万年]”。</p>
<p><strong>提示</strong></p>
<ul>
<li>为了指引用户操作，首先要将各个指令所表示的含义打印到控制台</li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">System.out.println("-------------欢迎来到点歌系统------------");
System.out.println("1.添加歌曲至列表");
System.out.println("2.将歌曲置顶");
System.out.println("3.将歌曲前移一位");
System.out.println("4.退出");
</code></pre>
<ul>
<li>程序中需要创建一个集合作为歌曲列表，并向其添加一部分歌曲</li>
<li>通过ArrayList或LinkedList集合定义的方法操作歌曲列表</li>
</ul>
<p><strong>代码</strong></p>
<ul>
<li>使用ArrayList集合模拟点歌系统的实现代码，如下所示：</li>
</ul>
<pre lang="java" class="notranslate"><code class="notranslate">/**
 * @author 尚硅谷-宋红康
 * @create 20:26
 */
public class KTVByArrayList {
    private static ArrayList musicList = new ArrayList();// 创建歌曲列表
    private static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {
        addMusicList();// 添加一部分歌曲至歌曲列表
        boolean flag = true;
        while (flag) {
            System.out.println("当前歌曲列表：" + musicList);
            System.out.println("-------------欢迎来到点歌系统------------");
            System.out.println("1.添加歌曲至列表");
            System.out.println("2.将歌曲置顶");
            System.out.println("3.将歌曲前移一位");
            System.out.println("4.退出");
            System.out.print("请输入操作序号：");
            int key = sc.nextInt();// //接收键盘输入的功能选项序号
            // 执行序号对应的功能
            switch (key) {
                case 1:// 添加歌曲至列表
                    addMusic();
                    break;
                case 2:// 将歌曲置顶
                    setTop();
                    break;
                case 3:// 将歌曲前移一位
                    setBefore();
                    break;
                case 4:// 退出
                    System.out.println("----------------退出---------------");
                    System.out.println("您已退出系统");
                    flag = false;
                    break;
                default:
                    System.out.println("----------------------------------");
                    System.out.println("功能选择有误，请输入正确的功能序号!");
                    break;
            }

        }
    }

    // 初始时添加歌曲名称
    private static void addMusicList() {
        musicList.add("本草纲目");
        musicList.add("你是我的眼");
        musicList.add("老男孩");
        musicList.add("白月光与朱砂痣");
        musicList.add("不谓侠");
        musicList.add("爱你");
    }

    // 执行添加歌曲
    private static void addMusic() {
        System.out.print("请输入要添加的歌曲名称：");
        String musicName = sc.next();// 获取键盘输入内容
        musicList.add(musicName);// 添加歌曲到列表的最后
        System.out.println("已添加歌曲：" + musicName);
    }

    // 执行将歌曲置顶
    private static void setTop() {
        System.out.print("请输入要置顶的歌曲名称：");
        String musicName = sc.next();// 获取键盘输入内容
        int musicIndex = musicList.indexOf(musicName);// 查找指定歌曲位置
        if (musicIndex &lt; 0) {// 判断输入歌曲是否存在
            System.out.println("当前列表中没有输入的歌曲！");
        }else if(musicIndex == 0){
            System.out.println("当前歌曲默认已置顶！");
        }else {
            musicList.remove(musicName);// 移除指定的歌曲
            musicList.add(0, musicName);// 将指定的歌曲放到第一位
            System.out.println("已将歌曲《" + musicName + "》置顶");
        }
    }

    // 执行将歌曲置前一位
    private static void setBefore() {
        System.out.print("请输入要置前的歌曲名称：");
        String musicName = sc.next();// 获取键盘输入内容
        int musicIndex = musicList.indexOf(musicName);// 查找指定歌曲位置
        if (musicIndex &lt; 0) {// 判断输入歌曲是否存在
            System.out.println("当前列表中没有输入的歌曲！");
        } else if (musicIndex == 0) {// 判断歌曲是否已在第一位
            System.out.println("当前歌曲已在最顶部！");
        } else {
            musicList.remove(musicName);// 移除指定的歌曲
            musicList.add(musicIndex - 1, musicName);// 将指定的歌曲放到前一位
            System.out.println("已将歌曲《" + musicName + "》置前一位");
        }
    }
}
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"><footer style="padding:10px 15px;text-align:left;font-size:14px;color:#555;border-top:1px solid #e0e0e0;line-height:1.8;font-family:Arial,sans-serif"><span>注意：转载请注明出处 <br> 转载请先阅读以下文章 </span><a href="https://blog.adouzi.eu.org/post/21.html" style="color:#0078d7;text-decoration:none">关于博客文章转载规则以及一些闲聊</a> <br><br> <span>  个人主页：<a href="https://adouzi.eu.org" style="color:#0078d7;text-decoration:none">https://adouzi.eu.org</a></span><span> | Email：<a href="mailto:shiraayano@adouzi.eu.org" style="color:#0078d7;text-decoration:none">shiraayano@adouzi.eu.org</a><br><br><br>支持笔者：<a href="https://www.profitableratecpm.com/euxxr69t?key=f815bdc51cd258ab9f699175b0ef4446" style="color:#0078d7;text-decoration:none">点击广告</a><br>广告收入是本站唯一的收入，若本站内容帮到了您，可以点击广告支持笔者。</span><script async data-cfasync="false" src="//pl27420049.profitableratecpm.com/0f4f9e716ea5257a380097bb2d39a0bb/invoke.js"></script><div id="container-0f4f9e716ea5257a380097bb2d39a0bb"></div><br><script type="text/javascript">
atOptions = {
	'key' : '7a765266e94fd2cc53f429f1806bfa33',
	'format' : 'iframe',
	'height' : 90,
	'width' : 728,
	'params' : {}
}; </script><script type='text/javascript' src='//www.highperformanceformat.com/7a765266e94fd2cc53f429f1806bfa33/invoke.js'></script></footer></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2"><span id="filingNum"><a href="https://beian.miit.gov.cn/" target="_blank"><a href='https://icp.gov.moe/?keyword=20240287' target='_blank'>萌ICP备20240287号</a></a> • </span>
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>document.addEventListener('visibilitychange',function(){const o=document.title;const i=['不来看看咱喵~？','喵喵喵~？'];if(document.visibilityState==='hidden'){document.title=i[Math.floor(Math.random()*i.length)];}else{document.title='欢迎回来喵~';setTimeout(function(){document.title=o;},1000);}});</script><script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script><script>document.addEventListener('visibilitychange',function(){if(!window.originalTitle){window.originalTitle=document.title;}const h=['不来看看咱喵~？','喵喵喵~？'];if(document.visibilityState==='hidden'){document.title=h[Math.floor(Math.random()*h.length)];}else{document.title='欢迎回来喵~';setTimeout(()=>{document.title=window.originalTitle;},1000);}});</script>

</html>
