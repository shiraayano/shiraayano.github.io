<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 6. 再谈同步
### 6.1 单例设计模式的线程安全问题
#### 6.1.1 饿汉式没有线程安全问题
饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的

形式一：

```java
package com.atguigu.single.hungry;

public class HungrySingle {
    private static HungrySingle INSTANCE = new HungrySingle(); //对象是否声明为final 都可以
    
    private HungrySingle(){}
    
    public static HungrySingle getInstance(){
        return INSTANCE;
    }
}
```

形式二：

```java
/*
public class HungryOne{
    public static final HungryOne INSTANCE = new HungryOne();
    private HungryOne(){}
}*/

public enum HungryOne{
    INSTANCE
}
```

测试类：

```java
package com.atguigu.single.hungry;

public class HungrySingleTest {

    static HungrySingle hs1 = null;
    static HungrySingle hs2 = null;

    //演示存在的线程安全问题
    public static void main(String[] args) {

        Thread t1 = new Thread() {
            @Override
            public void run() {
                hs1 = HungrySingle.getInstance();
            }
        };

        Thread t2 = new Thread() {
            @Override
            public void run() {
                hs2 = HungrySingle.getInstance();
            }
        };

        t1.start();
        t2.start();

        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(hs1);
        System.out.println(hs2);
        System.out.println(hs1 == hs2);//true
    }

}
```

#### 6.1.2 懒汉式线程安全问题
懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象

形式一：

```java
package com.atguigu.single.lazy;

public class LazyOne {
    private static LazyOne instance;

    private LazyOne(){}

    //方式1：
    public static synchronized LazyOne getInstance1(){
        if(instance == null){
            instance = new LazyOne();
        }
        return instance;
    }
    //方式2：
    public static LazyOne getInstance2(){
        synchronized(LazyOne.class) {
            if (instance == null) {
                instance = new LazyOne();
            }
            return instance;
        }
    }
    //方式3：
    public static LazyOne getInstance3(){
        if(instance == null){
            synchronized (LazyOne.class) {
                try {
                    Thread.sleep(10);//加这个代码，暴露问题
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(instance == null){
                    instance = new LazyOne();
                }
            }
        }

        return instance;
    }
    /*
    注意：上述方式3中，有指令重排问题
    mem = allocate(); 为单例对象分配内存空间
    instance = mem;   instance引用现在非空，但还未初始化
    ctorSingleton(instance); 为单例对象通过instance调用构造器
    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。">
<meta property="og:title" content="Java学习笔记基础篇 007">
<meta property="og:description" content="## 6. 再谈同步
### 6.1 单例设计模式的线程安全问题
#### 6.1.1 饿汉式没有线程安全问题
饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的

形式一：

```java
package com.atguigu.single.hungry;

public class HungrySingle {
    private static HungrySingle INSTANCE = new HungrySingle(); //对象是否声明为final 都可以
    
    private HungrySingle(){}
    
    public static HungrySingle getInstance(){
        return INSTANCE;
    }
}
```

形式二：

```java
/*
public class HungryOne{
    public static final HungryOne INSTANCE = new HungryOne();
    private HungryOne(){}
}*/

public enum HungryOne{
    INSTANCE
}
```

测试类：

```java
package com.atguigu.single.hungry;

public class HungrySingleTest {

    static HungrySingle hs1 = null;
    static HungrySingle hs2 = null;

    //演示存在的线程安全问题
    public static void main(String[] args) {

        Thread t1 = new Thread() {
            @Override
            public void run() {
                hs1 = HungrySingle.getInstance();
            }
        };

        Thread t2 = new Thread() {
            @Override
            public void run() {
                hs2 = HungrySingle.getInstance();
            }
        };

        t1.start();
        t2.start();

        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(hs1);
        System.out.println(hs2);
        System.out.println(hs1 == hs2);//true
    }

}
```

#### 6.1.2 懒汉式线程安全问题
懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象

形式一：

```java
package com.atguigu.single.lazy;

public class LazyOne {
    private static LazyOne instance;

    private LazyOne(){}

    //方式1：
    public static synchronized LazyOne getInstance1(){
        if(instance == null){
            instance = new LazyOne();
        }
        return instance;
    }
    //方式2：
    public static LazyOne getInstance2(){
        synchronized(LazyOne.class) {
            if (instance == null) {
                instance = new LazyOne();
            }
            return instance;
        }
    }
    //方式3：
    public static LazyOne getInstance3(){
        if(instance == null){
            synchronized (LazyOne.class) {
                try {
                    Thread.sleep(10);//加这个代码，暴露问题
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(instance == null){
                    instance = new LazyOne();
                }
            }
        }

        return instance;
    }
    /*
    注意：上述方式3中，有指令重排问题
    mem = allocate(); 为单例对象分配内存空间
    instance = mem;   instance引用现在非空，但还未初始化
    ctorSingleton(instance); 为单例对象通过instance调用构造器
    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/17.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java学习笔记基础篇 007</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>img{max-width:100%;height:auto;display:block;margin:1em auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);transition:transform .2s ease,box-shadow .2s ease;}img[data-src]{opacity:0;animation:fadeIn 1s forwards;}@keyframes fadeIn{to{opacity:1;}}img:hover{transform:scale(1.05);box-shadow:0 8px 12px rgba(0,0,0,.2);}@media(max-width:600px){img{margin:.5em auto;}}</style>



<body>
    <div id="header">
<h1 class="postTitle">Java学习笔记基础篇 007</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/17" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>6. 再谈同步</h2>
<h3>6.1 单例设计模式的线程安全问题</h3>
<h4>6.1.1 饿汉式没有线程安全问题</h4>
<p>饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的</p>
<p>形式一：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">single</span>.<span class="pl-s1">hungry</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">HungrySingle</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">HungrySingle</span> <span class="pl-c1">INSTANCE</span> = <span class="pl-k">new</span> <span class="pl-smi">HungrySingle</span>(); <span class="pl-c">//对象是否声明为final 都可以</span>
    
    <span class="pl-k">private</span> <span class="pl-smi">HungrySingle</span>(){}
    
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">HungrySingle</span> <span class="pl-en">getInstance</span>(){
        <span class="pl-k">return</span> <span class="pl-c1">INSTANCE</span>;
    }
}</pre></div>
<p>形式二：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c">public class HungryOne{</span>
<span class="pl-c">    public static final HungryOne INSTANCE = new HungryOne();</span>
<span class="pl-c">    private HungryOne(){}</span>
<span class="pl-c">}*/</span>

<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">HungryOne</span>{
    <span class="pl-c1">INSTANCE</span>
}</pre></div>
<p>测试类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">single</span>.<span class="pl-s1">hungry</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">HungrySingleTest</span> {

    <span class="pl-k">static</span> <span class="pl-smi">HungrySingle</span> <span class="pl-s1">hs1</span> = <span class="pl-c1">null</span>;
    <span class="pl-k">static</span> <span class="pl-smi">HungrySingle</span> <span class="pl-s1">hs2</span> = <span class="pl-c1">null</span>;

    <span class="pl-c">//演示存在的线程安全问题</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {

        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-s1">hs1</span> = <span class="pl-smi">HungrySingle</span>.<span class="pl-en">getInstance</span>();
            }
        };

        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-s1">hs2</span> = <span class="pl-smi">HungrySingle</span>.<span class="pl-en">getInstance</span>();
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();

        <span class="pl-k">try</span> {
            <span class="pl-s1">t1</span>.<span class="pl-en">join</span>();
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }
        <span class="pl-k">try</span> {
            <span class="pl-s1">t2</span>.<span class="pl-en">join</span>();
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">hs1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">hs2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">hs1</span> == <span class="pl-s1">hs2</span>);<span class="pl-c">//true</span>
    }

}</pre></div>
<h4>6.1.2 懒汉式线程安全问题</h4>
<p>懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象</p>
<p>形式一：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">single</span>.<span class="pl-s1">lazy</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">LazyOne</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">LazyOne</span> <span class="pl-s1">instance</span>;

    <span class="pl-k">private</span> <span class="pl-smi">LazyOne</span>(){}

    <span class="pl-c">//方式1：</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">synchronized</span> <span class="pl-smi">LazyOne</span> <span class="pl-en">getInstance1</span>(){
        <span class="pl-k">if</span>(<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>){
            <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">LazyOne</span>();
        }
        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }
    <span class="pl-c">//方式2：</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">LazyOne</span> <span class="pl-en">getInstance2</span>(){
        <span class="pl-k">synchronized</span>(<span class="pl-smi">LazyOne</span>.<span class="pl-k">class</span>) {
            <span class="pl-k">if</span> (<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>) {
                <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">LazyOne</span>();
            }
            <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
        }
    }
    <span class="pl-c">//方式3：</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">LazyOne</span> <span class="pl-en">getInstance3</span>(){
        <span class="pl-k">if</span>(<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>){
            <span class="pl-k">synchronized</span> (<span class="pl-smi">LazyOne</span>.<span class="pl-k">class</span>) {
                <span class="pl-k">try</span> {
                    <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">10</span>);<span class="pl-c">//加这个代码，暴露问题</span>
                } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                    <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                }
                <span class="pl-k">if</span>(<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>){
                    <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">LazyOne</span>();
                }
            }
        }

        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }
    <span class="pl-c">/*</span>
<span class="pl-c">    注意：上述方式3中，有指令重排问题</span>
<span class="pl-c">    mem = allocate(); 为单例对象分配内存空间</span>
<span class="pl-c">    instance = mem;   instance引用现在非空，但还未初始化</span>
<span class="pl-c">    ctorSingleton(instance); 为单例对象通过instance调用构造器</span>
<span class="pl-c">    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要   </span>
<span class="pl-c">    volatile关键字，避免指令重排。</span>
<span class="pl-c">    */</span>
    
}</pre></div>
<p>形式二：使用内部类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">single</span>.<span class="pl-s1">lazy</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">LazySingle</span> {
    <span class="pl-k">private</span> <span class="pl-smi">LazySingle</span>(){}
    
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">LazySingle</span> <span class="pl-en">getInstance</span>(){
        <span class="pl-k">return</span> <span class="pl-smi">Inner</span>.<span class="pl-c1">INSTANCE</span>;
    }
    
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-smi">Inner</span>{
        <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">LazySingle</span> <span class="pl-c1">INSTANCE</span> = <span class="pl-k">new</span> <span class="pl-smi">LazySingle</span>();
    }
    
}</pre></div>
<blockquote>
<p>内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。</p>
<p>此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。</p>
<p>此时的内部类，使用enum进行定义，也是可以的。</p>
</blockquote>
<p>测试类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">single</span>.<span class="pl-s1">lazy</span>;

<span class="pl-k">import</span> <span class="pl-s1">org</span>.<span class="pl-s1">junit</span>.<span class="pl-s1">Test</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestLazy</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test01</span>(){
        <span class="pl-smi">LazyOne</span> <span class="pl-s1">s1</span> = <span class="pl-smi">LazyOne</span>.<span class="pl-en">getInstance</span>();
        <span class="pl-smi">LazyOne</span> <span class="pl-s1">s2</span> = <span class="pl-smi">LazyOne</span>.<span class="pl-en">getInstance</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>);
    }

    <span class="pl-c">//把s1和s2声明在外面，是想要在线程的匿名内部类中为s1和s2赋值</span>
    <span class="pl-smi">LazyOne</span> <span class="pl-s1">s1</span>;
    <span class="pl-smi">LazyOne</span> <span class="pl-s1">s2</span>;
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test02</span>(){
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>(){
                <span class="pl-s1">s1</span> = <span class="pl-smi">LazyOne</span>.<span class="pl-en">getInstance</span>();
            }
        };
        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>(){
                <span class="pl-s1">s2</span> = <span class="pl-smi">LazyOne</span>.<span class="pl-en">getInstance</span>();
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();

        <span class="pl-k">try</span> {
            <span class="pl-s1">t1</span>.<span class="pl-en">join</span>();
            <span class="pl-s1">t2</span>.<span class="pl-en">join</span>();
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>);
    }


    <span class="pl-smi">LazySingle</span> <span class="pl-s1">obj1</span>;
    <span class="pl-smi">LazySingle</span> <span class="pl-s1">obj2</span>;
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test03</span>(){
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>(){
                <span class="pl-s1">obj1</span> = <span class="pl-smi">LazySingle</span>.<span class="pl-en">getInstance</span>();
            }
        };
        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>(){
                <span class="pl-s1">obj2</span> = <span class="pl-smi">LazySingle</span>.<span class="pl-en">getInstance</span>();
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();

        <span class="pl-k">try</span> {
            <span class="pl-s1">t1</span>.<span class="pl-en">join</span>();
            <span class="pl-s1">t2</span>.<span class="pl-en">join</span>();
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">obj1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">obj2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">obj1</span> == <span class="pl-s1">obj2</span>);
    }
}</pre></div>
<p>三种方案实现线程安全</p>
<h3>1. 同步整个方法</h3>
<p>这种方法简单直接，通过将<code class="notranslate">getInstance</code>方法声明为<code class="notranslate">synchronized</code>来保证线程安全。但是这样做会降低程序的性能，因为每次调用<code class="notranslate">getInstance</code>时都会锁住整个方法，即使<code class="notranslate">instance</code>已经被初始化了。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">BankTest</span> {
    <span class="pl-c">//static Bank bank = new Bank();</span>
    <span class="pl-c">//static Bank bank2 = new Bank();</span>

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Bank</span> {
    <span class="pl-k">private</span> <span class="pl-smi">Bank</span>() {}

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-s1">instance</span> = <span class="pl-c1">null</span>;

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">synchronized</span> <span class="pl-smi">Bank</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">if</span> (<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>) {
            <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">Bank</span>();
        }
        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }
}</pre></div>
<h3>2. 双重检查锁定（Double-Check Locking）</h3>
<p>这是更高效的实现方式，它只在<code class="notranslate">instance</code>未被初始化时进行同步操作。这样可以避免每次调用<code class="notranslate">getInstance</code>时都进行同步，提高了性能。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">BankTest</span> {
    <span class="pl-c">//static Bank bank = new Bank();</span>
    <span class="pl-c">//static Bank bank2 = new Bank();</span>

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Bank</span> {
    <span class="pl-k">private</span> <span class="pl-smi">Bank</span>() {}

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">volatile</span> <span class="pl-smi">Bank</span> <span class="pl-s1">instance</span> = <span class="pl-c1">null</span>;

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">if</span> (<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>) { <span class="pl-c">// 第一次检查</span>
            <span class="pl-k">synchronized</span> (<span class="pl-smi">Bank</span>.<span class="pl-k">class</span>) {
                <span class="pl-k">if</span> (<span class="pl-s1">instance</span> == <span class="pl-c1">null</span>) { <span class="pl-c">// 第二次检查</span>
                    <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">Bank</span>();
                }
            }
        }
        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }
}</pre></div>
<h3>3. 静态内部类</h3>
<p>这是最推荐的方式，因为它既保证了线程安全，又避免了同步带来的性能损失。静态内部类在第一次被加载时才会初始化，因此是延迟加载的。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">BankTest</span> {
    <span class="pl-c">//static Bank bank = new Bank();</span>
    <span class="pl-c">//static Bank bank2 = new Bank();</span>

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>());
            }
        };

        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Bank</span> {
    <span class="pl-k">private</span> <span class="pl-smi">Bank</span>() {}

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-smi">BankHolder</span> {
        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Bank</span> <span class="pl-c1">INSTANCE</span> = <span class="pl-k">new</span> <span class="pl-smi">Bank</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-smi">BankHolder</span>.<span class="pl-c1">INSTANCE</span>;
    }
}</pre></div>
<h3>总结</h3>
<ul>
<li><strong>同步整个方法</strong>：简单但性能较差，每次调用<code class="notranslate">getInstance</code>都会加锁。</li>
<li><strong>双重检查锁定</strong>：性能较好，只在<code class="notranslate">instance</code>未被初始化时进行同步。</li>
<li><strong>静态内部类</strong>：推荐使用，既线程安全又延迟加载，性能最好。</li>
</ul>
<p>你可以根据具体需求选择适合的实现方式。希望这些示例对你有所帮助！</p>
<h3>6.2 死锁</h3>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/thread-lock.png"><img src="images/thread-lock.png" alt="" style="max-width: 100%;"></a></p>
<blockquote>
<p>【小故事】</p>
<p>面试官：你能解释清楚什么是死锁，我就录取你！<br>
面试者：你录取我，我就告诉你什么是死锁！<br>
….<br>
恭喜你，面试通过了</p>
</blockquote>
<p>1.如何看待死锁?</p>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p>
<p>我们编写程序时，要避免出现死锁。</p>
<p>2.诱发死锁的原因?</p>
<p>互斥条件</p>
<p>占用且等待</p>
<p>不可抢夺(或不可抢占)</p>
<p>循环等待</p>
<p>以上4个条件，同时出现就会触发死锁。</p>
<p>3.如何避免死锁?</p>
<p>针对条件1:互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</p>
<p>针对条件2:可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p>
<p>针对条件3:占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p>
<p>针对条件4:可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p>
<p>1.步骤:</p>
<p>步骤1.创建Lock的实例，需要确保多个线程共用同一个Lock实例!需要考虑将此对象声明为static final</p>
<p>步骤2.执行lock()方法，锁定对共享资源的调用</p>
<p>步骤了.unlock(的调用，释放对共享数据的锁定</p>
<p>2.面试题:</p>
<p>synchronized同步的方式与Lock的对比?</p>
<p>synchronized不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放对同步监视器的调用</p>
<p>-ock是通过两个方法控制需要被同步的代码，更灵活一些。</p>
<p>Lock作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高。</p>
<p>一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。</p>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DeadLockTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {

        <span class="pl-smi">StringBuilder</span> <span class="pl-s1">s1</span> = <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-smi">StringBuilder</span> <span class="pl-s1">s2</span> = <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();

        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-k">synchronized</span> (<span class="pl-s1">s1</span>) {
                    <span class="pl-s1">s1</span>.<span class="pl-en">append</span>(<span class="pl-s">"a"</span>);
                    <span class="pl-s1">s2</span>.<span class="pl-en">append</span>(<span class="pl-s">"1"</span>);
                    
                    <span class="pl-k">try</span> {
                        <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">10</span>);
                    } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                        <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                    }

                    <span class="pl-k">synchronized</span> (<span class="pl-s1">s2</span>) {
                        <span class="pl-s1">s1</span>.<span class="pl-en">append</span>(<span class="pl-s">"b"</span>);
                        <span class="pl-s1">s2</span>.<span class="pl-en">append</span>(<span class="pl-s">"2"</span>);

                        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
                        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);

                    }
                }
            }
        }.<span class="pl-en">start</span>();

        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>() {
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-k">synchronized</span> (<span class="pl-s1">s2</span>) {
                    <span class="pl-s1">s1</span>.<span class="pl-en">append</span>(<span class="pl-s">"c"</span>);
                    <span class="pl-s1">s2</span>.<span class="pl-en">append</span>(<span class="pl-s">"3"</span>);

                    <span class="pl-k">try</span> {
                        <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">10</span>);
                    } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                        <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                    }
                    
                    <span class="pl-k">synchronized</span> (<span class="pl-s1">s1</span>) {
                        <span class="pl-s1">s1</span>.<span class="pl-en">append</span>(<span class="pl-s">"d"</span>);
                        <span class="pl-s1">s2</span>.<span class="pl-en">append</span>(<span class="pl-s">"4"</span>);

                        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
                        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);

                    }

                }
            }
        }.<span class="pl-en">start</span>();

    }
}</pre></div>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span> {
    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">foo</span>(<span class="pl-smi">B</span> <span class="pl-s1">b</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"当前线程名: "</span> + <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>()
                + <span class="pl-s">" 进入了A实例的foo方法"</span>); <span class="pl-c">// ①</span>
        <span class="pl-k">try</span> {
            <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">200</span>);
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">ex</span>) {
            <span class="pl-s1">ex</span>.<span class="pl-en">printStackTrace</span>();
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"当前线程名: "</span> + <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>()
                + <span class="pl-s">" 企图调用B实例的last方法"</span>); <span class="pl-c">// ③</span>
        <span class="pl-s1">b</span>.<span class="pl-en">last</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">last</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"进入了A类的last方法内部"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">B</span> {
    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">bar</span>(<span class="pl-smi">A</span> <span class="pl-s1">a</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"当前线程名: "</span> + <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>()
                + <span class="pl-s">" 进入了B实例的bar方法"</span>); <span class="pl-c">// ②</span>
        <span class="pl-k">try</span> {
            <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">200</span>);
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">ex</span>) {
            <span class="pl-s1">ex</span>.<span class="pl-en">printStackTrace</span>();
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"当前线程名: "</span> + <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>()
                + <span class="pl-s">" 企图调用A实例的last方法"</span>); <span class="pl-c">// ④</span>
        <span class="pl-s1">a</span>.<span class="pl-en">last</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">last</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"进入了B类的last方法内部"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DeadLock</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span> {
    <span class="pl-smi">A</span> <span class="pl-s1">a</span> = <span class="pl-k">new</span> <span class="pl-smi">A</span>();
    <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">init</span>() {
        <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">setName</span>(<span class="pl-s">"主线程"</span>);
        <span class="pl-c">// 调用a对象的foo方法</span>
        <span class="pl-s1">a</span>.<span class="pl-en">foo</span>(<span class="pl-s1">b</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"进入了主线程之后"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">setName</span>(<span class="pl-s">"副线程"</span>);
        <span class="pl-c">// 调用b对象的bar方法</span>
        <span class="pl-s1">b</span>.<span class="pl-en">bar</span>(<span class="pl-s1">a</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"进入了副线程之后"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">DeadLock</span> <span class="pl-s1">dl</span> = <span class="pl-k">new</span> <span class="pl-smi">DeadLock</span>();
        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">dl</span>).<span class="pl-en">start</span>();
        <span class="pl-s1">dl</span>.<span class="pl-en">init</span>();
    }
}</pre></div>
<p>举例3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestDeadLock</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Object</span> <span class="pl-s1">g</span> = <span class="pl-k">new</span> <span class="pl-smi">Object</span>();
        <span class="pl-smi">Object</span> <span class="pl-s1">m</span> = <span class="pl-k">new</span> <span class="pl-smi">Object</span>();
        <span class="pl-smi">Owner</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Owner</span>(<span class="pl-s1">g</span>,<span class="pl-s1">m</span>);
        <span class="pl-smi">Customer</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Customer</span>(<span class="pl-s1">g</span>,<span class="pl-s1">m</span>);
        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">s</span>).<span class="pl-en">start</span>();
        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">c</span>).<span class="pl-en">start</span>();
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Owner</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span>{
    <span class="pl-k">private</span> <span class="pl-smi">Object</span> <span class="pl-s1">goods</span>;
    <span class="pl-k">private</span> <span class="pl-smi">Object</span> <span class="pl-s1">money</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Owner</span>(<span class="pl-smi">Object</span> <span class="pl-s1">goods</span>, <span class="pl-smi">Object</span> <span class="pl-s1">money</span>) {
        <span class="pl-en">super</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">goods</span> = <span class="pl-s1">goods</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">money</span> = <span class="pl-s1">money</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-k">synchronized</span> (<span class="pl-s1">goods</span>) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"先给钱"</span>);
            <span class="pl-k">synchronized</span> (<span class="pl-s1">money</span>) {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"发货"</span>);
            }
        }
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Customer</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span>{
    <span class="pl-k">private</span> <span class="pl-smi">Object</span> <span class="pl-s1">goods</span>;
    <span class="pl-k">private</span> <span class="pl-smi">Object</span> <span class="pl-s1">money</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Customer</span>(<span class="pl-smi">Object</span> <span class="pl-s1">goods</span>, <span class="pl-smi">Object</span> <span class="pl-s1">money</span>) {
        <span class="pl-en">super</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">goods</span> = <span class="pl-s1">goods</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">money</span> = <span class="pl-s1">money</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-k">synchronized</span> (<span class="pl-s1">money</span>) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"先发货"</span>);
            <span class="pl-k">synchronized</span> (<span class="pl-s1">goods</span>) {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"再给钱"</span>);
            }
        }
    }
}</pre></div>
<p><strong>诱发死锁的原因：</strong></p>
<ul>
<li>互斥条件</li>
<li>占用且等待</li>
<li>不可抢夺（或不可抢占）</li>
<li>循环等待</li>
</ul>
<p>以上4个条件，同时出现就会触发死锁。</p>
<p><strong>解决死锁：</strong></p>
<p>死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。</p>
<p>针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</p>
<p>针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p>
<p>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p>
<p>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p>
<h3>6.3 JDK5.0新特性：Lock(锁)</h3>
<ul>
<li>JDK5.0的新增功能，保证线程的安全。与采用synchronized相比，Lock可提供多种锁方案，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>在实现线程安全的控制中，比较常用的是<code class="notranslate">ReentrantLock</code>，可以显式加锁、释放锁。
<ul>
<li>ReentrantLock类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。</li>
</ul>
</li>
<li>Lock锁也称同步锁，加锁与释放锁方法，如下：
<ul>
<li>public void lock() :加同步锁。</li>
<li>public void unlock() :释放同步锁。</li>
</ul>
</li>
<li>代码结构</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-c">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">ReentrantLock</span> <span class="pl-s1">lock</span> = <span class="pl-k">new</span> <span class="pl-smi">ReenTrantLock</span>();
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">m</span>(){
        <span class="pl-c">//2. 调动lock()，实现需共享的代码的锁定</span>
        <span class="pl-s1">lock</span>.<span class="pl-en">lock</span>();
        <span class="pl-k">try</span>{
            <span class="pl-c">//保证线程安全的代码;</span>
        }
        <span class="pl-k">finally</span>{
            <span class="pl-c">//3. 调用unlock()，释放共享代码的锁定</span>
            <span class="pl-s1">lock</span>.<span class="pl-en">unlock</span>();  
        }
    }
}</pre></div>
<blockquote>
<p>注意：如果同步代码有异常，要将unlock()写入finally语句块。</p>
</blockquote>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">concurrent</span>.<span class="pl-s1">locks</span>.<span class="pl-s1">ReentrantLock</span>;

<span class="pl-k">class</span> <span class="pl-smi">Window</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span>{
    <span class="pl-smi">int</span> <span class="pl-s1">ticket</span> = <span class="pl-c1">100</span>;
    <span class="pl-c">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">ReentrantLock</span> <span class="pl-s1">lock</span> = <span class="pl-k">new</span> <span class="pl-smi">ReentrantLock</span>();
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>(){
        
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            <span class="pl-k">try</span>{
                <span class="pl-c">//2. 调动lock()，实现需共享的代码的锁定</span>
                <span class="pl-s1">lock</span>.<span class="pl-en">lock</span>();
                <span class="pl-k">if</span>(<span class="pl-s1">ticket</span> &gt; <span class="pl-c1">0</span>){
                    <span class="pl-k">try</span> {
                        <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">10</span>);
                    } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                        <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                    }
                    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">ticket</span>--);
                }<span class="pl-k">else</span>{
                    <span class="pl-k">break</span>;
                }
            }<span class="pl-k">finally</span>{
                <span class="pl-c">//3. 调用unlock()，释放共享代码的锁定</span>
                <span class="pl-s1">lock</span>.<span class="pl-en">unlock</span>();
            }
        }
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ThreadLock</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Window</span> <span class="pl-s1">t</span> = <span class="pl-k">new</span> <span class="pl-smi">Window</span>();
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">t</span>);
        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">t</span>);
        
        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();
    }
}</pre></div>
<p><strong>synchronized与Lock的对比</strong></p>
<ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。</li>
<li>（了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以</li>
<li>（了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以</li>
</ol>
<blockquote>
<p>说明：开发建议中处理线程安全问题优先使用顺序为：</p>
<p>•    Lock ----&gt; 同步代码块 ----&gt; 同步方法</p>
</blockquote>
<h2>7. 线程的通信</h2>
<h3>7.1 线程间通信</h3>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>当我们<code class="notranslate">需要多个线程</code>来共同完成一件任务，并且我们希望他们<code class="notranslate">有规律的执行</code>，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。</p>
<p>比如：线程A用来生产包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— <strong>等待唤醒机制。</strong></p>
<h3>7.2 等待唤醒机制</h3>
<p>这是多个线程间的一种<code class="notranslate">协作机制</code>。谈到线程我们经常想到的是线程间的<code class="notranslate">竞争（race）</code>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p>
<p>在一个线程满足某个条件时，就进入等待状态（<code class="notranslate">wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code class="notranslate">notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code class="notranslate">notifyAll()</code>来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 <code class="notranslate">wait set</code> 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个<code class="notranslate">特别的动作</code>，也即“<code class="notranslate">通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code class="notranslate">ready queue</code>）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li>
<li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li>
</ul>
</blockquote>
<h3>7.3 举例</h3>
<p>例题：使用两个线程打印 1-100。线程1, 线程2 交替打印</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Communication</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">1</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
            <span class="pl-k">synchronized</span> (<span class="pl-smi">this</span>) {
                <span class="pl-en">notify</span>();
                <span class="pl-k">if</span> (<span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>) {
                    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + <span class="pl-s">":"</span> + <span class="pl-s1">i</span>++);
                } <span class="pl-k">else</span>
                    <span class="pl-k">break</span>;
                <span class="pl-k">try</span> {
                    <span class="pl-en">wait</span>();
                } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                    <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                }
            }
        }
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">PrintNumber</span> {
    <span class="pl-c">// 定义一个锁对象</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Object</span> <span class="pl-s1">lock</span> = <span class="pl-k">new</span> <span class="pl-smi">Object</span>();
    <span class="pl-c">// 定义一个计数器</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">count</span> = <span class="pl-c1">1</span>;

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建两个线程，一个打印奇数，一个打印偶数</span>
        <span class="pl-smi">Thread</span> <span class="pl-s1">t1</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-k">new</span> <span class="pl-smi">PrintTask</span>(<span class="pl-c1">true</span>), <span class="pl-s">"Thread-1"</span>);
        <span class="pl-smi">Thread</span> <span class="pl-s1">t2</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-k">new</span> <span class="pl-smi">PrintTask</span>(<span class="pl-c1">false</span>), <span class="pl-s">"Thread-2"</span>);

        <span class="pl-c">// 启动线程</span>
        <span class="pl-s1">t1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">t2</span>.<span class="pl-en">start</span>();
    }

    <span class="pl-c">// 定义一个打印任务的内部类</span>
    <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-smi">PrintTask</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span> {
        <span class="pl-c">// 定义一个布尔变量，用于判断是打印奇数还是偶数</span>
        <span class="pl-k">private</span> <span class="pl-smi">boolean</span> <span class="pl-s1">isOdd</span>;

        <span class="pl-c">// 构造方法，传入布尔变量</span>
        <span class="pl-k">public</span> <span class="pl-smi">PrintTask</span>(<span class="pl-smi">boolean</span> <span class="pl-s1">isOdd</span>) {
            <span class="pl-smi">this</span>.<span class="pl-s1">isOdd</span> = <span class="pl-s1">isOdd</span>;
        }

        <span class="pl-c1">@</span><span class="pl-c1">Override</span>
        <span class="pl-c">// 实现Runnable接口的run方法</span>
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
            <span class="pl-c">// 循环打印数字</span>
            <span class="pl-k">while</span> (<span class="pl-s1">count</span> &lt;= <span class="pl-c1">100</span>) {
                <span class="pl-c">// 加锁</span>
                <span class="pl-k">synchronized</span> (<span class="pl-s1">lock</span>) {
                    <span class="pl-c">// 判断是否打印奇数或偶数</span>
                    <span class="pl-k">if</span> ((<span class="pl-s1">count</span> % <span class="pl-c1">2</span> == <span class="pl-c1">1</span> &amp;&amp; <span class="pl-s1">isOdd</span>) || (<span class="pl-s1">count</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span> &amp;&amp; !<span class="pl-s1">isOdd</span>)) {
                        <span class="pl-c">// 打印数字</span>
                        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + <span class="pl-s">": "</span> + <span class="pl-s1">count</span>++);
                        <span class="pl-c">// 唤醒其他线程</span>
                        <span class="pl-s1">lock</span>.<span class="pl-en">notify</span>();
                    } <span class="pl-k">else</span> {
                        <span class="pl-c">// 如果不是当前线程应该打印的数字，则等待</span>
                        <span class="pl-k">try</span> {
                            <span class="pl-s1">lock</span>.<span class="pl-en">wait</span>();
                        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
                        }
                    }
                }
            }
        }
    }
}</pre></div>
<p>sleep 和 wait 的区别 sleep 不会释放同步监视器</p>
<h3>7.4 调用wait和notify需注意的细节</h3>
<ol>
<li>wait方法与notify方法必须要由<code class="notranslate">同一个锁对象调用</code>。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在<code class="notranslate">同步代码块</code>或者是<code class="notranslate">同步函数</code>中使用。因为：必须要<code class="notranslate">通过锁对象</code>调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。</li>
</ol>
<p>涉及到三个方法的使用:</p>
<p>wait():线程一旦执行此方法，就进入等待状态。同时，会释放对同步监视器的调用</p>
<p>notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。(如果被wait()的多个线程的优先级相同</p>
<p>随机唤醒一个)。被唤醒的线程从当初被wait的位置继续执行。</p>
<p>notifyALl():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<p>注意点:</p>
<p>此三个方法的使用，必须是在同步代码块或同步方法中，</p>
<p>(超纲:Lock需要配合Condition实现线程间的通信)</p>
<p>此三个方法的调用者，必须是同步监视器。否则，会报IllegalMonitorStateException异常</p>
<p>此三个方法声明在0bject类中。</p>
<ol>
<li><strong>此三个方法的使用必须是在同步代码块或同步方法中</strong>：
<ul>
<li>这是因为 <code class="notranslate">wait()</code>, <code class="notranslate">notify()</code>, 和 <code class="notranslate">notifyAll()</code> 方法需要在同步上下文中调用，以确保线程安全。如果尝试在非同步上下文中调用这些方法，将抛出 <code class="notranslate">IllegalMonitorStateException</code> 异常。</li>
</ul>
</li>
<li><strong>此三个方法的调用者必须是同步监视器</strong>：
<ul>
<li>同步监视器通常是指当前执行线程所持有的对象锁。如果一个线程没有持有对象的锁，那么它就不能调用这些方法，否则会抛出 <code class="notranslate">IllegalMonitorStateException</code> 异常。</li>
</ul>
</li>
<li><strong>此三个方法声明在Object类中</strong>：
<ul>
<li>这意味着所有的 Java 对象都可以使用这些方法，因为它们继承自 Object 类。</li>
</ul>
</li>
</ol>
<p>下面是使用这些方法的代码示例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">doSomething</span>() {
        <span class="pl-k">while</span> (<span class="pl-s1">conditionNotMet</span>) {
            <span class="pl-k">try</span> {
                <span class="pl-en">wait</span>(); <span class="pl-c">// 调用 wait() 方法，释放锁并等待</span>
            } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }
        }
        <span class="pl-c">// 执行一些操作</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">changeCondition</span>() {
        <span class="pl-c">// 改变条件</span>
        <span class="pl-s1">conditionNotMet</span> = <span class="pl-c1">false</span>;
        <span class="pl-en">notifyAll</span>(); <span class="pl-c">// 唤醒所有等待的线程</span>
    }
}</pre></div>
<p>在这个例子中，<code class="notranslate">doSomething()</code> 方法是一个同步方法，它在条件不满足时调用 <code class="notranslate">wait()</code> 方法，使得当前线程等待，并且释放锁。<code class="notranslate">changeCondition()</code> 方法也是一个同步方法，它在条件改变时调用 <code class="notranslate">notifyAll()</code> 方法，唤醒所有等待的线程。</p>
<p>请注意，<code class="notranslate">wait()</code> 方法会释放锁，允许其他线程进入同步块或方法，而 <code class="notranslate">notify()</code> 和 <code class="notranslate">notifyAll()</code> 方法则用于唤醒一个或所有等待的线程。</p>
<p>对比</p>
<ol>
<li><strong>声明的位置</strong>：
<ul>
<li><code class="notranslate">wait()</code>：声明在<code class="notranslate">Object</code>类中。</li>
<li><code class="notranslate">sleep()</code>：声明在<code class="notranslate">Thread</code>类中，是静态的。</li>
</ul>
</li>
<li><strong>使用的场景不同</strong>：
<ul>
<li><code class="notranslate">wait()</code>：只能在同步代码块或同步方法中使用。</li>
<li><code class="notranslate">sleep()</code>：可以在任何需要使用的场景中使用。</li>
</ul>
</li>
<li><strong>使用在同步代码块或同步方法中</strong>：
<ul>
<li><code class="notranslate">wait()</code>：一旦执行，会释放同步监视器（即当前线程持有的对象锁）。</li>
<li><code class="notranslate">sleep()</code>：一旦执行，不会释放同步监视器。</li>
</ul>
</li>
<li><strong>结束阻塞的方式</strong>：
<ul>
<li><code class="notranslate">wait()</code>：到达指定时间自动结束阻塞，或者通过被<code class="notranslate">notify()</code>或<code class="notranslate">notifyAll()</code>唤醒，结束阻塞。</li>
<li><code class="notranslate">sleep()</code>：到达指定时间自动结束阻塞。</li>
</ul>
</li>
</ol>
<h3>7.5 生产者与消费者问题</h3>
<p>等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）<code class="notranslate">共享固定大小缓冲区的线程</code>——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。</p>
<p>生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong></p>
<p><strong>举例：</strong></p>
<p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<p>类似的场景，比如厨师和服务员等。</p>
<p><strong>生产者与消费者问题中其实隐含了两个问题：</strong></p>
<ul>
<li>线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。</li>
<li>线程的协调工作问题：
<ul>
<li>要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ConsumerProducerTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Clerk</span> <span class="pl-s1">clerk</span> = <span class="pl-k">new</span> <span class="pl-smi">Clerk</span>();
        <span class="pl-smi">Producer</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Producer</span>(<span class="pl-s1">clerk</span>);
        
        <span class="pl-smi">Consumer</span> <span class="pl-s1">c1</span> = <span class="pl-k">new</span> <span class="pl-smi">Consumer</span>(<span class="pl-s1">clerk</span>);
        <span class="pl-smi">Consumer</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Consumer</span>(<span class="pl-s1">clerk</span>);
        
        <span class="pl-s1">p1</span>.<span class="pl-en">setName</span>(<span class="pl-s">"生产者1"</span>);
        <span class="pl-s1">c1</span>.<span class="pl-en">setName</span>(<span class="pl-s">"消费者1"</span>);
        <span class="pl-s1">c2</span>.<span class="pl-en">setName</span>(<span class="pl-s">"消费者2"</span>);
        
        <span class="pl-s1">p1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">c1</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">c2</span>.<span class="pl-en">start</span>();
    }
}

<span class="pl-c">//生产者</span>
<span class="pl-k">class</span> <span class="pl-smi">Producer</span> <span class="pl-k">extends</span> <span class="pl-smi">Thread</span>{
    <span class="pl-k">private</span> <span class="pl-smi">Clerk</span> <span class="pl-s1">clerk</span>;
    
    <span class="pl-k">public</span> <span class="pl-smi">Producer</span>(<span class="pl-smi">Clerk</span> <span class="pl-s1">clerk</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">clerk</span> = <span class="pl-s1">clerk</span>;
    }
    
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"=========生产者开始生产产品========"</span>);
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            
            <span class="pl-k">try</span> {
                <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">40</span>);
            } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }
            
            <span class="pl-c">//要求clerk去增加产品</span>
            <span class="pl-s1">clerk</span>.<span class="pl-en">addProduct</span>();
        }
    }
}

<span class="pl-c">//消费者</span>
<span class="pl-k">class</span> <span class="pl-smi">Consumer</span> <span class="pl-k">extends</span> <span class="pl-smi">Thread</span>{
    <span class="pl-k">private</span> <span class="pl-smi">Clerk</span> <span class="pl-s1">clerk</span>;
    
    <span class="pl-k">public</span> <span class="pl-smi">Consumer</span>(<span class="pl-smi">Clerk</span> <span class="pl-s1">clerk</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">clerk</span> = <span class="pl-s1">clerk</span>;
    }
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"=========消费者开始消费产品========"</span>);
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            
            <span class="pl-k">try</span> {
                <span class="pl-smi">Thread</span>.<span class="pl-en">sleep</span>(<span class="pl-c1">90</span>);
            } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }
            
            <span class="pl-c">//要求clerk去减少产品</span>
            <span class="pl-s1">clerk</span>.<span class="pl-en">minusProduct</span>();
        }
    }
}

<span class="pl-c">//资源类</span>
<span class="pl-k">class</span> <span class="pl-smi">Clerk</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">productNum</span> = <span class="pl-c1">0</span>;<span class="pl-c">//产品数量</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MAX_PRODUCT</span> = <span class="pl-c1">20</span>;
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MIN_PRODUCT</span> = <span class="pl-c1">1</span>;
    
    <span class="pl-c">//增加产品</span>
    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">addProduct</span>() {
        <span class="pl-k">if</span>(<span class="pl-s1">productNum</span> &lt; <span class="pl-c1">MAX_PRODUCT</span>){
            <span class="pl-s1">productNum</span>++;
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + 
                    <span class="pl-s">"生产了第"</span> + <span class="pl-s1">productNum</span> + <span class="pl-s">"个产品"</span>);
            <span class="pl-c">//唤醒消费者</span>
            <span class="pl-smi">this</span>.<span class="pl-en">notifyAll</span>();
        }<span class="pl-k">else</span>{
            
            <span class="pl-k">try</span> {
                <span class="pl-smi">this</span>.<span class="pl-en">wait</span>();
            } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }
        }
    }

    <span class="pl-c">//减少产品</span>
    <span class="pl-k">public</span> <span class="pl-k">synchronized</span> <span class="pl-smi">void</span> <span class="pl-en">minusProduct</span>() {
        <span class="pl-k">if</span>(<span class="pl-s1">productNum</span> &gt;= <span class="pl-c1">MIN_PRODUCT</span>){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + 
                    <span class="pl-s">"消费了第"</span> + <span class="pl-s1">productNum</span> + <span class="pl-s">"个产品"</span>);
            <span class="pl-s1">productNum</span>--;
            
            <span class="pl-c">//唤醒生产者</span>
            <span class="pl-smi">this</span>.<span class="pl-en">notifyAll</span>();
        }<span class="pl-k">else</span>{
            
            <span class="pl-k">try</span> {
                <span class="pl-smi">this</span>.<span class="pl-en">wait</span>();
            } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }
        }
    }
    
}</pre></div>
<h3>7.6 面试题：区分sleep()和wait()</h3>
<p>相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。</p>
<p>不同点：</p>
<p>① 定义方法所属的类：sleep():Thread中定义。  wait():Object中定义</p>
<p>② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中</p>
<p>③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器</p>
<p>④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间也可以无限等待直到notify或notifyAll。</p>
<p>sleep 在哪个线程里调用的就在哪里执行，与前面的对象无关</p>
<h3>7.7 是否释放锁的操作</h3>
<p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？</p>
<h4>7.7.1 释放锁的操作</h4>
<p>当前线程的同步方法、同步代码块执行结束。</p>
<p>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</p>
<p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致当前线程异常结束。</p>
<p>当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程被挂起，并释放锁。</p>
<h4>7.7.2 不会释放锁的操作</h4>
<p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。</p>
<p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。</p>
<ul>
<li>应尽量避免使用suspend()和resume()这样的过时来控制线程。</li>
</ul>
<h2>8. JDK5.0新增线程创建方式</h2>
<p>创建多线程的方式三:实现callable(jdk5.0新增的)<br>
1， 与之前的方式的对比:与Runnable方式的对比的好处</p>
<blockquote>
<p>call()可以有返回值，更灵活<br>
call()可以使用throws的方式处理异常，更灵活<br>
Callable使用了泛型参数，可以指明具体的call()的返回值类型，更灵活<br>
有缺点吗?如果在主线程中需要获取分线程call()的返回值，则此时的主线程是阻塞状态的。</p>
</blockquote>
<p>2.创建多线程的方式四:使用线程池</p>
<p>此方式的好处:</p>
<p>提高了程序执行的效率。(因为线程已经提前创建好了)</p>
<p>提高了资源的复用率。(因为执行完的线程并未销毁，而是可以继续执行其他的任务)</p>
<p>可以设置相关的参数，对线程池中的线程的使用进行管理</p>
<h2>8.1 新增方式一：实现Callable接口</h2>
<ul>
<li>与使用Runnable相比， Callable功能更强大些
<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值（需要借助FutureTask类，获取返回结果）</li>
</ul>
</li>
<li>Future接口（了解）
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
<li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li>
<li>代码举例</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c"> * 创建多线程的方式三：实现Callable （jdk5.0新增的）</span>
<span class="pl-c"> */</span>
<span class="pl-c">//1.创建一个实现Callable的实现类</span>
<span class="pl-k">class</span> <span class="pl-smi">NumThread</span> <span class="pl-k">implements</span> <span class="pl-smi">Callable</span> {
    <span class="pl-c">//2.实现call方法，将此线程需要执行的操作声明在call()中</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">Object</span> <span class="pl-en">call</span>() <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
        <span class="pl-smi">int</span> <span class="pl-s1">sum</span> = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">1</span>; <span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-k">if</span> (<span class="pl-s1">i</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>) {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">i</span>);
                <span class="pl-s1">sum</span> += <span class="pl-s1">i</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-s1">sum</span>;
    }
}


<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CallableTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//3.创建Callable接口实现类的对象</span>
        <span class="pl-smi">NumThread</span> <span class="pl-s1">numThread</span> = <span class="pl-k">new</span> <span class="pl-smi">NumThread</span>();

        <span class="pl-c">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span>
        <span class="pl-smi">FutureTask</span> <span class="pl-s1">futureTask</span> = <span class="pl-k">new</span> <span class="pl-smi">FutureTask</span>(<span class="pl-s1">numThread</span>);
        <span class="pl-c">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span>
        <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-s1">futureTask</span>).<span class="pl-en">start</span>();


<span class="pl-c">//      接收返回值</span>
        <span class="pl-k">try</span> {
            <span class="pl-c">//6.获取Callable中call方法的返回值</span>
            <span class="pl-c">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span>
            <span class="pl-smi">Object</span> <span class="pl-s1">sum</span> = <span class="pl-s1">futureTask</span>.<span class="pl-en">get</span>();
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"总和为："</span> + <span class="pl-s1">sum</span>);
        } <span class="pl-k">catch</span> (<span class="pl-smi">InterruptedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        } <span class="pl-k">catch</span> (<span class="pl-smi">ExecutionException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }
    }

}</pre></div>
<h3>8.2 新增方式二：使用线程池</h3>
<p><strong>现有问题：</strong></p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>**思路：**提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3.jpg"><img src="images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3.jpg" alt="" style="max-width: 100%;"></a></p>
<p><strong>好处：</strong></p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>线程池相关API</strong></p>
<ul>
<li>JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：<code class="notranslate">ExecutorService</code> 和 <code class="notranslate">Executors</code>。</li>
<li><code class="notranslate">ExecutorService</code>：真正的线程池接口。常见子类ThreadPoolExecutor
<ul>
<li><code class="notranslate">void execute(Runnable command)</code> ：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><code class="notranslate">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</li>
<li><code class="notranslate">void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><code class="notranslate">Executors</code>：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。
<ul>
<li><code class="notranslate">Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</li>
<li><code class="notranslate">Executors.newFixedThreadPool(int nThreads)</code>; 创建一个可重用固定线程数的线程池</li>
<li><code class="notranslate">Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</li>
<li><code class="notranslate">Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li>
</ul>
</li>
</ul>
<p><strong>代码举例：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">NumberThread</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span>{

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-k">for</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>;<span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>;<span class="pl-s1">i</span>++){
            <span class="pl-k">if</span>(<span class="pl-s1">i</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + <span class="pl-s">": "</span> + <span class="pl-s1">i</span>);
            }
        }
    }
}

<span class="pl-k">class</span> <span class="pl-smi">NumberThread1</span> <span class="pl-k">implements</span> <span class="pl-smi">Runnable</span>{

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-k">for</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>;<span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>;<span class="pl-s1">i</span>++){
            <span class="pl-k">if</span>(<span class="pl-s1">i</span> % <span class="pl-c1">2</span> != <span class="pl-c1">0</span>){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Thread</span>.<span class="pl-en">currentThread</span>().<span class="pl-en">getName</span>() + <span class="pl-s">": "</span> + <span class="pl-s1">i</span>);
            }
        }
    }
}

<span class="pl-k">class</span> <span class="pl-smi">NumberThread2</span> <span class="pl-k">implements</span> <span class="pl-smi">Callable</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">Object</span> <span class="pl-en">call</span>() <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
        <span class="pl-smi">int</span> <span class="pl-s1">evenSum</span> = <span class="pl-c1">0</span>;<span class="pl-c">//记录偶数的和</span>
        <span class="pl-k">for</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>;<span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>;<span class="pl-s1">i</span>++){
            <span class="pl-k">if</span>(<span class="pl-s1">i</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>){
                <span class="pl-s1">evenSum</span> += <span class="pl-s1">i</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-s1">evenSum</span>;
    }

}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ThreadPoolTest</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//1. 提供指定线程数量的线程池</span>
        <span class="pl-smi">ExecutorService</span> <span class="pl-s1">service</span> = <span class="pl-smi">Executors</span>.<span class="pl-en">newFixedThreadPool</span>(<span class="pl-c1">10</span>);
        <span class="pl-smi">ThreadPoolExecutor</span> <span class="pl-s1">service1</span> = (<span class="pl-smi">ThreadPoolExecutor</span>) <span class="pl-s1">service</span>;
<span class="pl-c">//        //设置线程池的属性</span>
<span class="pl-c">//        System.out.println(service.getClass());//ThreadPoolExecutor</span>
        <span class="pl-s1">service1</span>.<span class="pl-en">setMaximumPoolSize</span>(<span class="pl-c1">50</span>); <span class="pl-c">//设置线程池中线程数的上限</span>

        <span class="pl-c">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span>
        <span class="pl-s1">service</span>.<span class="pl-en">execute</span>(<span class="pl-k">new</span> <span class="pl-smi">NumberThread</span>());<span class="pl-c">//适合适用于Runnable</span>
        <span class="pl-s1">service</span>.<span class="pl-en">execute</span>(<span class="pl-k">new</span> <span class="pl-smi">NumberThread1</span>());<span class="pl-c">//适合适用于Runnable</span>

        <span class="pl-k">try</span> {
            <span class="pl-smi">Future</span> <span class="pl-s1">future</span> = <span class="pl-s1">service</span>.<span class="pl-en">submit</span>(<span class="pl-k">new</span> <span class="pl-smi">NumberThread2</span>());<span class="pl-c">//适合使用于Callable</span>
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"总和为："</span> + <span class="pl-s1">future</span>.<span class="pl-en">get</span>());
        } <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }
        <span class="pl-c">//3.关闭连接池</span>
        <span class="pl-s1">service</span>.<span class="pl-en">shutdown</span>();
    }

}</pre></div>
<h1>第11章_常用类和基础API</h1>
<p>1.String类的理解(以JDK8为例说明)<br>
1.1 类的声明<br>
public final class String<br>
implements java.io.Serializable, Comparable, CharSequence final:String是不可被继承的 Serializable:可序列化的接口。凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输。 Comparable:凡是实现此接口的类，其对象都可以比较大小。 1.2 内部声明的属性: jdk8中: private final char value[];//存储字符串数据的容器</p>
<blockquote>
<p>final :指明此value数组一日初始化，其地址就不可变，<br>
jdk9开始:为了节省内存空间，做了优化<br>
private final byte[] value;//存储字符串数据的容器<br>
字符串常量的存储位置</p>
</blockquote>
<p>1.2 内部声明的属性:<br>
jdk8中:<br>
private final char value[];//存储字符串数据的容器</p>
<blockquote>
<p>final :指明此valve数组一旦初始化，其地址就不可变<br>
jdk9开始:为了节省内存空间，做了优化<br>
private final byte[] value;//存储字符串数据的容器<br>
2.字符串常量的存储位置<br>
字符串常量都存储在字符串常量池(StringTable)中<br>
字符串常量池不允许存放两个相同的字符串常量。<br>
字符串常量池，在不同的jdk版本中，存放位置不同:<br>
jdk7之前:字符串常量池存放在方法区<br>
jdk7及之后:字符串常量池存放在堆空间。</p>
</blockquote>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StringDemo</span> {
    <span class="pl-c">//字符量常量池</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"hello"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"hello"</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">s4</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"hello"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>);<span class="pl-c">//true</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s3</span>);<span class="pl-c">//false</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//false</span>
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//String的不可变性</span>
<span class="pl-c">//当对字符串进行修改时，会在内存中创建新的对象</span>
<span class="pl-c">//当对字符串进行修改时，需要在内存中重新开辟空间，不能直接修改</span></pre></div>
<h4>String实例化的两种方式</h4>
<p>第1种方式:String s1="hello";</p>
<p>第2种方式:String s2 = new string("hello");</p>
<p>【面试题】</p>
<p>String s2 = new string("hello");在内存中创建了几个对象? 两个!</p>
<p>一个是堆空间中new的对象。另一个是在字符串常量池中生成的字面量。</p>
<h4>String的连接操作 :</h4>
<p>情况1:常量 + 常量:结果仍然存储在字符串常量池中，返回此字面量的地址。注:此时的常量可能是字面量，也可能是final修饰的常</p>
<p>情况2:常量 +变量或变量+变量 :都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址</p>
<p>情况了:调用字符串的intern():返回的是字符串常量池中字面量的地址</p>
<p>(了解)情况4:concat(xxx):不管是常量调用此方法，还是变量调用，同样不管参数是常量还是变量，总之，调用完concat()方法</p>
<p>都返回一个新new的对象。</p>
<h2>1. 字符串相关类之不可变字符序列：String</h2>
<h3>1.1 String的特性</h3>
<ul>
<li><code class="notranslate">java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如<code class="notranslate">"hello"</code> ）都可以看作是实现此类的实例。</li>
<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li>
<li>字符串String类型本身是final声明的，意味着我们不能继承String。</li>
<li>String对象的字符内容是存储在一个字符数组value[]中的。<code class="notranslate">"abc"</code> 等效于 <code class="notranslate">char[] data={'h','e','l','l','o'}</code>。</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//jdk8中的String源码：</span>
<span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">String</span>
    <span class="pl-k">implements</span> <span class="pl-smi">java</span>.<span class="pl-smi">io</span>.<span class="pl-smi">Serializable</span>, <span class="pl-smi">Comparable</span>&lt;<span class="pl-smi">String</span>&gt;, <span class="pl-smi">CharSequence</span> {
    <span class="pl-c">/** The value is used for character storage. */</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">char</span> <span class="pl-s1">value</span>[]; <span class="pl-c">//String对象的字符内容是存储在此数组中</span>
 
    <span class="pl-c">/** Cache the hash code for the string */</span>
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">hash</span>; <span class="pl-c">// Default to 0</span></pre></div>
<pre class="notranslate"><code class="notranslate">- private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法。
- final意味着字符数组的引用不可改变，而且String也没有提供方法来修改value数组某个元素值
- 因此字符串的字符数组内容也不可变的，即String代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。
- JDK9只有，底层使用byte[]数组。
</code></pre>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">String</span> <span class="pl-k">implements</span> <span class="pl-smi">java</span>.<span class="pl-smi">io</span>.<span class="pl-smi">Serializable</span>, <span class="pl-smi">Comparable</span>&lt;<span class="pl-smi">String</span>&gt;, <span class="pl-smi">CharSequence</span> { 
    <span class="pl-c1">@</span><span class="pl-c1">Stable</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">byte</span>[] <span class="pl-s1">value</span>;
}

<span class="pl-c">//官方说明：... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</span>

<span class="pl-c">//细节：... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</span></pre></div>
<ul>
<li>Java 语言提供对字符串串联符号（"+"）以及将其他对象转换为字符串的特殊支持（toString()方法）。</li>
</ul>
<h3>1.2 String的内存结构</h3>
<h4>1.2.1 概述</h4>
<p>因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象。</p>
<p>JDK6中，字符串常量池在方法区。JDK7开始，就移到堆空间，直到目前JDK17版本。</p>
<p>举例内存结构分配：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/1562945799274.png"><img src="images/1562945799274.png" alt="" style="max-width: 100%;"></a></p>
<h4>1.2.2 练习类型1：拼接</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"hello"</span>;
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>);
<span class="pl-c">// 内存中只有一个"hello"对象被创建，同时被s1和s2共享。</span></pre></div>
<p>对应内存结构为：（以下内存结构以<code class="notranslate">JDK6为例</code>绘制）：</p>
<p>进一步：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
<span class="pl-s1">p1</span>.<span class="pl-s1">name</span> = “<span class="pl-s1">Tom</span><span class="pl-s">";</span>
<span class="pl-s"></span>
<span class="pl-s">Person p2 = new Person();</span>
<span class="pl-s">p2.name = “Tom"</span>;

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">p1</span>.<span class="pl-s1">name</span>.<span class="pl-en">equals</span>( <span class="pl-s1">p2</span>.<span class="pl-s1">name</span>)); <span class="pl-c">//</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">p1</span>.<span class="pl-s1">name</span> == <span class="pl-s1">p2</span>.<span class="pl-s1">name</span>); <span class="pl-c">//</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">p1</span>.<span class="pl-s1">name</span> == <span class="pl-s">"Tom"</span>); <span class="pl-c">//</span></pre></div>
<h4>1.2.3 练习类型2：new</h4>
<p>String str1 = “abc”; 与 String str2 = new String(“abc”);的区别？</p>
<p>str2 首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组。</p>
<blockquote>
<ul>
<li>字符串常量存储在字符串常量池，目的是共享。</li>
<li>字符串非常量对象存储在堆中。</li>
</ul>
</blockquote>
<p>练习：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"javaEE"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"javaEE"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"javaEE"</span>);
<span class="pl-smi">String</span> <span class="pl-s1">s4</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"javaEE"</span>);

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>);<span class="pl-c">//true</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s3</span>);<span class="pl-c">//false</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//false</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//false</span></pre></div>
<p>练习：String str2 = new String("hello"); 在内存中创建了几个对象？</p>
<pre lang="plain" class="notranslate"><code class="notranslate">两个
</code></pre>
<h4>1.2.4 练习类型3：intern()</h4>
<ul>
<li><strong>String s1 = "a";</strong></li>
</ul>
<p>说明：在字符串常量池中创建了一个字面量为"a"的字符串。</p>
<ul>
<li><strong>s1 = s1 + "b";</strong></li>
</ul>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+"b"（也就是"ab")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p>
<ul>
<li><strong>String s2 = "ab";</strong></li>
</ul>
<p>说明：直接在字符串常量池中创建一个字面量为"ab"的字符串。</p>
<ul>
<li><strong>String s3 = "a" + "b";</strong></li>
</ul>
<p>说明：s3指向字符串常量池中已经创建的"ab"的字符串。</p>
<ul>
<li><strong>String s4 = s1.intern();</strong></li>
</ul>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的"ab"字符串赋值给s4。</p>
<p>练习：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"world"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-s">"hello"</span> + <span class="pl-s">"world"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s4</span> = <span class="pl-s1">s1</span> + <span class="pl-s">"world"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s5</span> = <span class="pl-s1">s1</span> + <span class="pl-s1">s2</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s6</span> = (<span class="pl-s1">s1</span> + <span class="pl-s1">s2</span>).<span class="pl-en">intern</span>();

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s5</span>);
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s4</span> == <span class="pl-s1">s5</span>);
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s6</span>);</pre></div>
<blockquote>
<p><strong>结论：</strong></p>
<p>（1）常量+常量：结果是常量池。且常量池中不会存在相同内容的常量。</p>
<p>（2）常量与变量 或 变量与变量：结果在堆中</p>
<p>（3）拼接后调用intern方法：返回值在常量池中</p>
</blockquote>
<p>练习：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
    <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"world"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-s">"helloworld"</span>;
        
    <span class="pl-smi">String</span> <span class="pl-s1">s4</span> = <span class="pl-s1">s1</span> + <span class="pl-s">"world"</span>;<span class="pl-c">//s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中</span>
    <span class="pl-smi">String</span> <span class="pl-s1">s5</span> = <span class="pl-s1">s1</span> + <span class="pl-s1">s2</span>;<span class="pl-c">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span>
    <span class="pl-smi">String</span> <span class="pl-s1">s6</span> = <span class="pl-s">"hello"</span> + <span class="pl-s">"world"</span>;<span class="pl-c">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span>
        
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//false</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s5</span>);<span class="pl-c">//false</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s6</span>);<span class="pl-c">//true</span>
}

<span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test02</span>(){
    <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
    <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"world"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-s">"helloworld"</span>;
    
    <span class="pl-smi">String</span> <span class="pl-s1">s4</span> = <span class="pl-s1">s1</span> + <span class="pl-s">"world"</span>;<span class="pl-c">//s4字符串内容也helloworld，s1是常量，"world"常量，常量+常量结果在常量池中</span>
    <span class="pl-smi">String</span> <span class="pl-s1">s5</span> = <span class="pl-s1">s1</span> + <span class="pl-s1">s2</span>;<span class="pl-c">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span>
    <span class="pl-smi">String</span> <span class="pl-s1">s6</span> = <span class="pl-s">"hello"</span> + <span class="pl-s">"world"</span>;<span class="pl-c">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span>
        
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//true</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s5</span>);<span class="pl-c">//true</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s6</span>);<span class="pl-c">//true</span>
}

<span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
    <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"hello"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"world"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-s">"helloworld"</span>;
        
    <span class="pl-smi">String</span> <span class="pl-s1">s4</span> = (<span class="pl-s1">s1</span> + <span class="pl-s">"world"</span>).<span class="pl-en">intern</span>();<span class="pl-c">//把拼接的结果放到常量池中</span>
    <span class="pl-smi">String</span> <span class="pl-s1">s5</span> = (<span class="pl-s1">s1</span> + <span class="pl-s1">s2</span>).<span class="pl-en">intern</span>();
        
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s4</span>);<span class="pl-c">//true</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span> == <span class="pl-s1">s5</span>);<span class="pl-c">//true</span>
}</pre></div>
<p>练习：下列程序运行的结果：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestString</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"hello"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-s">"world"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">str3</span> =<span class="pl-s">"helloworld"</span>;
        
        <span class="pl-smi">String</span> <span class="pl-s1">str4</span> = <span class="pl-s">"hello"</span>.<span class="pl-en">concat</span>(<span class="pl-s">"world"</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">str5</span> = <span class="pl-s">"hello"</span>+<span class="pl-s">"world"</span>;
        
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str3</span> == <span class="pl-s1">str4</span>);<span class="pl-c">//false</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str3</span> == <span class="pl-s1">str5</span>);<span class="pl-c">//true</span>
    }
}</pre></div>
<blockquote>
<p>concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。</p>
</blockquote>
<p>练习：下列程序运行的结果：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StringTest</span> {

    <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"good"</span>);
    <span class="pl-smi">char</span>[] <span class="pl-s1">ch</span> = { <span class="pl-s">'t'</span>, <span class="pl-s">'e'</span>, <span class="pl-s">'s'</span>, <span class="pl-s">'t'</span> };

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">change</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>, <span class="pl-smi">char</span> <span class="pl-s1">ch</span>[]) {
        <span class="pl-s1">str</span> = <span class="pl-s">"test ok"</span>;
        <span class="pl-s1">ch</span>[<span class="pl-c1">0</span>] = <span class="pl-s">'b'</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">StringTest</span> <span class="pl-s1">ex</span> = <span class="pl-k">new</span> <span class="pl-smi">StringTest</span>();
        <span class="pl-s1">ex</span>.<span class="pl-en">change</span>(<span class="pl-s1">ex</span>.<span class="pl-s1">str</span>, <span class="pl-s1">ex</span>.<span class="pl-s1">ch</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>(<span class="pl-s1">ex</span>.<span class="pl-s1">str</span> + <span class="pl-s">" and "</span>);<span class="pl-c">//</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">ex</span>.<span class="pl-s1">ch</span>);
    }
}</pre></div>
<h3>1.3 String的常用API-1</h3>
<h4>1.3.1 构造器</h4>
<ul>
<li><code class="notranslate">public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li>
<li><code class="notranslate"> String(String original)</code>： 初始化一个新创建的 <code class="notranslate">String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li>
<li><code class="notranslate">public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li>
<li><code class="notranslate">public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li>
<li><code class="notranslate">public String(byte[] bytes) </code> ：通过使用平台的<strong>默认字符集</strong>解码当前参数中的字节数组来构造新的String。</li>
<li><code class="notranslate">public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li>
</ul>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//字面量定义方式：字符串常量对象</span>
<span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"hello"</span>;

<span class="pl-c">//构造器定义方式：无参构造</span>
<span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>();

<span class="pl-c">//构造器定义方式：创建"hello"字符串常量的副本</span>
<span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"hello"</span>);

<span class="pl-c">//构造器定义方式：通过字符数组构造</span>
<span class="pl-smi">char</span> <span class="pl-s1">chars</span>[] = {<span class="pl-s">'a'</span>, <span class="pl-s">'b'</span>, <span class="pl-s">'c'</span>,<span class="pl-s">'d'</span>,<span class="pl-s">'e'</span>};     
<span class="pl-smi">String</span> <span class="pl-s1">str3</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">chars</span>);
<span class="pl-smi">String</span> <span class="pl-s1">str4</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">chars</span>,<span class="pl-c1">0</span>,<span class="pl-c1">3</span>);

<span class="pl-c">//构造器定义方式：通过字节数组构造</span>
<span class="pl-smi">byte</span> <span class="pl-s1">bytes</span>[] = {<span class="pl-c1">97</span>, <span class="pl-c1">98</span>, <span class="pl-c1">99</span> };     
<span class="pl-smi">String</span> <span class="pl-s1">str5</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">bytes</span>);
<span class="pl-smi">String</span> <span class="pl-s1">str6</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">bytes</span>,<span class="pl-s">"GBK"</span>);</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-s1">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
    <span class="pl-smi">char</span>[] <span class="pl-s1">data</span> = {<span class="pl-s">'h'</span>,<span class="pl-s">'e'</span>,<span class="pl-s">'l'</span>,<span class="pl-s">'l'</span>,<span class="pl-s">'o'</span>,<span class="pl-s">'j'</span>,<span class="pl-s">'a'</span>,<span class="pl-s">'v'</span>,<span class="pl-s">'a'</span>};
    <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-smi">String</span>.<span class="pl-en">copyValueOf</span>(<span class="pl-s1">data</span>);
    <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-smi">String</span>.<span class="pl-en">copyValueOf</span>(<span class="pl-s1">data</span>,<span class="pl-c1">0</span>,<span class="pl-c1">5</span>);
    <span class="pl-smi">int</span> <span class="pl-s1">num</span> = <span class="pl-c1">123456</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-smi">String</span>.<span class="pl-en">valueOf</span>(<span class="pl-s1">num</span>);
    
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span>);
}</pre></div>
<h4>1.3.2 String与其他结构间的转换</h4>
<p><strong>字符串 --&gt; 基本数据类型、包装类：</strong></p>
<ul>
<li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li>
<li>类似地，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li>
</ul>
<p><strong>基本数据类型、包装类 --&gt; 字符串：</strong></p>
<ul>
<li>调用String类的public String valueOf(int n)可将int型转换为字符串</li>
<li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换。</li>
</ul>
<p><strong>字符数组 --&gt;  字符串：</strong></p>
<ul>
<li>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>
</ul>
<p><strong>字符串 --&gt;  字符数组：</strong></p>
<ul>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</li>
<li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</li>
</ul>
<p><strong>字符串 --&gt; 字节数组：（编码）</strong></p>
<ul>
<li>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li>
<li>public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li>
</ul>
<p><strong>字节数组 --&gt; 字符串：（解码）</strong></p>
<ul>
<li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li>
<li>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li>
<li>String(byte[], String charsetName ) 或 new String(byte[], int, int,String charsetName )：解码，按照指定的编码方式进行解码。</li>
</ul>
<p>代码示例：</p>
<p>在 utf-8 中 一个汉字占用三个字节</p>
<p>在 gbk 中 一个汉字占用 2 个字节</p>
<p>utf8 与 gbk 都向下兼容了 ascii 码</p>
<p>编码与解码 编码用什么解码就要用什么 否则乱码</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>() <span class="pl-k">throws</span> <span class="pl-s1">Exception</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"中国"</span>;
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"ISO8859-1"</span>).<span class="pl-s1">length</span>);<span class="pl-c">// 2</span>
    <span class="pl-c">// ISO8859-1把所有的字符都当做一个byte处理，处理不了多个字节</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"GBK"</span>).<span class="pl-s1">length</span>);<span class="pl-c">// 4 每一个中文都是对应2个字节</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"UTF-8"</span>).<span class="pl-s1">length</span>);<span class="pl-c">// 6 常规的中文都是3个字节</span>

    <span class="pl-c">/*</span>
<span class="pl-c">     * 不乱码：（1）保证编码与解码的字符集名称一样（2）不缺字节</span>
<span class="pl-c">     */</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"ISO8859-1"</span>), <span class="pl-s">"ISO8859-1"</span>));<span class="pl-c">// 乱码</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"GBK"</span>), <span class="pl-s">"GBK"</span>));<span class="pl-c">// 中国</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">str</span>.<span class="pl-en">getBytes</span>(<span class="pl-s">"UTF-8"</span>), <span class="pl-s">"UTF-8"</span>));<span class="pl-c">// 中国</span>
}</pre></div>
<h3>1.4 String的常用API-2</h3>
<p><code class="notranslate">String</code> 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。</p>
<h4>1.4.1 系列1：常用方法</h4>
<p>（1）boolean isEmpty()：字符串是否为空<br>
（2）int length()：返回字符串的长度<br>
（3）String concat(xx)：拼接<br>
（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写<br>
（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写<br>
（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小<br>
（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写<br>
（8）String toLowerCase()：将字符串中大写字母转为小写<br>
（9）String toUpperCase()：将字符串中小写字母转为大写<br>
（10）String trim()：去掉字符串前后空白符<br>
（11）public String intern()：结果在常量池中共享</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
        <span class="pl-c">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span>
        <span class="pl-smi">Scanner</span> <span class="pl-s1">input</span> = <span class="pl-k">new</span> <span class="pl-smi">Scanner</span>(<span class="pl-smi">System</span>.<span class="pl-s1">in</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">word</span>;
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>(<span class="pl-s">"请输入单词："</span>);
            <span class="pl-s1">word</span> = <span class="pl-s1">input</span>.<span class="pl-en">nextLine</span>();
            <span class="pl-k">if</span>(<span class="pl-s1">word</span>.<span class="pl-en">trim</span>().<span class="pl-en">length</span>()!=<span class="pl-c1">0</span>){
                <span class="pl-s1">word</span> = <span class="pl-s1">word</span>.<span class="pl-en">toLowerCase</span>();
                <span class="pl-k">break</span>;
            }
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">word</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test02</span>(){
        <span class="pl-c">//随机生成验证码，验证码由0-9，A-Z,a-z的字符组成</span>
        <span class="pl-smi">char</span>[] <span class="pl-s1">array</span> = <span class="pl-k">new</span> <span class="pl-smi">char</span>[<span class="pl-c1">26</span>*<span class="pl-c1">2</span>+<span class="pl-c1">10</span>];
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">10</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-s1">array</span>[<span class="pl-s1">i</span>] = (<span class="pl-smi">char</span>)(<span class="pl-s">'0'</span> + <span class="pl-s1">i</span>);
        }
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">10</span>,<span class="pl-s1">j</span>=<span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">10</span>+<span class="pl-c1">26</span>; <span class="pl-s1">i</span>++,<span class="pl-s1">j</span>++) {
            <span class="pl-s1">array</span>[<span class="pl-s1">i</span>] = (<span class="pl-smi">char</span>)(<span class="pl-s">'A'</span> + <span class="pl-s1">j</span>);
        }
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">10</span>+<span class="pl-c1">26</span>,<span class="pl-s1">j</span>=<span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">array</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++,<span class="pl-s1">j</span>++) {
            <span class="pl-s1">array</span>[<span class="pl-s1">i</span>] = (<span class="pl-smi">char</span>)(<span class="pl-s">'a'</span> + <span class="pl-s1">j</span>);
        }
        <span class="pl-smi">String</span> <span class="pl-s1">code</span> = <span class="pl-s">""</span>;
        <span class="pl-smi">Random</span> <span class="pl-s1">rand</span> = <span class="pl-k">new</span> <span class="pl-smi">Random</span>();
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">4</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-s1">code</span> += <span class="pl-s1">array</span>[<span class="pl-s1">rand</span>.<span class="pl-en">nextInt</span>(<span class="pl-s1">array</span>.<span class="pl-s1">length</span>)];
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"验证码："</span> + <span class="pl-s1">code</span>);
        <span class="pl-c">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span>
        <span class="pl-smi">Scanner</span> <span class="pl-s1">input</span> = <span class="pl-k">new</span> <span class="pl-smi">Scanner</span>(<span class="pl-smi">System</span>.<span class="pl-s1">in</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>(<span class="pl-s">"请输入验证码："</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">inputCode</span> = <span class="pl-s1">input</span>.<span class="pl-en">nextLine</span>();
        
        <span class="pl-k">if</span>(!<span class="pl-s1">code</span>.<span class="pl-en">equalsIgnoreCase</span>(<span class="pl-s1">inputCode</span>)){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"验证码输入不正确"</span>);
        }
    }</pre></div>
<h4>1.4.2 系列2：查找</h4>
<p>（11）boolean contains(xx)：是否包含xx<br>
（12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1<br>
（13）int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>
（14）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1<br>
（15）int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"尚硅谷是一家靠谱的培训机构，尚硅谷可以说是IT培训的小清华，JavaEE是尚硅谷的当家学科，尚硅谷的大数据培训是行业独角兽。尚硅谷的前端和UI专业一样独领风骚。"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"是否包含清华："</span> + <span class="pl-s1">str</span>.<span class="pl-en">contains</span>(<span class="pl-s">"清华"</span>));
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"培训出现的第一次下标："</span> + <span class="pl-s1">str</span>.<span class="pl-en">indexOf</span>(<span class="pl-s">"培训"</span>));
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"培训出现的最后一次下标："</span> + <span class="pl-s1">str</span>.<span class="pl-en">lastIndexOf</span>(<span class="pl-s">"培训"</span>));
    }</pre></div>
<h4>1.4.3 系列3：字符串截取</h4>
<p>（16）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>
（17）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
    <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"helloworldjavaatguigu"</span>;
    <span class="pl-smi">String</span> <span class="pl-s1">sub1</span> = <span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-c1">5</span>);
    <span class="pl-smi">String</span> <span class="pl-s1">sub2</span> = <span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-c1">5</span>,<span class="pl-c1">10</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">sub1</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">sub2</span>);
}

<span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test02</span>(){
    <span class="pl-smi">String</span> <span class="pl-s1">fileName</span> = <span class="pl-s">"快速学习Java的秘诀.dat"</span>;
    <span class="pl-c">//截取文件名</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"文件名："</span> + <span class="pl-s1">fileName</span>.<span class="pl-en">substring</span>(<span class="pl-c1">0</span>,<span class="pl-s1">fileName</span>.<span class="pl-en">lastIndexOf</span>(<span class="pl-s">"."</span>)));
    <span class="pl-c">//截取后缀名</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"后缀名："</span> + <span class="pl-s1">fileName</span>.<span class="pl-en">substring</span>(<span class="pl-s1">fileName</span>.<span class="pl-en">lastIndexOf</span>(<span class="pl-s">"."</span>)));
}</pre></div>
<h4>1.4.4 系列4：和字符/字符数组相关</h4>
<p>（18）char charAt(index)：返回[index]位置的字符<br>
（19）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回<br>
（20）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String<br>
（21）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String<br>
（22）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String<br>
（23）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test01</span>(){
        <span class="pl-c">//将字符串中的字符按照大小顺序排列</span>
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"helloworldjavaatguigu"</span>;
        <span class="pl-smi">char</span>[] <span class="pl-s1">array</span> = <span class="pl-s1">str</span>.<span class="pl-en">toCharArray</span>();
        <span class="pl-smi">Arrays</span>.<span class="pl-en">sort</span>(<span class="pl-s1">array</span>);
        <span class="pl-s1">str</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">array</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span>);
    }
    
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test02</span>(){
        <span class="pl-c">//将首字母转为大写</span>
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"jack"</span>;
        <span class="pl-s1">str</span> = <span class="pl-smi">Character</span>.<span class="pl-en">toUpperCase</span>(<span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-c1">0</span>))+<span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-c1">1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span>);
    }
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test03</span>(){
        <span class="pl-smi">char</span>[] <span class="pl-s1">data</span> = {<span class="pl-s">'h'</span>,<span class="pl-s">'e'</span>,<span class="pl-s">'l'</span>,<span class="pl-s">'l'</span>,<span class="pl-s">'o'</span>,<span class="pl-s">'j'</span>,<span class="pl-s">'a'</span>,<span class="pl-s">'v'</span>,<span class="pl-s">'a'</span>};
        <span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-smi">String</span>.<span class="pl-en">copyValueOf</span>(<span class="pl-s1">data</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-smi">String</span>.<span class="pl-en">copyValueOf</span>(<span class="pl-s1">data</span>,<span class="pl-c1">0</span>,<span class="pl-c1">5</span>);
        <span class="pl-smi">int</span> <span class="pl-s1">num</span> = <span class="pl-c1">123456</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-smi">String</span>.<span class="pl-en">valueOf</span>(<span class="pl-s1">num</span>);
    
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span>);
    }</pre></div>
<h4>1.4.5 系列5：开头与结尾</h4>
<p>（24）boolean startsWith(xx)：测试此字符串是否以指定的前缀开始<br>
（25）boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>
（26）boolean endsWith(xx)：测试此字符串是否以指定的后缀结束</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test1</span>(){
        <span class="pl-smi">String</span> <span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">name</span>.<span class="pl-en">startsWith</span>(<span class="pl-s">"张"</span>));
    }
    
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test2</span>(){
        <span class="pl-smi">String</span> <span class="pl-s1">file</span> = <span class="pl-s">"Hello.txt"</span>;
        <span class="pl-k">if</span>(<span class="pl-s1">file</span>.<span class="pl-en">endsWith</span>(<span class="pl-s">".java"</span>)){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Java源文件"</span>);
        }<span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-s1">file</span>.<span class="pl-en">endsWith</span>(<span class="pl-s">".class"</span>)){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Java字节码文件"</span>);
        }<span class="pl-k">else</span>{
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"其他文件"</span>);
        }
    }</pre></div>
<h4>1.4.6 系列6：替换</h4>
<p>（27）String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。<br>
（28）String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>
（29）String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>
（30）String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Test</span>
<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">test1</span>(){
    <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-s">"hello244world.java;887"</span>;
    <span class="pl-c">//把其中的非字母去掉</span>
    <span class="pl-s1">str1</span> = <span class="pl-s1">str1</span>.<span class="pl-en">replaceAll</span>(<span class="pl-s">"[^a-zA-Z]"</span>, <span class="pl-s">""</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str1</span>);

    <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-s">"12hello34world5java7891mysql456"</span>;
    <span class="pl-c">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span>
    <span class="pl-smi">String</span> <span class="pl-s1">string</span> = <span class="pl-s1">str2</span>.<span class="pl-en">replaceAll</span>(<span class="pl-s">"<span class="pl-cce">\\</span>d+"</span>, <span class="pl-s">","</span>).<span class="pl-en">replaceAll</span>(<span class="pl-s">"^,|,$"</span>, <span class="pl-s">""</span>);
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">string</span>);

}</pre></div>
<h3>1.5 常见算法题目</h3>
<p>**题目1：**模拟一个trim方法，去除字符串两端的空格。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">myTrim</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">str</span> != <span class="pl-c1">null</span>) {
            <span class="pl-smi">int</span> <span class="pl-s1">start</span> = <span class="pl-c1">0</span>;<span class="pl-c">// 用于记录从前往后首次索引位置不是空格的位置的索引</span>
            <span class="pl-smi">int</span> <span class="pl-s1">end</span> = <span class="pl-s1">str</span>.<span class="pl-en">length</span>() - <span class="pl-c1">1</span>;<span class="pl-c">// 用于记录从后往前首次索引位置不是空格的位置的索引</span>

            <span class="pl-k">while</span> (<span class="pl-s1">start</span> &lt; <span class="pl-s1">end</span> &amp;&amp; <span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-s1">start</span>) == <span class="pl-s">' '</span>) {
                <span class="pl-s1">start</span>++;
            }

            <span class="pl-k">while</span> (<span class="pl-s1">start</span> &lt; <span class="pl-s1">end</span> &amp;&amp; <span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-s1">end</span>) == <span class="pl-s">' '</span>) {
                <span class="pl-s1">end</span>--;
            }
            <span class="pl-k">if</span> (<span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-s1">start</span>) == <span class="pl-s">' '</span>) {
                <span class="pl-k">return</span> <span class="pl-s">""</span>;
            }

            <span class="pl-k">return</span> <span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-s1">start</span>, <span class="pl-s1">end</span> + <span class="pl-c1">1</span>);
        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">testMyTrim</span>() {
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"   a   "</span>;
        <span class="pl-c">// str = " ";</span>
        <span class="pl-smi">String</span> <span class="pl-s1">newStr</span> = <span class="pl-en">myTrim</span>(<span class="pl-s1">str</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"---"</span> + <span class="pl-s1">newStr</span> + <span class="pl-s">"---"</span>);
    }</pre></div>
<p>**题目2：**将一个字符串进行反转。将字符串中指定部分进行反转。比如“ab<code class="notranslate">cdef</code>g”反转为”ab<code class="notranslate">fedc</code>g”</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c">// 方式一：</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">reverse1</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>, <span class="pl-smi">int</span> <span class="pl-s1">start</span>, <span class="pl-smi">int</span> <span class="pl-s1">end</span>) {<span class="pl-c">// start:2,end:5</span>
        <span class="pl-k">if</span> (<span class="pl-s1">str</span> != <span class="pl-c1">null</span>) {
            <span class="pl-c">// 1.</span>
            <span class="pl-smi">char</span>[] <span class="pl-s1">charArray</span> = <span class="pl-s1">str</span>.<span class="pl-en">toCharArray</span>();
            <span class="pl-c">// 2.</span>
            <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-s1">start</span>, <span class="pl-s1">j</span> = <span class="pl-s1">end</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">j</span>; <span class="pl-s1">i</span>++, <span class="pl-s1">j</span>--) {
                <span class="pl-smi">char</span> <span class="pl-s1">temp</span> = <span class="pl-s1">charArray</span>[<span class="pl-s1">i</span>];
                <span class="pl-s1">charArray</span>[<span class="pl-s1">i</span>] = <span class="pl-s1">charArray</span>[<span class="pl-s1">j</span>];
                <span class="pl-s1">charArray</span>[<span class="pl-s1">j</span>] = <span class="pl-s1">temp</span>;
            }
            <span class="pl-c">// 3.</span>
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">charArray</span>);

        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;

    }

    <span class="pl-c">// 方式二：</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">reverse2</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>, <span class="pl-smi">int</span> <span class="pl-s1">start</span>, <span class="pl-smi">int</span> <span class="pl-s1">end</span>) {
        <span class="pl-c">// 1.</span>
        <span class="pl-smi">String</span> <span class="pl-s1">newStr</span> = <span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-c1">0</span>, <span class="pl-s1">start</span>);<span class="pl-c">// ab</span>
        <span class="pl-c">// 2.</span>
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-s1">end</span>; <span class="pl-s1">i</span> &gt;= <span class="pl-s1">start</span>; <span class="pl-s1">i</span>--) {
            <span class="pl-s1">newStr</span> += <span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-s1">i</span>);
        } <span class="pl-c">// abfedc</span>
            <span class="pl-c">// 3.</span>
        <span class="pl-s1">newStr</span> += <span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-s1">end</span> + <span class="pl-c1">1</span>);
        <span class="pl-k">return</span> <span class="pl-s1">newStr</span>;
    }

    <span class="pl-c">// 方式三：推荐 （相较于方式二做的改进）</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">reverse3</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>, <span class="pl-smi">int</span> <span class="pl-s1">start</span>, <span class="pl-smi">int</span> <span class="pl-s1">end</span>) {<span class="pl-c">// ArrayList list = new ArrayList(80);</span>
        <span class="pl-c">// 1.</span>
        <span class="pl-smi">StringBuffer</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">StringBuffer</span>(<span class="pl-s1">str</span>.<span class="pl-en">length</span>());
        <span class="pl-c">// 2.</span>
        <span class="pl-s1">s</span>.<span class="pl-en">append</span>(<span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-c1">0</span>, <span class="pl-s1">start</span>));<span class="pl-c">// ab</span>
        <span class="pl-c">// 3.</span>
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-s1">end</span>; <span class="pl-s1">i</span> &gt;= <span class="pl-s1">start</span>; <span class="pl-s1">i</span>--) {
            <span class="pl-s1">s</span>.<span class="pl-en">append</span>(<span class="pl-s1">str</span>.<span class="pl-en">charAt</span>(<span class="pl-s1">i</span>));
        }

        <span class="pl-c">// 4.</span>
        <span class="pl-s1">s</span>.<span class="pl-en">append</span>(<span class="pl-s1">str</span>.<span class="pl-en">substring</span>(<span class="pl-s1">end</span> + <span class="pl-c1">1</span>));

        <span class="pl-c">// 5.</span>
        <span class="pl-k">return</span> <span class="pl-s1">s</span>.<span class="pl-en">toString</span>();

    }

    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">testReverse</span>() {
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"abcdefg"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-en">reverse3</span>(<span class="pl-s1">str</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str1</span>);<span class="pl-c">// abfedcg</span>

    }</pre></div>
<p>**题目3：**获取一个字符串在另一个字符串中出现的次数。<br>
比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c">// 第3题</span>
    <span class="pl-c">// 判断str2在str1中出现的次数</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">getCount</span>(<span class="pl-smi">String</span> <span class="pl-s1">mainStr</span>, <span class="pl-smi">String</span> <span class="pl-s1">subStr</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">mainStr</span>.<span class="pl-en">length</span>() &gt;= <span class="pl-s1">subStr</span>.<span class="pl-en">length</span>()) {
            <span class="pl-smi">int</span> <span class="pl-s1">count</span> = <span class="pl-c1">0</span>;
            <span class="pl-smi">int</span> <span class="pl-s1">index</span> = <span class="pl-c1">0</span>;
            <span class="pl-c">// while((index = mainStr.indexOf(subStr)) != -1){</span>
            <span class="pl-c">// count++;</span>
            <span class="pl-c">// mainStr = mainStr.substring(index + subStr.length());</span>
            <span class="pl-c">// }</span>
            <span class="pl-c">// 改进：</span>
            <span class="pl-k">while</span> ((<span class="pl-s1">index</span> = <span class="pl-s1">mainStr</span>.<span class="pl-en">indexOf</span>(<span class="pl-s1">subStr</span>, <span class="pl-s1">index</span>)) != -<span class="pl-c1">1</span>) {
                <span class="pl-s1">index</span> += <span class="pl-s1">subStr</span>.<span class="pl-en">length</span>();
                <span class="pl-s1">count</span>++;
            }

            <span class="pl-k">return</span> <span class="pl-s1">count</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }

    }

    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">testGetCount</span>() {
        <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-s">"cdabkkcadkabkebfkabkskab"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-s">"ab"</span>;
        <span class="pl-smi">int</span> <span class="pl-s1">count</span> = <span class="pl-en">getCount</span>(<span class="pl-s1">str1</span>, <span class="pl-s1">str2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">count</span>);
    }</pre></div>
<p>**题目4：**获取两个字符串中最大相同子串。比如：<br>
str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"<br>
提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c">// 第4题</span>
    <span class="pl-c">// 如果只存在一个最大长度的相同子串</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">getMaxSameSubString</span>(<span class="pl-smi">String</span> <span class="pl-s1">str1</span>, <span class="pl-smi">String</span> <span class="pl-s1">str2</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">str1</span> != <span class="pl-c1">null</span> &amp;&amp; <span class="pl-s1">str2</span> != <span class="pl-c1">null</span>) {
            <span class="pl-smi">String</span> <span class="pl-s1">maxStr</span> = (<span class="pl-s1">str1</span>.<span class="pl-en">length</span>() &gt; <span class="pl-s1">str2</span>.<span class="pl-en">length</span>()) ? <span class="pl-s1">str1</span> : <span class="pl-s1">str2</span>;
            <span class="pl-smi">String</span> <span class="pl-s1">minStr</span> = (<span class="pl-s1">str1</span>.<span class="pl-en">length</span>() &gt; <span class="pl-s1">str2</span>.<span class="pl-en">length</span>()) ? <span class="pl-s1">str2</span> : <span class="pl-s1">str1</span>;

            <span class="pl-smi">int</span> <span class="pl-s1">len</span> = <span class="pl-s1">minStr</span>.<span class="pl-en">length</span>();

            <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">len</span>; <span class="pl-s1">i</span>++) {<span class="pl-c">// 0 1 2 3 4 此层循环决定要去几个字符</span>

                <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">0</span>, <span class="pl-s1">y</span> = <span class="pl-s1">len</span> - <span class="pl-s1">i</span>; <span class="pl-s1">y</span> &lt;= <span class="pl-s1">len</span>; <span class="pl-s1">x</span>++, <span class="pl-s1">y</span>++) {

                    <span class="pl-k">if</span> (<span class="pl-s1">maxStr</span>.<span class="pl-en">contains</span>(<span class="pl-s1">minStr</span>.<span class="pl-en">substring</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>))) {

                        <span class="pl-k">return</span> <span class="pl-s1">minStr</span>.<span class="pl-en">substring</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>);
                    }

                }

            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

    <span class="pl-c">// 如果存在多个长度相同的最大相同子串</span>
    <span class="pl-c">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span>[] <span class="pl-s1">getMaxSameSubString1</span>(<span class="pl-smi">String</span> <span class="pl-s1">str1</span>, <span class="pl-smi">String</span> <span class="pl-s1">str2</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">str1</span> != <span class="pl-c1">null</span> &amp;&amp; <span class="pl-s1">str2</span> != <span class="pl-c1">null</span>) {
            <span class="pl-smi">StringBuffer</span> <span class="pl-s1">sBuffer</span> = <span class="pl-k">new</span> <span class="pl-smi">StringBuffer</span>();
            <span class="pl-smi">String</span> <span class="pl-s1">maxString</span> = (<span class="pl-s1">str1</span>.<span class="pl-en">length</span>() &gt; <span class="pl-s1">str2</span>.<span class="pl-en">length</span>()) ? <span class="pl-s1">str1</span> : <span class="pl-s1">str2</span>;
            <span class="pl-smi">String</span> <span class="pl-s1">minString</span> = (<span class="pl-s1">str1</span>.<span class="pl-en">length</span>() &gt; <span class="pl-s1">str2</span>.<span class="pl-en">length</span>()) ? <span class="pl-s1">str2</span> : <span class="pl-s1">str1</span>;

            <span class="pl-smi">int</span> <span class="pl-s1">len</span> = <span class="pl-s1">minString</span>.<span class="pl-en">length</span>();
            <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">len</span>; <span class="pl-s1">i</span>++) {
                <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">0</span>, <span class="pl-s1">y</span> = <span class="pl-s1">len</span> - <span class="pl-s1">i</span>; <span class="pl-s1">y</span> &lt;= <span class="pl-s1">len</span>; <span class="pl-s1">x</span>++, <span class="pl-s1">y</span>++) {
                    <span class="pl-smi">String</span> <span class="pl-s1">subString</span> = <span class="pl-s1">minString</span>.<span class="pl-en">substring</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>);
                    <span class="pl-k">if</span> (<span class="pl-s1">maxString</span>.<span class="pl-en">contains</span>(<span class="pl-s1">subString</span>)) {
                        <span class="pl-s1">sBuffer</span>.<span class="pl-en">append</span>(<span class="pl-s1">subString</span> + <span class="pl-s">","</span>);
                    }
                }
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">sBuffer</span>);
                <span class="pl-k">if</span> (<span class="pl-s1">sBuffer</span>.<span class="pl-en">length</span>() != <span class="pl-c1">0</span>) {
                    <span class="pl-k">break</span>;
                }
            }
            <span class="pl-smi">String</span>[] <span class="pl-s1">split</span> = <span class="pl-s1">sBuffer</span>.<span class="pl-en">toString</span>().<span class="pl-en">replaceAll</span>(<span class="pl-s">",$"</span>, <span class="pl-s">""</span>).<span class="pl-en">split</span>(<span class="pl-s">"<span class="pl-cce">\\</span>,"</span>);
            <span class="pl-k">return</span> <span class="pl-s1">split</span>;
        }

        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-c">// 如果存在多个长度相同的最大相同子串：使用ArrayList</span>
<span class="pl-c">//	public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) {</span>
<span class="pl-c">//		if (str1 != null &amp;&amp; str2 != null) {</span>
<span class="pl-c">//			List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="pl-c">//			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span>
<span class="pl-c">//			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span>
<span class="pl-c">//</span>
<span class="pl-c">//			int len = minString.length();</span>
<span class="pl-c">//			for (int i = 0; i &lt; len; i++) {</span>
<span class="pl-c">//				for (int x = 0, y = len - i; y &lt;= len; x++, y++) {</span>
<span class="pl-c">//					String subString = minString.substring(x, y);</span>
<span class="pl-c">//					if (maxString.contains(subString)) {</span>
<span class="pl-c">//						list.add(subString);</span>
<span class="pl-c">//					}</span>
<span class="pl-c">//				}</span>
<span class="pl-c">//				if (list.size() != 0) {</span>
<span class="pl-c">//					break;</span>
<span class="pl-c">//				}</span>
<span class="pl-c">//			}</span>
<span class="pl-c">//			return list;</span>
<span class="pl-c">//		}</span>
<span class="pl-c">//</span>
<span class="pl-c">//		return null;</span>
<span class="pl-c">//	}</span>

    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">testGetMaxSameSubString</span>() {
        <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-s">"abcwerthelloyuiodef"</span>;
        <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-s">"cvhellobnmiodef"</span>;
        <span class="pl-smi">String</span>[] <span class="pl-s1">strs</span> = <span class="pl-en">getMaxSameSubString1</span>(<span class="pl-s1">str1</span>, <span class="pl-s1">str2</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Arrays</span>.<span class="pl-en">toString</span>(<span class="pl-s1">strs</span>));
    }</pre></div>
<p>**题目5：**对字符串中字符进行自然顺序排序。<br>
提示：<br>
1）字符串变成字符数组。<br>
2）对数组排序，选择，冒泡，Arrays.sort();<br>
3）将排序后的数组变成字符串。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-c">// 第5题</span>
    <span class="pl-c1">@</span><span class="pl-c1">Test</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">testSort</span>() {
        <span class="pl-smi">String</span> <span class="pl-s1">str</span> = <span class="pl-s">"abcwerthelloyuiodef"</span>;
        <span class="pl-smi">char</span>[] <span class="pl-s1">arr</span> = <span class="pl-s1">str</span>.<span class="pl-en">toCharArray</span>();
        <span class="pl-smi">Arrays</span>.<span class="pl-en">sort</span>(<span class="pl-s1">arr</span>);

        <span class="pl-smi">String</span> <span class="pl-s1">newStr</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s1">arr</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">newStr</span>);
    }</pre></div>
<h2>2. 字符串相关类之可变字符序列：StringBuffer、StringBuilder</h2>
<p>因为String对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK又在java.lang包提供了可变字符序列StringBuffer和StringBuilder类型。</p>
<h3>2.1 StringBuffer与StringBuilder的理解</h3>
<ul>
<li>java.lang.StringBuffer代表<code class="notranslate">可变的字符序列</code>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。比如：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//情况1:</span>
<span class="pl-smi">String</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"我喜欢学习"</span>); 
<span class="pl-c">//情况2：</span>
<span class="pl-smi">StringBuffer</span> <span class="pl-s1">buffer</span> = <span class="pl-k">new</span> <span class="pl-smi">StringBuffer</span>(<span class="pl-s">"我喜欢学习"</span>); 
<span class="pl-s1">buffer</span>.<span class="pl-en">append</span>(<span class="pl-s">"数学"</span>); </pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220405221714261.png"><img src="images/image-20220405221714261.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>继承结构：</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220405174233055.png"><img src="images/image-20220405174233055.png" alt="" style="max-width: 100%;"></a></p>
<ul>
<li>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样。</li>
<li>区分String、StringBuffer、StringBuilder
<ul>
<li>String:不可变的字符序列； 底层使用char[]数组存储(JDK8.0中)</li>
<li>StringBuffer:可变的字符序列；线程安全（方法有synchronized修饰），效率低；底层使用char[]数组存储 (JDK8.0中)</li>
<li>StringBuilder:可变的字符序列； jdk1.5引入，线程不安全的，效率高；底层使用char[]数组存储(JDK8.0中)</li>
</ul>
</li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"><P>注意：转载请注明出处<br>转载前请仔细阅读此文章<br><a href = 'https://blog.adouzi.eu.org/post/21.html'>关于博客文章转载规则以及一些闲聊</a><br>个人主页<a href='https://adouzi.eu.org'>https://adouzi.eu.org</a><br>email：shiraayano@adouzi.eu.org</p><br></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2"><span id="filingNum"><a href="https://beian.miit.gov.cn/" target="_blank"><a href='https://icp.gov.moe/?keyword=20240287' target='_blank'>萌ICP备20240287号</a></a> • </span>
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script><script>document.addEventListener('visibilitychange',function(){const t=document.title,h=['不来看看咱喵~？','喵喵喵~？'];document.title=document.visibilityState==='hidden'?h[Math.floor(Math.random()*h.length)]:'欢迎回来喵~';if(document.visibilityState==='visible')setTimeout(()=>{document.title=t},1000);});</script>

</html>
