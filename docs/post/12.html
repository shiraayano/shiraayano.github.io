<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 递归
# 面向对象

### 面向对象编程（OOP）笔记

![image (54)](https://github.com/user-attachments/assets/a651492b-5e75-4e2f-ad61-cbcf4dc2cbe8)


#### Java类及类的成员
1. **类的成员**
   - **属性**：定义对象的状态和特征（通常称为类的字段或成员变量）。">
<meta property="og:title" content="Java 学习笔记 基础篇 003">
<meta property="og:description" content="# 递归
# 面向对象

### 面向对象编程（OOP）笔记

![image (54)](https://github.com/user-attachments/assets/a651492b-5e75-4e2f-ad61-cbcf4dc2cbe8)


#### Java类及类的成员
1. **类的成员**
   - **属性**：定义对象的状态和特征（通常称为类的字段或成员变量）。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/12.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java 学习笔记 基础篇 003</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Java 学习笔记 基础篇 003</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/12" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>递归</h1>
<h1>面向对象</h1>
<h3>面向对象编程（OOP）笔记</h3>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/a651492b-5e75-4e2f-ad61-cbcf4dc2cbe8"><img src="https://github.com/user-attachments/assets/a651492b-5e75-4e2f-ad61-cbcf4dc2cbe8" alt="image (54)" style="max-width: 100%;"></a></p>
<h4>Java类及类的成员</h4>
<ol>
<li><strong>类的成员</strong>
<ul>
<li><strong>属性</strong>：定义对象的状态和特征（通常称为类的字段或成员变量）。</li>
<li><strong>方法</strong>：定义对象的行为，用于操作类的属性。</li>
<li><strong>构造器</strong>：初始化对象实例，为属性赋初值。</li>
</ul>
</li>
<li><strong>代码块</strong>
<ul>
<li><strong>普通代码块</strong>：在方法内部，用于局部范围内逻辑块的处理。</li>
<li><strong>静态代码块</strong>：在类加载时执行，仅执行一次，用于初始化静态资源。</li>
</ul>
</li>
<li><strong>内部类</strong>
<ul>
<li>定义在另一个类内部的类，可用于封装更为复杂的结构，便于组织逻辑和代码。</li>
</ul>
</li>
</ol>
<h4>面向对象的特征</h4>
<ol>
<li><strong>封装</strong>：隐藏对象的内部实现，仅对外提供访问接口。</li>
<li><strong>继承</strong>：子类继承父类的属性和方法，促进代码复用。</li>
<li><strong>多态</strong>：对象可以表现为多种形态，具体表现由运行时动态决定。</li>
</ol>
<h4>编程范式</h4>
<ul>
<li><strong>面向过程编程（POP）</strong>：强调按顺序执行一系列指令来实现功能。</li>
<li><strong>面向对象编程（OOP）</strong>：通过对象的属性和方法来封装行为。</li>
<li><strong>指令式编程</strong>：按步骤操作数据。</li>
<li><strong>函数式编程</strong>：用函数来封装行为，以不可变的数据传递流为核心。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/8c8d2e97-bfb3-4f05-94dd-fc7549a2c592"><img src="https://github.com/user-attachments/assets/8c8d2e97-bfb3-4f05-94dd-fc7549a2c592" alt="image (55)" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/ea86d0a0-4c78-40c5-94ac-b6c01dfcb1d5"><img src="https://github.com/user-attachments/assets/ea86d0a0-4c78-40c5-94ac-b6c01dfcb1d5" alt="image (56)" style="max-width: 100%;"></a></p>
<h4>调用方法</h4>
<ul>
<li>对象.属性</li>
<li>对象.方法</li>
</ul>
<h4>示例代码</h4>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/e5a90cb0-35b1-4df2-a698-44c6932d09ed"><img src="https://github.com/user-attachments/assets/e5a90cb0-35b1-4df2-a698-44c6932d09ed" alt="image (57)" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/122d3852-eceb-47e5-9c12-53907f34ccec"><img src="https://github.com/user-attachments/assets/122d3852-eceb-47e5-9c12-53907f34ccec" alt="image (58)" style="max-width: 100%;"></a></p>
<ol>
<li><strong>创建对象并操作属性</strong></li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 创建Phone类的对象p1</span>
<span class="pl-smi">Phone</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Phone</span>();
<span class="pl-s1">p1</span>.<span class="pl-s1">name</span> = <span class="pl-s">"huawei"</span>;   <span class="pl-c">// 设置属性</span>
<span class="pl-s1">p1</span>.<span class="pl-s1">price</span> = <span class="pl-c1">6999</span>;      <span class="pl-c">// 设置属性</span>

<span class="pl-c">// 输出属性</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"name="</span> + <span class="pl-s1">p1</span>.<span class="pl-s1">name</span>);  <span class="pl-c">// 输出 name 属性</span></pre></div>
<ol start="2">
<li><strong>用户类层次结构</strong></li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 用户类</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;  <span class="pl-c">// 用户名</span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;  <span class="pl-c">// 密码</span>

    <span class="pl-c">// 构造器，初始化用户名和密码</span>
    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-c">// Getter 和 Setter 方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-c">// 通用用户登录方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">login</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">username</span> + <span class="pl-s">" is logging in."</span>);
    }
}

<span class="pl-c">// 管理员类，继承User类</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Admin</span> <span class="pl-k">extends</span> <span class="pl-smi">User</span> {
    <span class="pl-k">public</span> <span class="pl-smi">Admin</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-en">super</span>(<span class="pl-s1">username</span>, <span class="pl-s1">password</span>);
    }

    <span class="pl-c">// 管理员特有方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">manageUsers</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-en">getUsername</span>() + <span class="pl-s">" is managing users."</span>);
    }
}

<span class="pl-c">// 超级管理员类，继承Admin类</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">SuperAdmin</span> <span class="pl-k">extends</span> <span class="pl-smi">Admin</span> {
    <span class="pl-k">public</span> <span class="pl-smi">SuperAdmin</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-en">super</span>(<span class="pl-s1">username</span>, <span class="pl-s1">password</span>);
    }

    <span class="pl-c">// 超级管理员特有方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">grantAdminRights</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-en">getUsername</span>() + <span class="pl-s">" is granting admin rights."</span>);
    }
}

<span class="pl-c">// 用户管理类，用于测试创建用户、管理员和超级管理员</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UserManager</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建普通用户</span>
        <span class="pl-smi">User</span> <span class="pl-s1">regularUser</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"johnDoe"</span>, <span class="pl-s">"password123"</span>);
        <span class="pl-s1">regularUser</span>.<span class="pl-en">login</span>();

        <span class="pl-c">// 创建管理员</span>
        <span class="pl-smi">Admin</span> <span class="pl-s1">adminUser</span> = <span class="pl-k">new</span> <span class="pl-smi">Admin</span>(<span class="pl-s">"janeAdmin"</span>, <span class="pl-s">"adminpass"</span>);
        <span class="pl-s1">adminUser</span>.<span class="pl-en">login</span>();
        <span class="pl-s1">adminUser</span>.<span class="pl-en">manageUsers</span>();

        <span class="pl-c">// 创建超级管理员</span>
        <span class="pl-smi">SuperAdmin</span> <span class="pl-s1">superAdminUser</span> = <span class="pl-k">new</span> <span class="pl-smi">SuperAdmin</span>(<span class="pl-s">"bobSuper"</span>, <span class="pl-s">"superpass"</span>);
        <span class="pl-s1">superAdminUser</span>.<span class="pl-en">login</span>();
        <span class="pl-s1">superAdminUser</span>.<span class="pl-en">manageUsers</span>();
        <span class="pl-s1">superAdminUser</span>.<span class="pl-en">grantAdminRights</span>();
    }
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/ccf01c78-125c-48f5-b10e-e01faa7f211f"><img src="https://github.com/user-attachments/assets/ccf01c78-125c-48f5-b10e-e01faa7f211f" alt="image (59)" style="max-width: 100%;"></a></p>
<h4>对象的独立性和引用</h4>
<ol>
<li>
<p><strong>独立实体</strong>：每个对象在堆空间中都有一个独立的实体，保存着类属性的副本。更改一个对象的属性不会影响其他对象。</p>
<ul>
<li>示例：
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
<span class="pl-smi">Person</span> <span class="pl-s1">p2</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();

<span class="pl-s1">p1</span>.<span class="pl-s1">age</span> = <span class="pl-c1">18</span>;  <span class="pl-c">// 修改 p1 的 age</span>
<span class="pl-s1">p2</span>.<span class="pl-s1">age</span> = <span class="pl-c1">28</span>;  <span class="pl-c">// p2 的 age 独立不受影响</span>
<span class="pl-s1">p1</span>.<span class="pl-s1">age</span> = <span class="pl-c1">30</span>;  <span class="pl-c">// 修改 p1 的 age 后，p2 的 age 仍为 28</span></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>引用变量共享</strong>：如果两个变量指向同一个对象，修改其中一个的属性会影响另一个。</p>
<ul>
<li>示例：
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
<span class="pl-smi">Person</span> <span class="pl-s1">p3</span> = <span class="pl-s1">p1</span>;  <span class="pl-c">// p3 引用 p1 的对象</span>

<span class="pl-s1">p3</span>.<span class="pl-s1">age</span> = <span class="pl-c1">25</span>;     <span class="pl-c">// 修改 p3 的 age</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">p1</span>.<span class="pl-s1">age</span>);  <span class="pl-c">// 访问 p1 的 age，值为 25</span></pre></div>
</li>
</ul>
</li>
</ol>
<p>这些内容包含了Java面向对象编程的基本要点和细节，代码示例提供了清晰的参考。</p>
<hr>
<h3>Java 面向对象笔记（详细版）</h3>
<hr>
<h4>成员变量与局部变量</h4>
<ol>
<li>
<p><strong>成员变量（Field）</strong></p>
<ul>
<li>
<p><strong>定义</strong>：在类中定义，但不在任何方法、构造方法或代码块中的变量。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>作用域</strong>：整个类内可见，类的所有方法均可访问。</li>
<li><strong>生命周期</strong>：与对象绑定，对象创建时初始化，随对象销毁而销毁。</li>
<li><strong>初始化</strong>：未显式赋值时，自动初始化为默认值（例如 <code class="notranslate">int</code> 默认值为 <code class="notranslate">0</code>，对象引用默认值为 <code class="notranslate">null</code>）。</li>
<li><strong>访问控制</strong>：可以使用 <code class="notranslate">public</code>、<code class="notranslate">private</code>、<code class="notranslate">protected</code> 等访问修饰符来控制可见性。</li>
</ol>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>; <span class="pl-c">// 成员变量</span>
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;     <span class="pl-c">// 成员变量</span>

    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>; <span class="pl-c">// 初始化成员变量</span>
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">displayInfo</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Name: "</span> + <span class="pl-s1">name</span> + <span class="pl-s">", Age: "</span> + <span class="pl-s1">age</span>);
    }
}</pre></div>
</li>
</ul>
</li>
<li>
<p><strong>局部变量（Local Variable）</strong></p>
<ul>
<li>
<p><strong>定义</strong>：在方法、构造方法或代码块中声明的变量。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>作用域</strong>：仅在定义它的块内可见，块结束后超出作用域。</li>
<li><strong>生命周期</strong>：随方法执行过程创建和销毁。</li>
<li><strong>初始化</strong>：必须显式初始化，否则会导致编译错误。</li>
<li><strong>访问控制</strong>：不能使用访问修饰符，因为它们仅在当前块内可见。</li>
</ol>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Calculator</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>) {
        <span class="pl-smi">int</span> <span class="pl-s1">sum</span> = <span class="pl-s1">a</span> + <span class="pl-s1">b</span>; <span class="pl-c">// 局部变量</span>
        <span class="pl-k">return</span> <span class="pl-s1">sum</span>;
    }
}</pre></div>
</li>
</ul>
</li>
</ol>
<h4>内部类与外部类实例化</h4>
<ol>
<li>
<p><strong>内部类</strong>：将一个类定义在另一个类的内部，内部类可以访问外部类的所有成员（包括私有成员）。</p>
<ul>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">OuterClass</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">outerField</span> = <span class="pl-s">"Outer field"</span>;

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InnerClass</span> {
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>() {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Accessing outer field: "</span> + <span class="pl-s1">outerField</span>);
        }
    }

    <span class="pl-k">public</span> <span class="pl-smi">InnerClass</span> <span class="pl-en">getInnerClassInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">InnerClass</span>();
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestInnerClass</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">OuterClass</span> <span class="pl-s1">outer</span> = <span class="pl-k">new</span> <span class="pl-smi">OuterClass</span>();
        <span class="pl-smi">OuterClass</span>.<span class="pl-smi">InnerClass</span> <span class="pl-s1">inner</span> = <span class="pl-s1">outer</span>.<span class="pl-en">getInnerClassInstance</span>();
        <span class="pl-s1">inner</span>.<span class="pl-en">display</span>();
    }
}</pre></div>
</li>
</ul>
</li>
<li>
<p><strong>外部类实例化</strong>：在一个类中创建另一个类的实例，通过实例访问方法和属性。</p>
<ul>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Car</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">brand</span> = <span class="pl-s">"Toyota"</span>;
    
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">startEngine</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">brand</span> + <span class="pl-s">" engine started"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Garage</span> {
    <span class="pl-smi">Car</span> <span class="pl-s1">myCar</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Garage</span>() {
        <span class="pl-s1">myCar</span> = <span class="pl-k">new</span> <span class="pl-smi">Car</span>(); <span class="pl-c">// 创建 Car 实例</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">startCarEngine</span>() {
        <span class="pl-s1">myCar</span>.<span class="pl-en">startEngine</span>(); <span class="pl-c">// 调用 Car 实例的方法</span>
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestGarage</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Garage</span> <span class="pl-s1">garage</span> = <span class="pl-k">new</span> <span class="pl-smi">Garage</span>();
        <span class="pl-s1">garage</span>.<span class="pl-en">startCarEngine</span>();
    }
}</pre></div>
</li>
</ul>
</li>
</ol>
<h4>方法（Method）</h4>
<ul>
<li>
<p><strong>方法的定义</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[访问修饰符] [<span class="pl-k">static</span>] 返回类型 方法名(参数类型 参数名, ...) {
    <span class="pl-c">// 方法体</span>
    <span class="pl-k">return</span> 返回值; <span class="pl-c">// 如果有返回值</span>
}</pre></div>
<ul>
<li><strong>访问修饰符</strong>：定义方法可见性，如 <code class="notranslate">public</code>、<code class="notranslate">private</code>、<code class="notranslate">protected</code>。</li>
<li><strong>static</strong>：用于静态方法，直接通过类名调用，无需实例化。</li>
<li><strong>返回类型</strong>：方法返回的数据类型。若无返回值，用 <code class="notranslate">void</code>。</li>
<li><strong>方法名</strong>：符合命名规范，表示方法功能。</li>
<li><strong>参数</strong>：方法输入的数据。</li>
<li><strong>方法体</strong>：方法的执行内容。</li>
</ul>
</li>
<li>
<p><strong>方法的调用</strong>：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Calculator</span> {

    <span class="pl-c">// 无返回值的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">displayMessage</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Hello, World!"</span>);
    }

    <span class="pl-c">// 有参数有返回值的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">num1</span>, <span class="pl-smi">int</span> <span class="pl-s1">num2</span>) {
        <span class="pl-smi">int</span> <span class="pl-s1">sum</span> = <span class="pl-s1">num1</span> + <span class="pl-s1">num2</span>;
        <span class="pl-k">return</span> <span class="pl-s1">sum</span>; <span class="pl-c">// 返回结果</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Calculator</span> <span class="pl-s1">calc</span> = <span class="pl-k">new</span> <span class="pl-smi">Calculator</span>(); <span class="pl-c">// 创建实例</span>

        <span class="pl-c">// 调用无返回值方法</span>
        <span class="pl-s1">calc</span>.<span class="pl-en">displayMessage</span>();

        <span class="pl-c">// 调用有返回值方法</span>
        <span class="pl-smi">int</span> <span class="pl-s1">result</span> = <span class="pl-s1">calc</span>.<span class="pl-en">add</span>(<span class="pl-c1">5</span>, <span class="pl-c1">10</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"The sum is: "</span> + <span class="pl-s1">result</span>);
    }
}</pre></div>
</li>
<li>
<p><strong>注意事项</strong>：</p>
<ol>
<li>静态方法可通过类名直接调用，如 <code class="notranslate">ClassName.methodName()</code>。</li>
<li>非静态方法需在类实例上调用。</li>
<li>方法参数必须与定义时参数类型和顺序一致。</li>
<li><code class="notranslate">return</code> 结束方法，并将值返回给调用者，<code class="notranslate">return</code> 后不可再有代码。</li>
</ol>
</li>
<li>
<p><strong>方法的分类</strong>：</p>
<ul>
<li><strong>无返回值类型</strong>：<code class="notranslate">void</code> 类型，无需返回值。</li>
<li><strong>有返回值类型</strong>：需要使用 <code class="notranslate">return</code> 语句返回与定义类型匹配的数据。</li>
</ul>
</li>
</ul>
<h4>示例代码</h4>
<ol>
<li>
<p><strong>成员变量与局部变量的比较</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {

    <span class="pl-c">// 成员变量，生命周期与对象一致</span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">methodExample</span>() {
        <span class="pl-c">// 局部变量，生命周期仅在当前方法内</span>
        <span class="pl-smi">int</span> <span class="pl-s1">number</span> = <span class="pl-c1">10</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Local variable number: "</span> + <span class="pl-s1">number</span>);
    }
}</pre></div>
</li>
<li>
<p><strong>使用方法与参数</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(<span class="pl-smi">int</span> <span class="pl-s1">hours</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人每天至少睡："</span> + <span class="pl-s1">hours</span> + <span class="pl-s">"小时"</span>);
    }
}</pre></div>
<ul>
<li><strong>说明</strong>：方法定义时根据功能决定参数类型；参数列表为空时表示无输入要求。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/9e7c9b33-2e75-4378-a986-52b51c0bac67"><img src="https://github.com/user-attachments/assets/9e7c9b33-2e75-4378-a986-52b51c0bac67" alt="image (60)" style="max-width: 100%;"></a></p>
<h3>方法的定义与调用</h3>
<p>在 Java 中，方法是实现功能模块的基本单元。一个方法可以包含逻辑代码、接收参数并返回数据。方法的定义结构包括访问修饰符、可选的 <code class="notranslate">static</code> 关键字、返回值类型、方法名和参数列表。</p>
<h4>方法的定义结构</h4>
<div class="highlight highlight-source-java"><pre class="notranslate">[访问修饰符] [<span class="pl-k">static</span>] 返回类型 方法名(参数类型 参数名, 参数类型 参数名, ...) {
    <span class="pl-c">// 方法体</span>
    <span class="pl-c">// ...</span>
    <span class="pl-c">// 返回语句（如果方法有返回值）</span>
    <span class="pl-k">return</span> 返回值;
}</pre></div>
<p><strong>要点：</strong></p>
<ul>
<li><strong>访问修饰符</strong>：如 <code class="notranslate">public</code>、<code class="notranslate">private</code>、<code class="notranslate">protected</code>，控制方法的访问权限。</li>
<li><strong>static</strong>：若方法为静态，则使用类名直接调用，不需要创建实例。</li>
<li><strong>返回类型</strong>：指定方法返回的数据类型，若没有返回值，使用 <code class="notranslate">void</code>。</li>
<li><strong>方法名</strong>：方法的标识符，遵循 Java 命名规范。</li>
<li><strong>参数</strong>：方法的输入，可以在调用时传递数据。</li>
</ul>
<h4>方法的调用</h4>
<p>调用方法时使用方法名，并传入相应的参数（如果有）。方法的返回值可以用于后续操作。</p>
<p><strong>示例：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Calculator</span> {

    <span class="pl-c">// 无参数、无返回值的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">displayMessage</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Hello, World!"</span>);
    }

    <span class="pl-c">// 有参数、有返回值的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">num1</span>, <span class="pl-smi">int</span> <span class="pl-s1">num2</span>) {
        <span class="pl-smi">int</span> <span class="pl-s1">sum</span> = <span class="pl-s1">num1</span> + <span class="pl-s1">num2</span>;
        <span class="pl-k">return</span> <span class="pl-s1">sum</span>; <span class="pl-c">// 返回计算结果</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Calculator</span> <span class="pl-s1">calc</span> = <span class="pl-k">new</span> <span class="pl-smi">Calculator</span>(); <span class="pl-c">// 创建 Calculator 类的实例</span>

        <span class="pl-c">// 调用无参数、无返回值的方法</span>
        <span class="pl-s1">calc</span>.<span class="pl-en">displayMessage</span>();

        <span class="pl-c">// 调用有参数、有返回值的方法，并打印结果</span>
        <span class="pl-smi">int</span> <span class="pl-s1">result</span> = <span class="pl-s1">calc</span>.<span class="pl-en">add</span>(<span class="pl-c1">5</span>, <span class="pl-c1">10</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"The sum is: "</span> + <span class="pl-s1">result</span>);
    }
}</pre></div>
<p>在这个例子中，<code class="notranslate">Calculator</code> 类包含两个方法：<code class="notranslate">displayMessage</code> 和 <code class="notranslate">add</code>。<code class="notranslate">displayMessage</code> 没有参数，也没有返回值，它仅打印消息。<code class="notranslate">add</code> 方法接受两个整数参数，返回它们的和。</p>
<h4>注意事项</h4>
<ul>
<li><strong>静态方法</strong>：可通过类名直接调用，如 <code class="notranslate">Calculator.displayMessage()</code>。</li>
<li><strong>非静态方法</strong>：必须在实例上调用，如 <code class="notranslate">calc.displayMessage()</code>。</li>
<li><strong>参数匹配</strong>：传入的参数必须与方法定义的参数类型和顺序相匹配。</li>
<li><strong>调用限制</strong>：方法可以调用同一类中的其他方法，包括自己。</li>
</ul>
<h3>方法声明</h3>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/8afa91f3-d9f5-4c9b-9f43-495979185092"><img src="https://github.com/user-attachments/assets/8afa91f3-d9f5-4c9b-9f43-495979185092" alt="image (60)" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-java"><pre class="notranslate">权限修饰符 [其它修饰符（非必要）] 返回值类型 方法名（形参列表）{
    <span class="pl-c">// 方法体</span>
}</pre></div>
<h4>方法分类</h4>
<ol>
<li><strong>无返回值类型</strong>：若方法没有返回值，使用 <code class="notranslate">void</code>，如 <code class="notranslate">public void displayMessage()</code>。</li>
<li><strong>有返回值类型</strong>：返回具体的数据类型，如 <code class="notranslate">int</code>、<code class="notranslate">String</code> 等，并必须包含 <code class="notranslate">return</code> 语句。</li>
</ol>
<h4>形参列表的使用</h4>
<p>当方法需要外部数据时，形参列表可指定接收的参数：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">sleep</span>(<span class="pl-smi">int</span> <span class="pl-s1">hour</span>) {
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人每天最少睡："</span> + <span class="pl-s1">hour</span> + <span class="pl-s">" 小时"</span>);
}</pre></div>
<h4>注意 <code class="notranslate">return</code> 语句</h4>
<ul>
<li><code class="notranslate">return</code> 用于结束方法并返回值。</li>
<li><code class="notranslate">return</code> 后不能有任何可执行语句，否则编译错误。</li>
</ul>
<h3>Java 递归方法</h3>
<p><strong>递归</strong>指的是方法在自身内部调用自己。递归是一种强大的编程技术，通常用于解决具有重复子结构的问题，比如分治法、树结构处理和数学计算等场景。</p>
<h4>递归方法的分类</h4>
<ol>
<li><strong>直接递归</strong>：方法直接调用自己。</li>
<li><strong>间接递归</strong>：方法通过其他方法间接调用自身。例如，<code class="notranslate">A()</code> 调用 <code class="notranslate">B()</code>，然后 <code class="notranslate">B()</code> 再调用 <code class="notranslate">A()</code>。</li>
</ol>
<h4>递归的特性</h4>
<ul>
<li><strong>隐式循环</strong>：递归方法通过方法调用栈来实现循环，因此可以被认为包含一种隐式的循环。</li>
<li><strong>递归终止条件</strong>：递归方法一定要在已知的方向上递归，即每次递归调用要朝着满足条件的方向收敛。否则会出现<strong>无限递归</strong>，最终导致栈内存溢出（StackOverflowError）。</li>
</ul>
<h4>递归示例</h4>
<p>以下是一个简单的递归示例：<strong>计算阶乘</strong>。</p>
<p><strong>阶乘的定义</strong>：</p>
<ul>
<li>n! = n × (n - 1) × (n - 2) × ... × 1</li>
<li>特殊情况：0! = 1</li>
</ul>
<p><strong>代码实现：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Factorial</span> {
    <span class="pl-c">// 递归计算阶乘的方法</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">factorial</span>(<span class="pl-smi">int</span> <span class="pl-s1">n</span>) {
        <span class="pl-c">// 递归终止条件：当 n 为 0 时返回 1</span>
        <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-c">// 递归调用：计算 n * (n-1)!</span>
        <span class="pl-k">return</span> <span class="pl-s1">n</span> * <span class="pl-en">factorial</span>(<span class="pl-s1">n</span> - <span class="pl-c1">1</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">int</span> <span class="pl-s1">number</span> = <span class="pl-c1">5</span>;
        <span class="pl-smi">int</span> <span class="pl-s1">result</span> = <span class="pl-en">factorial</span>(<span class="pl-s1">number</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">number</span> + <span class="pl-s">"! = "</span> + <span class="pl-s1">result</span>);  <span class="pl-c">// 输出结果</span>
    }
}</pre></div>
<p><strong>代码说明</strong>：</p>
<ul>
<li><code class="notranslate">factorial</code> 方法在每次调用时都会检查是否满足终止条件 <code class="notranslate">n == 0</code>。</li>
<li>如果满足条件则返回 1，否则继续调用 <code class="notranslate">factorial(n - 1)</code> 计算 <code class="notranslate">(n - 1)!</code>。</li>
<li>最终每层递归都会返回计算值，直至整个阶乘计算完成。</li>
</ul>
<h4>注意事项</h4>
<ol>
<li><strong>确保递归终止条件</strong>：递归方法必须有明确的终止条件，否则会导致无限递归。</li>
<li><strong>优化递归</strong>：递归效率较低，尤其是在需要重复计算的情况下（如斐波那契数列）。这时可以考虑使用<strong>动态规划</strong>等优化方式。</li>
</ol>
<hr>
<p>递归的概念和用法主要总结如上，适用于解决许多复杂问题。</p>
<p>这个代码定义了多个递归和非递归方法，来展示递归的应用。代码有一些需要修改和完善的地方，我已为你整理并补充了注释。</p>
<hr>
<h3>递归示例代码</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 文件名: RecursionTest.java</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">RecursionTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建当前类的对象，用于调用实例方法</span>
        <span class="pl-smi">RecursionTest</span> <span class="pl-s1">rt</span> = <span class="pl-k">new</span> <span class="pl-smi">RecursionTest</span>();

        <span class="pl-c">// 调用求和方法（非递归）</span>
        <span class="pl-s1">rt</span>.<span class="pl-en">method2</span>();

        <span class="pl-c">// 调用递归求和方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"1到100的总和："</span> + <span class="pl-s1">rt</span>.<span class="pl-en">method3</span>(<span class="pl-c1">100</span>));

        <span class="pl-c">// 调用递归计算阶乘方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"5的阶乘："</span> + <span class="pl-s1">rt</span>.<span class="pl-en">method4</span>(<span class="pl-c1">5</span>));

        <span class="pl-c">// 调用斐波那契数列计算方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"斐波那契数列第10项："</span> + <span class="pl-s1">rt</span>.<span class="pl-en">method5</span>(<span class="pl-c1">10</span>));
    }

    <span class="pl-c">// 递归方法示例：无限递归</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method1</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"method1。。。"</span>);
        <span class="pl-c">// 自己调用自己，会导致无限递归</span>
        <span class="pl-en">method1</span>();
    }

    <span class="pl-c">// 非递归求和方法：计算1到100之间的总和</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method2</span>() {
        <span class="pl-smi">int</span> <span class="pl-s1">sum</span> = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">1</span>; <span class="pl-s1">i</span> &lt;= <span class="pl-c1">100</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-s1">sum</span> += <span class="pl-s1">i</span>;
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"1到100的总和："</span> + <span class="pl-s1">sum</span>);
    }

    <span class="pl-c">// 递归求和方法：计算1到num的总和</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">method3</span>(<span class="pl-smi">int</span> <span class="pl-s1">num</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">num</span> == <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-s1">num</span> + <span class="pl-en">method3</span>(<span class="pl-s1">num</span> - <span class="pl-c1">1</span>);
        }
    }

    <span class="pl-c">// 递归计算阶乘：计算n的阶乘 n!</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">method4</span>(<span class="pl-smi">int</span> <span class="pl-s1">n</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-s1">n</span> * <span class="pl-en">method4</span>(<span class="pl-s1">n</span> - <span class="pl-c1">1</span>);
        }
    }

    <span class="pl-c">// 递归计算斐波那契数列：f(n) = f(n-1) + f(n-2)</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">method5</span>(<span class="pl-smi">int</span> <span class="pl-s1">n</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">1</span> || <span class="pl-s1">n</span> == <span class="pl-c1">2</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-en">method5</span>(<span class="pl-s1">n</span> - <span class="pl-c1">1</span>) + <span class="pl-en">method5</span>(<span class="pl-s1">n</span> - <span class="pl-c1">2</span>);
        }
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 文件名: RecursionExer.java</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">RecursionExer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">RecursionExer</span> <span class="pl-s1">exer</span> = <span class="pl-k">new</span> <span class="pl-smi">RecursionExer</span>();

        <span class="pl-c">// 测试自定义递归方法 f 和 func</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"f(20)的值："</span> + <span class="pl-s1">exer</span>.<span class="pl-en">f</span>(<span class="pl-c1">20</span>));
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"func(20)的值："</span> + <span class="pl-s1">exer</span>.<span class="pl-en">func</span>(<span class="pl-c1">20</span>));
    }

    <span class="pl-c">// 递归方法：根据自定义规则定义的递归公式</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">f</span>(<span class="pl-smi">int</span> <span class="pl-s1">n</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">20</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">21</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">4</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-en">f</span>(<span class="pl-s1">n</span> + <span class="pl-c1">1</span>) + <span class="pl-en">f</span>(<span class="pl-s1">n</span> + <span class="pl-c1">2</span>);
        }
    }

    <span class="pl-c">// 递归方法：另一个自定义的递归公式</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">func</span>(<span class="pl-smi">int</span> <span class="pl-s1">n</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-s1">n</span> == <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">4</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">2</span> * <span class="pl-en">func</span>(<span class="pl-s1">n</span> - <span class="pl-c1">1</span>) + <span class="pl-c1">2</span> * <span class="pl-en">func</span>(<span class="pl-s1">n</span> - <span class="pl-c1">2</span>);
        }
    }
}</pre></div>
<h3>代码说明</h3>
<ol>
<li><strong>method1</strong>：无限递归调用自己，无终止条件，会导致<strong>栈溢出错误</strong>（StackOverflowError）。</li>
<li><strong>method2</strong>：非递归方法，用于计算 1 到 100 的总和。</li>
<li><strong>method3</strong>：递归求和方法，计算从 1 到 <code class="notranslate">num</code> 的总和。终止条件为 <code class="notranslate">num == 1</code>。</li>
<li><strong>method4</strong>：递归阶乘方法，计算 <code class="notranslate">n!</code>。终止条件为 <code class="notranslate">n == 1</code>。</li>
<li><strong>method5</strong>：递归实现的斐波那契数列，终止条件为 <code class="notranslate">n == 1</code> 或 <code class="notranslate">n == 2</code>。</li>
<li><strong>f</strong> 和 <strong>func</strong>：两个自定义递归方法，依次计算指定规则的递归序列。</li>
</ol>
<h3>注意事项</h3>
<ul>
<li>递归方法中务必设置<strong>递归终止条件</strong>，防止无限递归。</li>
<li>对于计算量大的递归问题，可以考虑使用<strong>缓存</strong>或<strong>动态规划</strong>来提高效率，如斐波那契数列等。</li>
</ul>
<h1></h1>
<h1>关键字</h1>
<p>关键字 package 包 import</p>
<p>package ，成为包， 用于指明文件中定义的类 。接口等结构所在的包</p>
<p>package 顶层包名.子包名;</p>
<p>语法 package pack1.pack2;</p>
<p>在Java中，<code class="notranslate">import static</code>语句允许你导入一个类或接口中的静态成员（包括方法和变量），这样你就可以直接通过成员名来访问它们，而不需要每次都指定类名。这可以使代码更加简洁，尤其是在使用频繁调用的静态方法时。</p>
<p>以下是<code class="notranslate">import static</code>的一些使用场景：</p>
<ol>
<li><strong>导入单个静态成员</strong>：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.<span class="pl-c1">PI</span>;
<span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.<span class="pl-s1">sqrt</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">double</span> <span class="pl-s1">area</span> = <span class="pl-en">sqrt</span>(<span class="pl-c1">4</span>) * <span class="pl-c1">PI</span>; <span class="pl-c">// 使用导入的静态成员</span>
    }
}</pre></div>
<ol start="2">
<li><strong>导入多个静态成员</strong>：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.{<span class="pl-c1">PI</span>, <span class="pl-s1">sqrt</span>};

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">double</span> <span class="pl-s1">area</span> = <span class="pl-en">sqrt</span>(<span class="pl-c1">4</span>) * <span class="pl-c1">PI</span>; <span class="pl-c">// 使用导入的静态成员</span>
    }
}</pre></div>
<ol start="3">
<li><strong>导入整个类的静态成员</strong>：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.*;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">double</span> <span class="pl-s1">area</span> = <span class="pl-en">sqrt</span>(<span class="pl-c1">4</span>) * <span class="pl-c1">PI</span>; <span class="pl-c">// 使用导入的静态成员</span>
    }
}</pre></div>
<p>使用<code class="notranslate">import static</code>时需要注意的几点：</p>
<ul>
<li>它只能用于导入静态成员。</li>
<li>如果多个类有相同名称的静态成员，你需要指定使用哪一个。</li>
<li>过度使用<code class="notranslate">import static</code>可能会导致代码的可读性降低，因为读者需要知道被导入的静态成员来自哪个类。</li>
</ul>
<p>使用<code class="notranslate">import static</code>可以提高代码的可读性和简洁性，但应该适度使用，以保持代码的清晰和易于维护。</p>
<p>import 导入</p>
<p>import 语句来显示引入指定包下的类，相当于 import 语句告诉编译器去哪里找到这个类</p>
<p>import 包名.类名;</p>
<p>写在包的声明和类的声明之间</p>
<p>可以使用.*一键导入包中所有的类中和所有接口</p>
<p>如果导入的类或接口 是 java.lang 包下的，或是当前包下的则可以省略 import 语句</p>
<p>如果在包下出现不同包下同名的类，那么就需要使用类的全类名方式指明调用的是哪个类（java.sql.Date data1= new java.sql.Date(12121212121L);）</p>
<p>（了解）import static 组合的使用 调用指定类或接口下的静态的属性或方法</p>
<p>Java中的<code class="notranslate">package</code>是一个关键词，用于声明类属于哪个包（package）。包是Java中组织类和接口的一种方式，它有助于避免命名冲突，并允许开发者将功能相关的类组织在一起。下面是关于Java包的一些基本介绍和使用规范：</p>
<h3>1. 定义包</h3>
<p>在Java文件的最开始，可以使用<code class="notranslate">package</code>关键词来声明该文件属于哪个包。例如：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">example</span>.<span class="pl-s1">myapp</span>;</pre></div>
<p>这行代码声明了该Java文件属于<code class="notranslate">com.example.myapp</code>包。</p>
<h3>2. 使用包</h3>
<ul>
<li><strong>导入类</strong>：如果你要使用其他包中的类，可以使用<code class="notranslate">import</code>语句。例如：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">com</span>.<span class="pl-s1">example</span>.<span class="pl-s1">myapp</span>.<span class="pl-s1">MyClass</span>;</pre></div>
<p>或者使用<code class="notranslate">import</code>语句的通配符形式：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">com</span>.<span class="pl-s1">example</span>.<span class="pl-s1">myapp</span>.*;</pre></div>
<p>这将导入<code class="notranslate">com.example.myapp</code>包下的所有类。</p>
<h3>3. 包的使用规范</h3>
<ul>
<li><strong>避免命名冲突</strong>：包名通常采用全小写字母，使用点<code class="notranslate">.</code>分隔不同级别的组织结构，如域名的逆序。例如，<code class="notranslate">com.example.myapp</code>。</li>
<li><strong>组织结构</strong>：包通常按照功能或模块来组织。例如，一个大型项目可能包含多个子项目，每个子项目都有自己的包。</li>
<li><strong>访问控制</strong>：Java的访问修饰符（public, protected, default, private）与包的使用密切相关。默认访问权限（没有指定访问修饰符）的类或成员只能在同一个包内被访问。</li>
<li><strong>避免过度使用</strong>：虽然包可以帮助组织代码，但过度使用包会使项目结构变得复杂难懂。合理地划分包的粒度很重要。</li>
<li><strong>遵循Java平台模块系统</strong>：从Java 9开始，Java引入了模块系统（JPMS），它允许更细粒度的控制包的可见性和依赖关系。使用模块可以提高代码的封装性和安全性。</li>
</ul>
<h3>4. 包与目录结构</h3>
<p>在文件系统中，包对应于目录结构。例如，<code class="notranslate">com.example.myapp</code>包对应的目录结构可能是：</p>
<pre lang="plain" class="notranslate"><code class="notranslate">src/
└── com/
    └── example/
        └── myapp/
</code></pre>
<p>每个包名的组成部分对应于目录结构中的一个目录。</p>
<h3>5. 包的声明顺序</h3>
<p>在Java文件中，<code class="notranslate">package</code>声明必须是文件的第一行非注释代码，它不能与其他语句或声明一起使用。</p>
<p>通过合理使用包，可以提高Java项目的可维护性和可读性。</p>
<p>是的，Java中包名的一种常见约定是使用公司或组织的域名的倒置形式。这种约定有助于确保包名的唯一性，因为域名是唯一的，并且可以避免不同组织之间的命名冲突。下面是一些关于使用域名倒置作为包名的要点：</p>
<ol>
<li><strong>域名倒置</strong>：将域名的各个部分倒置，并将它们用点<code class="notranslate">.</code>分隔。例如，如果域名是<code class="notranslate">example.com</code>，则包名可以是<code class="notranslate">com.example</code>。</li>
<li><strong>添加项目或模块名称</strong>：在域名倒置的基础上，可以添加项目或模块的名称，以进一步组织代码。例如，如果项目名称是<code class="notranslate">myapp</code>，则完整的包名可能是<code class="notranslate">com.example.myapp</code>。</li>
<li><strong>避免使用顶级域名</strong>：在倒置的域名后面，通常会添加至少一个额外的名称，以避免直接使用顶级域名（如<code class="notranslate">com</code>、<code class="notranslate">org</code>等）作为包名的顶级元素。</li>
<li><strong>保持简洁</strong>：虽然使用域名倒置可以确保唯一性，但包名应该尽可能简洁，以便于理解和使用。</li>
<li><strong>遵循Java命名约定</strong>：Java的命名约定建议使用全小写字母，并且单词之间用驼峰命名法连接。这些约定同样适用于包名。</li>
</ol>
<p>使用域名倒置作为包名是一种广泛接受的最佳实践，它有助于确保包名的唯一性，并提供一个清晰的组织结构。这种命名方式在Java社区中非常流行，也被许多其他编程语言和框架所采用。</p>
<p>包名不要以 java 开头（安全问题）</p>
<p>用域名命名规范主要是便于区分不同组织</p>
<p>在计算机编程和软件开发中，“包”（Package）这个概念扮演着重要的角色，它的作用可以从多个角度来理解：</p>
<h3>1. 组织和管理代码</h3>
<ul>
<li><strong>逻辑分组</strong>：包允许开发者将功能相关的类和接口组织在一起，形成逻辑上的分组，这有助于代码的模块化和清晰性。</li>
<li><strong>层次结构</strong>：包提供了一种层次结构，允许开发者按照功能模块或业务逻辑创建嵌套的包结构。</li>
</ul>
<h3>2. 避免命名冲突</h3>
<ul>
<li><strong>命名空间</strong>：在大型项目或多团队协作中，不同的开发者可能会定义相同名称的类或方法。通过使用包，可以为每个类创建一个唯一的命名空间，从而避免命名冲突。</li>
</ul>
<h3>3. 控制访问权限</h3>
<ul>
<li><strong>封装性</strong>：包可以包含具有不同访问权限的类和成员（如public、protected、private）。这有助于控制不同包之间的访问级别，增强代码的封装性。</li>
<li><strong>默认访问权限</strong>：在Java中，没有指定访问修饰符的类或成员默认只能在同一个包内被访问，这有助于保护内部实现细节。</li>
</ul>
<h3>4. 提高代码的可维护性</h3>
<ul>
<li><strong>模块化</strong>：通过将功能相关的代码组织在同一个包中，可以提高代码的可维护性。当需要修改或更新某个功能时，只需要关注相应的包。</li>
<li><strong>重用性</strong>：包内的类和接口可以被其他包重用，这有助于减少代码的重复，并提高代码的重用性。</li>
</ul>
<h3>5. 便于部署和分发</h3>
<ul>
<li><strong>依赖管理</strong>：在现代软件开发中，包管理系统（如Maven、NPM）使用包的概念来管理项目的依赖关系，这使得依赖的安装、更新和版本控制变得更加容易。</li>
<li><strong>分发单元</strong>：包可以作为代码分发的基本单元，使得开发者可以轻松地共享和部署代码。</li>
</ul>
<h3>6. 支持多视图和国际化</h3>
<ul>
<li><strong>本地化</strong>：在支持多语言的应用程序中，包可以用来组织不同语言的资源文件，如字符串、图像等，以支持国际化和本地化。</li>
</ul>
<h3>7. 遵循标准和约定</h3>
<ul>
<li><strong>行业标准</strong>：在许多编程语言中，包的使用遵循特定的行业标准和约定，如Java中的包名通常采用域名倒置的格式。</li>
</ul>
<p>总的来说，包是软件开发中用于组织代码、控制访问权限、提高代码重用性和可维护性的重要工具。通过合理使用包，开发者可以构建更加清晰、模块化和易于维护的软件系统。</p>
<p>Java Development Kit (JDK) 提供了许多内置的包（package），这些包包含了大量的类和接口，用于支持各种编程任务。以下是一些JDK中非常重要的包：</p>
<ol>
<li><strong>java.lang</strong>：
<ul>
<li>包含Java语言的核心类，如<code class="notranslate">Object</code>、<code class="notranslate">String</code>、<code class="notranslate">Math</code>、<code class="notranslate">System</code>、<code class="notranslate">Thread</code>等。这些类是Java程序的基石，每个Java程序都会隐式地使用这个包。</li>
</ul>
</li>
<li><strong>java.util</strong>：
<ul>
<li>提供了一系列实用工具类，包括集合框架（<code class="notranslate">List</code>、<code class="notranslate">Set</code>、<code class="notranslate">Map</code>等）、日期和时间API（<code class="notranslate">Date</code>、<code class="notranslate">Calendar</code>）、并发工具类（<code class="notranslate">ThreadLocal</code>、<code class="notranslate">Executor</code>等）。</li>
</ul>
</li>
<li><strong>java.io</strong>：
<ul>
<li>包含输入/输出相关的类，用于处理文件、网络和管道通信。核心类包括<code class="notranslate">File</code>、<code class="notranslate">InputStream</code>、<code class="notranslate">OutputStream</code>、<code class="notranslate">Reader</code>、<code class="notranslate">Writer</code>等。</li>
</ul>
</li>
<li><strong>java.net</strong>：
<ul>
<li>提供了网络编程所需的类，如<code class="notranslate">URL</code>、<code class="notranslate">URLConnection</code>、<code class="notranslate">Socket</code>、<code class="notranslate">ServerSocket</code>等。</li>
</ul>
</li>
<li><strong>java.nio</strong>（New Input/Output）：
<ul>
<li>从Java 1.4开始引入，提供了一种更高效的I/O操作方式，支持文件锁定、内存映射文件等。核心类包括<code class="notranslate">ByteBuffer</code>、<code class="notranslate">FileChannel</code>、<code class="notranslate">Selector</code>等。</li>
</ul>
</li>
<li><strong>java.sql</strong>：
<ul>
<li>提供了数据库编程所需的类和接口，如<code class="notranslate">Connection</code>、<code class="notranslate">Statement</code>、<code class="notranslate">ResultSet</code>等，用于执行SQL语句和处理数据库查询结果。</li>
</ul>
</li>
<li><strong>javax.swing</strong>：
<ul>
<li>用于构建图形用户界面（GUI），包含<code class="notranslate">JFrame</code>、<code class="notranslate">JPanel</code>、<code class="notranslate">JButton</code>等组件。</li>
</ul>
</li>
<li><strong>java.awt</strong>：
<ul>
<li>包含用于创建图形用户界面的基本组件，如<code class="notranslate">Frame</code>、<code class="notranslate">Panel</code>、<code class="notranslate">Button</code>等，以及处理图形和图像的类。</li>
</ul>
</li>
<li><strong>java.beans</strong>：
<ul>
<li>提供了与JavaBean相关的类和接口，JavaBean是一种特殊的Java类，遵循特定的命名约定，用于开发可重用的组件。</li>
</ul>
</li>
<li><strong>java.text</strong>：
<ul>
<li>包含用于格式化、解析和处理文本的类，如<code class="notranslate">DateFormat</code>、<code class="notranslate">NumberFormat</code>等。</li>
</ul>
</li>
<li><strong>java.security</strong>：
<ul>
<li>提供了安全和加密相关的类和接口，如<code class="notranslate">Key</code>、<code class="notranslate">Certificate</code>、<code class="notranslate">MessageDigest</code>等。</li>
</ul>
</li>
<li><strong>java.lang.reflect</strong>：
<ul>
<li>提供了Java反射API，允许程序在运行时访问、检查和修改类的行为。</li>
</ul>
</li>
<li><strong>java.time</strong>（Java 8引入）：
<ul>
<li>替代了<code class="notranslate">java.util.Date</code>和<code class="notranslate">java.util.Calendar</code>，提供了更加强大和灵活的日期和时间API，如<code class="notranslate">LocalDate</code>、<code class="notranslate">LocalTime</code>、<code class="notranslate">ZonedDateTime</code>等。</li>
</ul>
</li>
<li><strong>javafx</strong>（JavaFX SDK）：
<ul>
<li>用于构建富客户端应用程序的现代GUI工具包，提供了<code class="notranslate">Stage</code>、<code class="notranslate">Scene</code>、<code class="notranslate">Pane</code>等组件。</li>
</ul>
</li>
</ol>
<p>这些包是JDK中非常核心的部分，涵盖了基础功能、I/O操作、网络编程、数据库访问、GUI构建等多个方面。了解和掌握这些包对于Java开发者来说非常重要。</p>
<p>MVC（Model-View-Controller）设计模式是一种用于软件设计，特别是用户界面设计中常用的设计模式。它将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller），以实现关注点分离，提高代码的可维护性和可扩展性。下面是这三个组件的简要介绍：</p>
<ol>
<li><strong>模型（Model）</strong>：
<ul>
<li><strong>定义</strong>：模型代表应用程序的数据结构和业务逻辑。它是应用程序的主体，负责管理数据、执行业务规则和逻辑。</li>
<li><strong>职责</strong>：包括数据的存储、检索、验证、计算等。模型通常不包含任何界面元素，只负责数据的处理。</li>
<li><strong>交互</strong>：模型可以通知视图关于数据的变化，以便视图可以更新显示。</li>
</ul>
</li>
<li><strong>视图（View）</strong>：
<ul>
<li><strong>定义</strong>：视图是用户界面组件，负责显示数据（即模型）并收集用户的输入。</li>
<li><strong>职责</strong>：展示模型中的数据，提供用户界面元素（如文本框、按钮、列表等），并处理用户的交互（如点击、输入等）。</li>
<li><strong>交互</strong>：视图从模型接收数据，并在用户进行操作时，通过控制器更新模型。</li>
</ul>
</li>
<li><strong>控制器（Controller）</strong>：
<ul>
<li><strong>定义</strong>：控制器是应用程序的中介者，它接收用户的输入并调用模型和视图去完成用户的需求。</li>
<li><strong>职责</strong>：处理用户的输入，将输入转换为模型的数据操作，更新模型的状态，并选择合适的视图来显示模型的数据。</li>
<li><strong>交互</strong>：控制器接收来自视图的用户输入，调用模型进行处理，然后根据模型的状态更新视图。</li>
</ul>
</li>
</ol>
<p>MVC设计模式的主要优点包括：</p>
<ul>
<li><strong>关注点分离</strong>：将数据处理、用户界面和用户输入处理分开，使得各个部分可以独立开发和维护。</li>
<li><strong>提高代码的可维护性</strong>：由于关注点分离，修改一个组件不会影响其他组件，降低了维护的复杂性。</li>
<li><strong>提高可扩展性</strong>：新的功能可以更容易地添加到模型、视图或控制器中，而不需要重写整个应用程序。</li>
<li><strong>多视图支持</strong>：同一个模型可以支持多个视图，这意味着你可以为不同的用户界面或设备提供不同的视图，而不需要改变模型本身。</li>
</ul>
<p>MVC模式也有其局限性，例如可能导致过多的控制器代码，以及在大型应用程序中可能导致组件之间的复杂交互。为了解决这些问题，衍生出了MVC的变体，如MVP（Model-View-Presenter）和MVVM（Model-View-ViewModel），它们在某些方面对MVC进行了改进。</p>
<p>在Java中，<code class="notranslate">import</code>语句用于导入其他包中的类或整个包，以便在当前文件中使用这些类而不需要完全限定类名。这有助于简化代码，使其更加清晰和易于维护。以下是<code class="notranslate">import</code>语句的一些使用方式：</p>
<h3>导入单个类</h3>
<p>如果你只需要使用某个包中的一个或几个类，可以单独导入这些类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">List</span>;
<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Map</span>;</pre></div>
<p>这样，你就可以在代码中直接使用<code class="notranslate">List</code>和<code class="notranslate">Map</code>，而不需要每次都写<code class="notranslate">java.util.List</code>。</p>
<h3>导入整个包</h3>
<p>如果你需要使用某个包中的多个类，可以导入整个包：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.*;</pre></div>
<p>这将导入<code class="notranslate">java.util</code>包中的所有类，但请注意，这种做法可能会导致命名冲突，并且不推荐在大型项目中使用，因为它降低了代码的清晰度。</p>
<h3>静态导入</h3>
<p>Java 5引入了静态导入，允许导入静态方法和静态字段，使得调用这些成员时不需要指定类名：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.<span class="pl-c1">PI</span>;
<span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">java</span>.<span class="pl-s1">lang</span>.<span class="pl-s1">Math</span>.<span class="pl-s1">sqrt</span>;</pre></div>
<p>之后，你可以直接使用<code class="notranslate">PI</code>和<code class="notranslate">sqrt</code>，而不需要<code class="notranslate">Math.PI</code>和<code class="notranslate">Math.sqrt</code>。</p>
<h3>导入规则和最佳实践</h3>
<ol>
<li><strong>避免导入整个包</strong>：虽然导入整个包可以减少代码量，但它可能会导致命名冲突，并使代码难以阅读。推荐按需导入单个类。</li>
<li><strong>保持一致性</strong>：在项目中保持一致的导入风格，比如是否使用<code class="notranslate">*</code>来导入整个包。</li>
<li><strong>避免不必要的导入</strong>：只导入实际使用的类，避免导入未使用的类，以减少混乱和潜在的命名冲突。</li>
<li><strong>静态导入的使用</strong>：静态导入适用于频繁使用的静态方法和字段，但也要谨慎使用，以免代码过于依赖静态成员，影响代码的可测试性和模块化。</li>
<li><strong>导入顺序</strong>：通常建议按照以下顺序排列<code class="notranslate">import</code>语句：
<ul>
<li>Java核心库类（如<code class="notranslate">java.*</code>）</li>
<li>Java扩展库类（如<code class="notranslate">javax.*</code>）</li>
<li>第三方库类</li>
<li>项目自己的类（按字母顺序）</li>
</ul>
</li>
<li><strong>IDE支持</strong>：现代IDE（如IntelliJ IDEA、Eclipse）通常提供自动导入功能，可以自动管理<code class="notranslate">import</code>语句，减少手动操作。</li>
</ol>
<p>正确使用<code class="notranslate">import</code>语句可以提高代码的可读性和可维护性，是Java编程中的一个重要方面。</p>
<p>封装性</p>
<p>封装（Encapsulation）是Java面向对象编程（OOP）的三大特性之一，其他两个是继承（Inheritance）和多态（Polymorphism）。封装的核心思想是将对象的属性和实现细节隐藏起来，只对外提供必要的接口。这种做法不仅提高了代码的安全性和可维护性，还能减少耦合，使代码更易于理解和修改。</p>
<h3>封装的概念</h3>
<p>封装是指将对象的属性和方法隐藏在其内部，只对外提供必要的访问方式。通过这种方式，可以保护对象的内部状态，防止外部程序直接访问和修改对象的内部数据。</p>
<h3>封装的优点</h3>
<ol>
<li><strong>减少耦合</strong>：良好的封装能够减少类与类之间的耦合度，使得代码更加模块化。</li>
<li><strong>隐藏实现细节</strong>：通过隐藏类的内部实现细节，只暴露必要的接口，可以防止外部直接访问和修改对象的状态。</li>
<li><strong>提高代码的可维护性</strong>：封装使得代码更容易理解和维护，修改类的内部实现不会影响到外部代码。</li>
<li><strong>控制访问</strong>：可以通过访问修饰符（如private、protected、public）来控制对类成员的访问权限，从而提高数据的安全性。</li>
</ol>
<h3>实现封装的步骤</h3>
<ol>
<li><strong>将属性设置为私有</strong>：通过将类的属性声明为私有（private），限制外部对这些属性的直接访问。</li>
<li><strong>提供公共的访问方法</strong>：通过提供公共的getter和setter方法，允许外部程序访问和修改私有属性。</li>
</ol>
<h3>示例代码</h3>
<p>以下是一个简单的Java封装示例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-c">// 私有属性</span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">// 公共的getter方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-c">// 公共的setter方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-c">// 公共的getter方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">age</span>;
    }

    <span class="pl-c">// 公共的setter方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAge</span>(<span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">age</span> &gt;= <span class="pl-c1">0</span>) {
            <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-smi">IllegalArgumentException</span>(<span class="pl-s">"Age cannot be negative"</span>);
        }
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestPerson</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Person</span> <span class="pl-s1">person</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
        <span class="pl-s1">person</span>.<span class="pl-en">setName</span>(<span class="pl-s">"Alice"</span>);
        <span class="pl-s1">person</span>.<span class="pl-en">setAge</span>(<span class="pl-c1">25</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Name: "</span> + <span class="pl-s1">person</span>.<span class="pl-en">getName</span>());
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Age: "</span> + <span class="pl-s1">person</span>.<span class="pl-en">getAge</span>());
    }
}</pre></div>
<h3>详细解释</h3>
<ol>
<li><strong>私有属性</strong>：在<code class="notranslate">Person</code>类中，<code class="notranslate">name</code>和<code class="notranslate">age</code>属性被声明为私有，这意味着它们只能在类的内部被访问和修改。</li>
<li><strong>公共方法</strong>：通过提供公共的getter和setter方法，外部程序可以访问和修改私有属性。例如，<code class="notranslate">getName</code>和<code class="notranslate">setName</code>方法允许外部程序访问和修改<code class="notranslate">name</code>属性。</li>
<li><strong>数据验证</strong>：在setter方法中，可以添加数据验证逻辑。例如，在<code class="notranslate">setAge</code>方法中，添加了一个检查，确保年龄不能为负数。</li>
</ol>
<h3>封装的实际应用</h3>
<ol>
<li><strong>数据验证</strong>：在setter方法中，可以对输入的数据进行验证，以确保其符合预期的格式或范围。</li>
<li><strong>懒加载</strong>：在getter方法中，可以实现懒加载策略，即只在第一次需要访问某个属性时才加载该属性的值。</li>
<li><strong>日志记录</strong>：在getter和setter方法中，可以添加日志记录功能，以记录对对象内部状态的访问和修改操作。</li>
</ol>
<h3>总结</h3>
<p>封装是Java面向对象编程的重要特性之一，通过将对象的属性和方法隐藏在其内部，并提供必要的访问方式，封装不仅提高了程序的安全性、可维护性和可重用性，还能实现数据验证、懒加载和日志记录等高级功能。因此，在Java编程中，应充分利用封装的优势来设计和实现高质量的代码。</p>
<h4>权限修饰符</h4>
<p>Java中提供了四种访问权限修饰符，它们可以修饰类、接口中的成员（字段和方法）：</p>
<ol>
<li><strong>private</strong>：私有权限，被private修饰的成员变量或方法，只能在定义它们的类内部访问，不能被外部访问。</li>
<li><strong>default</strong>（默认）：没有指定访问修饰符，称为默认访问权限。类成员如果采用默认访问权限，则只能被同一个包中的其他类访问。</li>
<li><strong>protected</strong>：受保护的权限，被protected修饰的成员变量或方法可以被同一个包中的其他类访问，也可以被不同包中的子类访问。</li>
<li><strong>public</strong>：公共权限，被public修饰的成员变量或方法可以被任何其他类访问，没有任何访问限制。</li>
</ol>
<p>以下是权限修饰符的访问级别对比表：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>类型</th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包</td>
<td>✗</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包，子类</td>
<td>✗</td>
<td>✗</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包，非子类</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>√</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>权限修饰符的使用规则：</h3>
<ul>
<li><strong>类和接口</strong>：不能被声明为private或protected，但可以声明为public或默认。</li>
<li><strong>成员变量</strong>：可以被声明为private、default、protected或public。</li>
<li><strong>方法</strong>：可以被声明为private、default、protected或public。</li>
<li><strong>构造方法</strong>：可以被声明为private、default、protected或public。</li>
<li><strong>内部类</strong>：可以被声明为private、default、protected或public。</li>
</ul>
<h3>权限修饰符的作用：</h3>
<ul>
<li><strong>private</strong>：用于隐藏类的内部信息，确保外部代码不能直接访问对象的内部状态，只能通过公共的接口（getter/setter）进行交互。</li>
<li><strong>default</strong>：用于控制类成员在同一个包内可见，有助于包的封装性，避免过度暴露类的内部实现。</li>
<li><strong>protected</strong>：用于允许类的子类访问其成员，即使子类在不同的包中也能访问。</li>
<li><strong>public</strong>：用于提供类的外部接口，使类成员可以被任何其他类访问。</li>
</ul>
<p>权限修饰符是Java语言中实现封装和控制访问级别的重要工具，合理使用权限修饰符可以提高代码的安全性和可维护性。</p>
<p>代码示例</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * Test</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建Animal对象并设置属性</span>
        <span class="pl-smi">Animal</span> <span class="pl-s1">animl1</span> = <span class="pl-k">new</span> <span class="pl-smi">Animal</span>();
        <span class="pl-s1">animl1</span>.<span class="pl-s1">name</span> = <span class="pl-s">"金蟾"</span>;
        <span class="pl-s1">animl1</span>.<span class="pl-en">setLeg</span>(<span class="pl-c1">4</span>); <span class="pl-c">// 调用setLeg方法设置腿的数量</span>

        <span class="pl-c">// 打印动物的名字和腿的数量</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"动物名称:"</span> + <span class="pl-s1">animl1</span>.<span class="pl-s1">name</span> + <span class="pl-s">" 动物腿数:"</span> + <span class="pl-s1">animl1</span>.<span class="pl-en">getLeg</span>());

        <span class="pl-c">// 访问修饰符</span>
        <span class="pl-c">// public: 公共的，任何类都可以访问</span>
        <span class="pl-c">// private: 私有的，只有本类可以访问</span>
        <span class="pl-c">// protected: 受保护的，本类、同包类、子类可以访问</span>
        <span class="pl-c">// 默认（不写）：本类、同包类可以访问</span>

        <span class="pl-c">// 其他修饰符</span>
        <span class="pl-c">// static: 静态的，类变量、类方法</span>
        <span class="pl-c">// final: 最终的，常量、类、方法、变量</span>
        <span class="pl-c">// abstract: 抽象的，抽象类、抽象方法</span>
        <span class="pl-c">// transient: 瞬态的，不会被序列化的变量</span>
        <span class="pl-c">// volatile: 易变的，多线程操作共享变量</span>
        <span class="pl-c">// synchronized: 同步的，多线程操作共享变量</span>
        <span class="pl-c">// native: 本地的，调用本地方法</span>
        <span class="pl-c">// strictfp: 精确浮点，浮点运算更加精确</span>
        <span class="pl-c">// default: 默认的，接口方法</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Animal</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>; <span class="pl-c">// 名字</span>
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;     <span class="pl-c">// 年龄</span>
    <span class="pl-smi">String</span> <span class="pl-s1">color</span>;<span class="pl-c">// 颜色</span>
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">leg</span>; <span class="pl-c">// 腿的数量</span>

    <span class="pl-c">// 设置腿的数量</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setLeg</span>(<span class="pl-smi">int</span> <span class="pl-s1">l</span>) {
        <span class="pl-k">if</span> (<span class="pl-s1">l</span> &gt;= <span class="pl-c1">0</span> &amp;&amp; <span class="pl-s1">l</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>) {
            <span class="pl-s1">leg</span> = <span class="pl-s1">l</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"请输入正确的腿数"</span>);
        }
    }

    <span class="pl-c">// 获取腿的数量</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getLeg</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">leg</span>;
    }

    <span class="pl-c">// 动物觅食的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"动物觅食"</span>);
    }
}</pre></div>
<p>如何体现封装性？</p>
<p>java 规定了四种访问权限修饰符，分别是 private ，缺省 ，protected ，public</p>
<p>我们可以用这四种权限去修饰类及类的成员，当这些成员被调用时体现可见性的大小</p>
<p>（类只能使用 public 和 缺省 修饰 类的内部成员可以使用四种修饰符）</p>
<p>使用频率</p>
<p>高 public private</p>
<p>低 缺省 protected</p>
<p>封装性的体现</p>
<p>场景1,私有化（pr1vate)类的属性，提供公共（public)的get和set方法，对此属性进行获取或修改</p>
<p>场景2:将类中不需要对外暴露的方法，设置为pr1vate</p>
<p>场景3,单例模式中构造器private的了，避免在类的外部创建实例。(放到static关键字后讲）</p>
<p>封装性的体现主要在于将对象的状态（属性）和行为（方法）捆绑在一起，并对对象的内部实现细节进行隐藏，仅通过有限的接口与外界通信。以下是封装性的几个具体体现和应用场景：</p>
<h3>封装性的体现：</h3>
<ol>
<li><strong>隐藏内部实现细节</strong>：
<ul>
<li>通过将类的成员变量设置为私有（<code class="notranslate">private</code>），不允许外部直接访问。</li>
<li>仅通过公共的访问方法（<code class="notranslate">public</code> getter/setter）来提供对属性的访问和修改。</li>
</ul>
</li>
<li><strong>提供公共接口</strong>：
<ul>
<li>提供公共的方法（<code class="notranslate">public</code>）来允许外部代码以受控的方式访问和修改私有属性。</li>
<li>通过这些公共接口，可以在修改内部实现时不影响外部代码。</li>
</ul>
</li>
<li><strong>数据校验</strong>：
<ul>
<li>在setter方法中添加逻辑来校验赋给属性的值，确保数据的有效性和合理性。</li>
</ul>
</li>
<li><strong>数据封装</strong>：
<ul>
<li>将相关属性和处理这些属性的方法封装在一起，构成一个独立的实体。</li>
</ul>
</li>
<li><strong>实现细节的变化不影响外部</strong>：
<ul>
<li>可以在不影响使用该类的代码的情况下修改类的内部实现。</li>
</ul>
</li>
<li><strong>提高代码的可读性和可维护性</strong>：
<ul>
<li>将属性和方法组织在同一个类中，使得代码结构更清晰，易于理解和维护。</li>
</ul>
</li>
</ol>
<h3>应用场景：</h3>
<ol>
<li><strong>数据校验</strong>：
<ul>
<li>在用户注册时，通过封装确保用户提供的邮箱、密码等信息符合特定的格式和安全要求。</li>
</ul>
</li>
<li><strong>对象状态管理</strong>：
<ul>
<li>在游戏中，通过封装管理角色的状态，如生命值、能量等，并通过方法来修改这些状态，而不是直接暴露这些属性。</li>
</ul>
</li>
<li><strong>设备控制</strong>：
<ul>
<li>在硬件操作中，通过封装隐藏复杂的硬件访问细节，提供简单的接口来控制设备。</li>
</ul>
</li>
<li><strong>业务逻辑抽象</strong>：
<ul>
<li>在业务系统中，通过封装将复杂的业务逻辑细节隐藏起来，对外提供简单的服务接口。</li>
</ul>
</li>
<li><strong>数据缓存</strong>：
<ul>
<li>在需要缓存数据的场景中，通过封装实现数据的懒加载，即仅在需要时才从数据库或其他存储介质中加载数据。</li>
</ul>
</li>
<li><strong>日志记录和审计</strong>：
<ul>
<li>在setter和getter方法中添加日志记录，以跟踪对象状态的变化，这对于调试和审计非常有用。</li>
</ul>
</li>
<li><strong>保护敏感信息</strong>：
<ul>
<li>对于包含敏感信息的对象，如银行账户、个人身份信息等，通过封装确保这些信息不被未授权访问。</li>
</ul>
</li>
<li><strong>接口与实现的分离</strong>：
<ul>
<li>在开发库或框架时，通过封装将接口与具体实现分离，使得实现可以在不影响使用者的情况下进行更改。</li>
</ul>
</li>
<li><strong>代码重用</strong>：
<ul>
<li>在需要重用代码的场景中，通过封装可以轻松地将一个类的实现替换为另一个类，只要它们提供了相同的接口。</li>
</ul>
</li>
<li><strong>解耦合</strong>：
<ul>
<li>在复杂的系统中，通过封装减少各个组件之间的依赖，提高系统的灵活性和可维护性。</li>
</ul>
</li>
</ol>
<p>封装性是面向对象设计的核心原则之一，它有助于构建松耦合、高内聚的系统，使得代码更加健壮、灵活和易于维护。</p>
<p>例子</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">PersonTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//创建Person实例1</span>
        <span class="pl-smi">Person</span> <span class="pl-s1">person1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
        <span class="pl-c">// person1.age;</span>
        <span class="pl-s1">person1</span>.<span class="pl-en">setAge</span>(<span class="pl-c1">18</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">//设置age的属性</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAge</span>(<span class="pl-smi">int</span> <span class="pl-s1">age</span>){
        <span class="pl-k">if</span>(<span class="pl-s1">age</span>&gt;= <span class="pl-c1">0</span> &amp;&amp; <span class="pl-s1">age</span> &lt;= <span class="pl-c1">150</span>){
            <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
        }<span class="pl-k">else</span>{
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"年龄不合法"</span>);
        }
    }

    <span class="pl-c">//获取age的属性</span>

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getAge</span>(){
        <span class="pl-k">return</span> <span class="pl-s1">age</span>;
    }
}</pre></div>
<p>构造器</p>
<p>在Java中，构造器（Constructor）是一种特殊的方法，用于在创建新对象时初始化对象。构造器的名称必须与类名完全相同，并且没有返回类型，甚至连<code class="notranslate">void</code>类型的返回值也没有。构造器的主要目的是让数据成员（属性）在对象创建时就被初始化。</p>
<h3>构造器的特点：</h3>
<ol>
<li><strong>名称</strong>：构造器的名称必须与类名完全相同。</li>
<li><strong>返回类型</strong>：构造器没有返回类型，连<code class="notranslate">void</code>也不行。</li>
<li><strong>调用</strong>：在创建新对象时自动调用。</li>
<li><strong>重载</strong>：可以有多个构造器，只要它们的参数列表不同（参数的数量或类型不同）。</li>
<li><strong>隐式调用</strong>：如果未显式定义构造器，编译器会提供一个默认无参构造器。</li>
</ol>
<h3>构造器的作用：</h3>
<ol>
<li><strong>初始化对象</strong>：在对象创建时给对象的属性赋初值。</li>
<li><strong>控制对象的创建</strong>：通过重载构造器，可以控制对象的创建过程。</li>
<li><strong>提高封装性</strong>：通过私有构造器和工厂方法，可以控制对象的创建和访问。</li>
</ol>
<h3>构造器的分类：</h3>
<ol>
<li><strong>无参构造器</strong>（No-argument Constructor）：
<ul>
<li>没有参数的构造器。</li>
<li>如果没有显式定义任何构造器，编译器会提供一个默认的无参构造器。</li>
</ul>
</li>
<li><strong>有参构造器</strong>（Parameterized Constructor）：
<ul>
<li>带有参数的构造器，用于在创建对象时初始化对象的属性。</li>
</ul>
</li>
<li><strong>重载构造器</strong>（Constructor Overloading）：
<ul>
<li>一个类中可以有多个构造器，只要它们的参数列表不同。</li>
</ul>
</li>
</ol>
<h3>构造器的继承：</h3>
<ul>
<li>父类的构造器不能被子类继承，子类必须通过<code class="notranslate">super</code>关键字显式调用父类的构造器。</li>
</ul>
<h3>构造器的使用示例：</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">// 无参构造器</span>
    <span class="pl-k">public</span> <span class="pl-smi">Person</span>() {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s">"Unknown"</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-c1">0</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person created with default values."</span>);
    }

    <span class="pl-c">// 有参构造器</span>
    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person created with name: "</span> + <span class="pl-s1">name</span> + <span class="pl-s">" and age: "</span> + <span class="pl-s1">age</span>);
    }

    <span class="pl-c">// Getter and Setter</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">age</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAge</span>(<span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestConstructor</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Person</span> <span class="pl-s1">person1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>(); <span class="pl-c">// 调用无参构造器</span>
        <span class="pl-smi">Person</span> <span class="pl-s1">person2</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>(<span class="pl-s">"Alice"</span>, <span class="pl-c1">30</span>); <span class="pl-c">// 调用有参构造器</span>
    }
}</pre></div>
<p>在这个例子中，<code class="notranslate">Person</code>类有两个构造器：一个无参构造器和一个有参构造器。无参构造器提供了默认的初始化值，而有参构造器允许在创建对象时设置具体的属性值。</p>
<p>构造器是对象生命周期的起点，正确地使用构造器可以确保对象在创建时就处于有效和一致的状态。</p>
<p>每个类都有构造器</p>
<p>构造器的作用</p>
<ul>
<li>搭配 new 关键字，创建类的对象</li>
<li>在创建对象的同时，可以给对象的相关属性赋值</li>
<li>创建类以后，在没有显示提供任何构造器的情况下，系统会默认提供一个空参的构造器，且权限与类的权限相同</li>
<li>一旦类中显示声明了构造器，那么系统将不再提供·空参的构造器</li>
<li>在一个类中可以声明多个构造器，彼此直接可以构成重载</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StudentTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Student</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>(<span class="pl-s">"张三"</span>, <span class="pl-c1">20</span>, <span class="pl-s">"男"</span>, <span class="pl-s">"计算机"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s</span>.<span class="pl-s1">name</span> + <span class="pl-s">" "</span> + <span class="pl-s1">s</span>.<span class="pl-s1">age</span> + <span class="pl-s">" "</span> + <span class="pl-s1">s</span>.<span class="pl-s1">school</span> + <span class="pl-s">" "</span> + <span class="pl-s1">s</span>.<span class="pl-s1">major</span>);

        <span class="pl-smi">Student</span> <span class="pl-s1">s2</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>(<span class="pl-s">"李四"</span>, <span class="pl-c1">21</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s2</span>.<span class="pl-s1">name</span> + <span class="pl-s">" "</span> + <span class="pl-s1">s2</span>.<span class="pl-s1">age</span> );

        

    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Student</span> {
    <span class="pl-c">//构造器说明</span>
    <span class="pl-c">//1.构造器没有返回值</span>
    <span class="pl-c">//2.构造器的名称必须和类名相同</span>
    <span class="pl-c">//3.构造器的作用是完成对对象的初始化操作</span>
    <span class="pl-c">//4.如果你没有显式的定义类的构造器的话，则系统默认提供一个无参数的构造器</span>
    <span class="pl-c">//5.一旦你显式的定义了一个构造器，则系统就不再提供默认的无参数的构造器了</span>
    <span class="pl-c">//6.构造器也是可以重载的</span>


     <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
     <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
     <span class="pl-smi">String</span> <span class="pl-s1">school</span>;
     <span class="pl-smi">String</span> <span class="pl-s1">major</span>;<span class="pl-c">//主修课</span>

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">n</span>, <span class="pl-smi">int</span> <span class="pl-s1">a</span>) {
        <span class="pl-s1">name</span> = <span class="pl-s1">n</span>;
        <span class="pl-s1">age</span> = <span class="pl-s1">a</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">n</span>, <span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">String</span> <span class="pl-s1">s</span>) {
        <span class="pl-s1">name</span> = <span class="pl-s1">n</span>;
        <span class="pl-s1">age</span> = <span class="pl-s1">a</span>;
        <span class="pl-s1">school</span> = <span class="pl-s1">s</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>, <span class="pl-smi">String</span> <span class="pl-s1">school</span>, <span class="pl-smi">String</span> <span class="pl-s1">major</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">school</span> = <span class="pl-s1">school</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">major</span> = <span class="pl-s1">major</span>;
    }

    
}</pre></div>
<p>存款取款例子</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CustomerTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//创建Customer实例</span>
        <span class="pl-smi">Customer</span> <span class="pl-s1">customer</span> = <span class="pl-k">new</span> <span class="pl-smi">Customer</span>(<span class="pl-s">"Jane"</span>, <span class="pl-s">"Smith"</span>);

        <span class="pl-smi">Account</span> <span class="pl-s1">account</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>(<span class="pl-c1">1001</span>, <span class="pl-c1">20000.0</span>, <span class="pl-c1">0.045</span>);
        <span class="pl-s1">customer</span>.<span class="pl-en">setAccount</span>(<span class="pl-s1">account</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"客户姓名："</span> + <span class="pl-s1">customer</span>.<span class="pl-en">getFirstName</span>() + <span class="pl-s">" "</span> + <span class="pl-s1">customer</span>.<span class="pl-en">getLastName</span>());

        <span class="pl-c">//对客户的取钱存钱</span>
        <span class="pl-s1">customer</span>.<span class="pl-en">getAccount</span>().<span class="pl-en">deposit</span>(<span class="pl-c1">1000</span>);
        <span class="pl-s1">customer</span>.<span class="pl-en">getAccount</span>().<span class="pl-en">deposit</span>(<span class="pl-c1">2000</span>);
        <span class="pl-s1">customer</span>.<span class="pl-en">getAccount</span>().<span class="pl-en">withdraw</span>(<span class="pl-c1">5000</span>);

        <span class="pl-c">//输出客户信息</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"客户姓名："</span> + <span class="pl-s1">customer</span>.<span class="pl-en">getFirstName</span>() + <span class="pl-s">" "</span> + <span class="pl-s1">customer</span>.<span class="pl-en">getLastName</span>());

    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Customer</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">firstName</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">lastName</span>;
    <span class="pl-k">private</span> <span class="pl-smi">Account</span> <span class="pl-s1">account</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Customer</span>(<span class="pl-smi">String</span> <span class="pl-s1">f</span>,<span class="pl-smi">String</span> <span class="pl-s1">l</span>){
        <span class="pl-s1">firstName</span>=<span class="pl-s1">f</span>;
        <span class="pl-s1">lastName</span>=<span class="pl-s1">l</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getFirstName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">firstName</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getLastName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">lastName</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Account</span> <span class="pl-en">getAccount</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">account</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAccount</span>(<span class="pl-smi">Account</span> <span class="pl-s1">account</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">account</span> = <span class="pl-s1">account</span>;
    }

}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Account</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">id</span>;
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">balname</span>;<span class="pl-c">//余额</span>
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">annualInterestRate</span>;<span class="pl-c">//年利率</span>

    <span class="pl-k">public</span> <span class="pl-smi">Account</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>,<span class="pl-smi">double</span> <span class="pl-s1">b</span>,<span class="pl-smi">double</span> <span class="pl-s1">a</span>){
        <span class="pl-s1">id</span>=<span class="pl-s1">i</span>;
        <span class="pl-s1">balname</span>=<span class="pl-s1">b</span>;
        <span class="pl-s1">annualInterestRate</span>=<span class="pl-s1">a</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getId</span>(){
        <span class="pl-k">return</span> <span class="pl-s1">id</span>;

    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setBalname</span>(<span class="pl-smi">double</span> <span class="pl-s1">b</span>){
        <span class="pl-s1">balname</span>=<span class="pl-s1">b</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setId</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>){
        <span class="pl-s1">id</span>=<span class="pl-s1">i</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAnnualInterestRate</span>(<span class="pl-smi">double</span> <span class="pl-s1">a</span>){
        <span class="pl-s1">annualInterestRate</span>=<span class="pl-s1">a</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">getAnnualInterestRate</span>(){
        <span class="pl-k">return</span> <span class="pl-s1">annualInterestRate</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">withdraw</span>(<span class="pl-smi">double</span> <span class="pl-s1">m</span>){
        <span class="pl-k">if</span>(<span class="pl-s1">m</span>&gt;<span class="pl-s1">balname</span>){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"余额不足"</span>);
        }<span class="pl-k">else</span>{
            <span class="pl-s1">balname</span>=<span class="pl-s1">balname</span>-<span class="pl-s1">m</span>;
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"取款成功"</span>);
        }
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">deposit</span>(<span class="pl-smi">double</span> <span class="pl-s1">m</span>){
        <span class="pl-s1">balname</span>+=<span class="pl-s1">m</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"存款成功"</span>);
    }

    



}</pre></div>
<p>在Java中，匿名对象（Anonymous Object）是指没有显式名称的对象。这种对象通常是局部的，并且只在创建它的代码块中可见。匿名对象经常与接口或抽象类的匿名内部类一起使用，以实现特定的行为。</p>
<h3>匿名对象的特点：</h3>
<ol>
<li><strong>局部作用域</strong>：匿名对象只在创建它的代码块中有效。</li>
<li><strong>没有名称</strong>：匿名对象没有名称，因此不能被引用。</li>
<li><strong>单次使用</strong>：通常用于单次操作，如创建后立即调用其方法。</li>
<li><strong>与接口或抽象类一起使用</strong>：经常用来直接实现接口或继承抽象类，而不需要创建一个具体的类。</li>
</ol>
<h3>匿名对象的使用场景：</h3>
<ol>
<li><strong>实现接口</strong>：当需要一个接口的实例来临时实现某个功能时。</li>
<li><strong>继承抽象类</strong>：当需要一个抽象类的实例来临时实现某些方法时。</li>
<li><strong>回调</strong>：在需要提供回调函数时，尤其是当回调只需要使用一次时。</li>
<li><strong>事件监听器</strong>：在为组件添加事件监听器时，经常使用匿名对象来实现<code class="notranslate">EventListener</code>接口。</li>
</ol>
<h3>匿名对象的示例：</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 使用匿名对象实现Runnable接口来创建线程</span>
<span class="pl-smi">Thread</span> <span class="pl-s1">thread</span> = <span class="pl-k">new</span> <span class="pl-smi">Thread</span>(<span class="pl-k">new</span> <span class="pl-smi">Runnable</span>() {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Thread is running."</span>);
    }
});

<span class="pl-s1">thread</span>.<span class="pl-en">start</span>();

<span class="pl-c">// 使用匿名对象作为方法参数</span>
<span class="pl-s1">button</span>.<span class="pl-en">setOnClickListener</span>(<span class="pl-k">new</span> <span class="pl-smi">View</span>.<span class="pl-smi">OnClickListener</span>() {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">onClick</span>(<span class="pl-smi">View</span> <span class="pl-s1">v</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Button is clicked."</span>);
    }
});</pre></div>
<p>在第一个例子中，我们创建了一个<code class="notranslate">Thread</code>对象，其接收一个实现了<code class="notranslate">Runnable</code>接口的匿名对象作为参数。这个匿名对象重写了<code class="notranslate">run</code>方法，当线程启动时，会执行这个方法。</p>
<p>在第二个例子中，我们创建了一个按钮点击事件的监听器。我们传递了一个实现了<code class="notranslate">View.OnClickListener</code>接口的匿名对象给<code class="notranslate">setOnClickListener</code>方法。这个匿名对象重写了<code class="notranslate">onClick</code>方法，当按钮被点击时，会执行这个方法。</p>
<h3>匿名对象的注意事项：</h3>
<ul>
<li>匿名对象不能有构造器，因为它们没有名称。</li>
<li>匿名对象不能被声明为<code class="notranslate">final</code>，因为它们没有名称，无法被引用。</li>
<li>匿名对象通常用于实现一个接口或继承一个抽象类，并且实现的方式是匿名的、局部的。</li>
</ul>
<p>匿名对象是Java中实现特定功能的一种简洁方式，它们使得代码更加紧凑，尤其是在处理回调和事件监听器时。然而，过度使用匿名对象可能会导致代码的可读性和可维护性降低，因此应该在适当的场合使用。</p>
<p>匿名对象没有对象名，往往只能使用一次，后续无法调用。</p>
<p>匿名对象常常作为实参传递给形参</p>
<p>'''</p>
<p>customer.setAcccount().deposit(100);</p>
<p>'''</p>
<p>类中属性 可以通过哪种方法赋值</p>
<ul>
<li>默认赋值</li>
<li>显示赋值</li>
<li>构造器中赋值</li>
<li>通过对象.方法赋值</li>
<li>通过对象.属性 的方式赋值</li>
</ul>
<p>赋值的先后顺序</p>
<p>1 2 3 4/5</p>
<p>在Java中，类的属性（成员变量）可以通过以下几种方式进行赋值，并且它们的赋值顺序如下：</p>
<ol>
<li><strong>直接在字段声明时赋值（Field Initialization）</strong>：<br>
属性可以在声明时直接赋予初始值。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">value</span> = <span class="pl-c1">10</span>; <span class="pl-c">// 声明时直接赋值</span>
}</pre></div>
<p>这种赋值方式最先执行，因为它是直接在字段声明时进行的。</p>
<ol start="2">
<li><strong>通过构造器赋值（Constructor Assignment）</strong>：<br>
在类的构造器中对属性进行赋值。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">value</span>;
    <span class="pl-k">public</span> <span class="pl-smi">Example</span>(<span class="pl-smi">int</span> <span class="pl-s1">value</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">value</span> = <span class="pl-s1">value</span>; <span class="pl-c">// 通过构造器赋值</span>
    }
}</pre></div>
<p>构造器赋值在对象创建时执行，它在字段声明赋值之后执行，因为对象的内存空间被分配后，首先会执行字段的声明赋值，然后才执行构造器中的代码。</p>
<ol start="3">
<li><strong>通过代码块赋值（Instance Initializer Block）</strong>：<br>
使用实例初始化块对属性进行赋值。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">value</span>;
    {
        <span class="pl-s1">value</span> = <span class="pl-c1">20</span>; <span class="pl-c">// 实例初始化块赋值</span>
    }
}</pre></div>
<p>实例初始化块在构造器执行之前，按照它们在代码中出现的顺序执行。</p>
<ol start="4">
<li><strong>通过静态代码块赋值（Static Initializer Block）</strong>：<br>
使用静态初始化块对属性进行赋值。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">value</span>;
    <span class="pl-k">static</span> {
        <span class="pl-s1">value</span> = <span class="pl-c1">30</span>; <span class="pl-c">// 静态初始化块赋值</span>
    }
}</pre></div>
<p>静态初始化块在类被加载到JVM时执行，且仅执行一次。它先于任何对象的创建和实例初始化块执行。</p>
<ol start="5">
<li><strong>通过setter方法赋值（Setter Method）</strong>：<br>
通过公共的setter方法对属性进行赋值。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">value</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setValue</span>(<span class="pl-smi">int</span> <span class="pl-s1">value</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">value</span> = <span class="pl-s1">value</span>; <span class="pl-c">// 通过setter方法赋值</span>
    }
}</pre></div>
<p>setter方法赋值可以在对象创建后的任何时间点执行，具体取决于代码逻辑。</p>
<h3>赋值顺序总结：</h3>
<ol>
<li><strong>静态字段声明赋值</strong>：<code class="notranslate">static int value = 30;</code></li>
<li><strong>静态代码块</strong>：<code class="notranslate">static { value = 30; }</code></li>
<li><strong>字段声明赋值</strong>：<code class="notranslate">int value = 10;</code></li>
<li><strong>实例代码块</strong>：<code class="notranslate">{ value = 20; }</code></li>
<li><strong>构造器</strong>：在构造器中通过<code class="notranslate">this.value = value;</code>赋值</li>
<li><strong>setter方法</strong>：在对象创建后通过<code class="notranslate">setValue</code>方法赋值</li>
</ol>
<p>这个顺序展示了在Java中一个类的属性可能被赋值的不同阶段。静态初始化只在类加载时发生一次，而实例相关的赋值在每个对象创建时发生。setter方法则提供了一种灵活的途径，在对象的生命周期中随时可以改变属性值。</p>
<p>JavaBean是遵循特定编写规范的Java类，通常用于表示应用程序的数据。这个概念最早由Sun Microsystems公司提出，并成为了Java应用开发中一个广泛使用的组件技术。JavaBean可以是可视化组件，也可以是非可视化的，它们通常用于以下两个主要目的：</p>
<ol>
<li><strong>封装数据</strong>：JavaBean提供了一种封装数据和业务逻辑的方式，使得数据可以被不同部分的应用程序所使用。</li>
<li><strong>遵循标准</strong>：JavaBean遵循特定的命名和属性管理约定，使得它们可以被各种开发工具和应用程序框架识别和操作。</li>
</ol>
<h3>JavaBean的特点：</h3>
<ol>
<li><strong>可序列化</strong>：JavaBean通常是可序列化的，这意味着它们可以被转化为字节流，方便在网络上传输或存储到文件中。</li>
<li><strong>属性访问方法</strong>：JavaBean通过标准的getter和setter方法来访问私有属性。</li>
<li><strong>可选的构造器</strong>：除了默认的无参构造器外，JavaBean可以提供其他构造器来初始化对象。</li>
<li><strong>事件处理</strong>：可视化JavaBean可以有事件监听器和通知方法。</li>
<li><strong>可选的持久性</strong>：JavaBean可以实现<code class="notranslate">java.io.Externalizable</code>接口来自定义序列化行为。</li>
<li><strong>设计模式</strong>：JavaBean经常与设计模式如工厂模式、单例模式等结合使用。</li>
</ol>
<h3>JavaBean的规范：</h3>
<ul>
<li><strong>属性访问</strong>：属性通常通过<code class="notranslate">getPropertyName()</code>和<code class="notranslate">setPropertyName(value)</code>方法访问，其中<code class="notranslate">PropertyName</code>是属性名，首字母大写。</li>
<li><strong>布尔属性</strong>：对于布尔类型的属性，通常使用<code class="notranslate">isPropertyName()</code>作为getter方法，<code class="notranslate">setPropertyName(value)</code>作为setter方法。</li>
<li><strong>构造器</strong>：除了默认构造器外，可以提供带参数的构造器来初始化对象。</li>
<li><strong>序列化</strong>：实现<code class="notranslate">java.io.Serializable</code>接口，使得对象可以被序列化和反序列化。</li>
<li><strong>可选的标签</strong>：可以使用<code class="notranslate">java.beans</code>包中的类和接口来提供额外的功能，如属性更改事件和自定义器。</li>
</ul>
<h3>JavaBean的简单示例：</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">io</span>.<span class="pl-s1">Serializable</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UserBean</span> <span class="pl-k">implements</span> <span class="pl-smi">Serializable</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">// 默认构造器</span>
    <span class="pl-k">public</span> <span class="pl-smi">UserBean</span>() {
    }

    <span class="pl-c">// 带参数的构造器</span>
    <span class="pl-k">public</span> <span class="pl-smi">UserBean</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-c">// 标准的getter和setter方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">age</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAge</span>(<span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }
}</pre></div>
<p>在这个例子中，<code class="notranslate">UserBean</code>类有两个属性：<code class="notranslate">name</code>和<code class="notranslate">age</code>。它提供了标准的getter和setter方法来访问这些属性，并且实现了<code class="notranslate">Serializable</code>接口，使得<code class="notranslate">UserBean</code>对象可以被序列化。</p>
<p>JavaBean是Java EE规范的一部分，它们在Java应用开发中扮演着重要的角色，尤其是在MVC（模型-视图-控制器）架构中，JavaBean通常用作模型，负责存储数据和业务逻辑。</p>
<p>统一建模语言（Unified Modeling Language，UML）是一种标准的建模语言，用于软件工程中对软件系统的结构、行为和规则进行可视化。UML类图（Class Diagram）是UML中使用最广泛的一种图，用于展示系统的静态结构，即系统中的类、接口、枚举和它们之间的关系。</p>
<h3>UML类图的主要组成部分：</h3>
<ol>
<li><strong>类（Class）</strong>：
<ul>
<li>用矩形表示，矩形顶部提供类名，下方可以显示属性（attributes）和操作（operations）。</li>
</ul>
</li>
<li><strong>属性（Attributes）</strong>：
<ul>
<li>类的内部结构，包括数据字段和常量，通常显示在类名下方。</li>
</ul>
</li>
<li><strong>操作（Operations）</strong>：
<ul>
<li>类的行为，包括方法和构造函数，通常显示在属性下方。</li>
</ul>
</li>
<li><strong>关系（Relationships）</strong>：
<ul>
<li>类与类之间的连接，包括依赖（Dependency）、关联（Association）、聚合（Aggregation）和组合（Composition）。</li>
</ul>
</li>
<li><strong>接口（Interface）</strong>：
<ul>
<li>用一个带有曲线的矩形表示，内部可以包含操作签名。</li>
</ul>
</li>
<li><strong>泛化（Generalization）</strong>：
<ul>
<li>表示继承关系，用一个带有空心箭头的直线连接子类和父类。</li>
</ul>
</li>
<li><strong>实现（Realization）</strong>：
<ul>
<li>表示类实现了接口，用一个带有空心箭头的虚线连接类和接口。</li>
</ul>
</li>
<li><strong>依赖（Dependency）</strong>：
<ul>
<li>表示一个类的变化可能影响到另一个类，用一条带箭头的虚线表示。</li>
</ul>
</li>
<li><strong>关联（Association）</strong>：
<ul>
<li>表示两个类之间的结构关系，用一条实线表示。</li>
</ul>
</li>
<li><strong>聚合（Aggregation）</strong>：
<ul>
<li>表示整体与部分的关系，但部分可以独立于整体存在，用一条带有菱形的实线表示。</li>
</ul>
</li>
<li><strong>组合（Composition）</strong>：
<ul>
<li>表示整体与部分的关系，部分不能独立于整体存在，用一条带有实心菱形的实线表示。</li>
</ul>
</li>
</ol>
<h3>UML类图的表示方法：</h3>
<ul>
<li><strong>类名</strong>：
<ul>
<li>通常以大写字母开头，如<code class="notranslate">Classname</code>。</li>
</ul>
</li>
<li><strong>属性和操作</strong>：
<ul>
<li>属性通常以<code class="notranslate">-</code>（私有）或<code class="notranslate">+</code>（公共）开头，操作以<code class="notranslate">+</code>（公共）或<code class="notranslate">-</code>（私有）开头。</li>
<li>属性和操作可以有类型和名称，如<code class="notranslate">+visibility : Type</code>。</li>
</ul>
</li>
<li><strong>可见性</strong>：
<ul>
<li><code class="notranslate">+</code>表示公共（public）。</li>
<li><code class="notranslate">-</code>表示私有（private）。</li>
<li><code class="notranslate">#</code>表示受保护（protected）。</li>
<li><code class="notranslate">~</code>表示包级私有（package-private）。</li>
</ul>
</li>
</ul>
<h3>UML类图的作用：</h3>
<ol>
<li><strong>系统设计</strong>：
<ul>
<li>提供系统的静态视图，帮助开发者理解系统的结构。</li>
</ul>
</li>
<li><strong>文档化</strong>：
<ul>
<li>作为项目文档的一部分，供团队成员和利益相关者参考。</li>
</ul>
</li>
<li><strong>沟通工具</strong>：
<ul>
<li>帮助开发者和非技术人员之间就系统设计进行沟通。</li>
</ul>
</li>
<li><strong>分析和规划</strong>：
<ul>
<li>在软件开发的早期阶段，用于识别和规划系统的需求。</li>
</ul>
</li>
<li><strong>维护和扩展</strong>：
<ul>
<li>为现有系统的维护和扩展提供参考。</li>
</ul>
</li>
</ol>
<p>UML类图是一种强大的工具，可以帮助开发者以图形化的方式理解和设计复杂的系统结构。通过UML类图，开发者可以清晰地看到系统中的各个组件及其相互关系，这对于大型软件项目的成功至关重要。</p>
<h1>复习</h1>
<p>面向对象编程（OOP）是一种编程范式，它使用“对象”来设计应用程序，并将数据和方法封装在对象中。以下是面向对象编程中完成具体功能的操作的三步流程：</p>
<h3>步骤1: 创建类，并设计类的内部成员（属性，方法）</h3>
<p>在这一步中，你需要定义一个类，这个类将作为创建对象的蓝图。类的内部成员包括属性（也称为字段或变量）和方法（也称为函数或过程）。属性用于存储数据，而方法定义了对象可以执行的操作。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Phone</span> {
    <span class="pl-c">// 属性</span>
    <span class="pl-smi">String</span> <span class="pl-s1">brand</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">memory</span>;

    <span class="pl-c">// 方法</span>
    <span class="pl-smi">void</span> <span class="pl-en">call</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Making a call..."</span>);
    }

    <span class="pl-smi">void</span> <span class="pl-en">sendSMS</span>(<span class="pl-smi">String</span> <span class="pl-s1">message</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Sending SMS: "</span> + <span class="pl-s1">message</span>);
    }
}</pre></div>
<h3>步骤2: 创建类的对象</h3>
<p>一旦类被定义，下一步就是创建类的实例，也就是对象。在Java中，这是通过使用<code class="notranslate">new</code>关键字完成的。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Phone</span> <span class="pl-s1">phoneP1</span> = <span class="pl-k">new</span> <span class="pl-smi">Phone</span>();</pre></div>
<p>这行代码在堆内存中为<code class="notranslate">Phone</code>类的一个新对象分配空间，并返回一个指向该对象的引用。</p>
<h3>步骤3: 通过对象，调用其内部声明的属性或方法，完成相关的功能</h3>
<p>创建对象后，你可以通过对象引用来访问其属性和方法，从而执行操作。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-s1">phoneP1</span>.<span class="pl-s1">brand</span> = <span class="pl-s">"Moonshot"</span>;
<span class="pl-s1">phoneP1</span>.<span class="pl-s1">memory</span> = <span class="pl-c1">128</span>;
<span class="pl-s1">phoneP1</span>.<span class="pl-en">call</span>();
<span class="pl-s1">phoneP1</span>.<span class="pl-en">sendSMS</span>(<span class="pl-s">"Hello, World!"</span>);</pre></div>
<h3>对象的内存解析</h3>
<p>在Java中，对象的内存解析涉及到几个不同的内存区域：</p>
<ul>
<li><strong>虚拟机栈（VM Stack）</strong>：这是线程私有的内存区域，用于存储局部变量和部分结果，以及动态链接和方法出口等信息。每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li><strong>堆（Heap）</strong>：这是Java中最大的内存区域，也是垃圾收集器管理的主要区域。所有的对象实例和数组都是在这里分配的。</li>
<li><strong>方法区（Method Area）</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量等数据。</li>
<li><strong>程序计数器（Program Counter Register）</strong>：这块内存区域很小，用于存储指向下一条指令的地址，即字节码行号指示器。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈类似，但是用于支持本地方法的执行。</li>
</ul>
<p>通过这些内存区域的协同工作，Java程序能够创建对象、调用方法，并管理内存。</p>
<p>权限修饰符 返回值类型 方法名(形参列表){  方法体 }</p>
<p>在面向对象编程（OOP）中，方法声明是定义类中方法的过程，这些方法定义了对象可以执行的操作。方法声明包括以下几个关键部分：</p>
<ol>
<li><strong>访问修饰符</strong>：定义了方法的可见性，例如<code class="notranslate">public</code>、<code class="notranslate">private</code>、<code class="notranslate">protected</code>等。</li>
<li><strong>返回类型</strong>：方法执行后返回的数据类型。如果方法不返回任何值，则返回类型为<code class="notranslate">void</code>。</li>
<li><strong>方法名</strong>：方法的名称，它应该是描述性的，以便于理解方法的功能。</li>
<li><strong>参数列表</strong>：方法执行时需要的输入值，这些值在方法内部作为局部变量使用。参数列表包括参数类型和参数名，多个参数之间用逗号分隔。</li>
<li><strong>方法体</strong>：方法的具体实现，即方法执行时所执行的代码块。</li>
<li><strong>异常</strong>：方法可能抛出的异常列表。</li>
</ol>
<p>下面是一个Java中方法声明的示例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Calculator</span> {

    <span class="pl-c">// 计算两个整数的和</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">num1</span>, <span class="pl-smi">int</span> <span class="pl-s1">num2</span>) {
        <span class="pl-k">return</span> <span class="pl-s1">num1</span> + <span class="pl-s1">num2</span>;
    }

    <span class="pl-c">// 计算两个浮点数的差，可能抛出算术异常</span>
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">subtract</span>(<span class="pl-smi">double</span> <span class="pl-s1">num1</span>, <span class="pl-smi">double</span> <span class="pl-s1">num2</span>) <span class="pl-k">throws</span> <span class="pl-smi">ArithmeticException</span> {
        <span class="pl-k">return</span> <span class="pl-s1">num1</span> - <span class="pl-s1">num2</span>;
    }

    <span class="pl-c">// 显示欢迎信息，不返回任何值</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">displayWelcomeMessage</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Welcome to the Calculator Application!"</span>);
    }
}</pre></div>
<p>在这个例子中：</p>
<ul>
<li><code class="notranslate">public</code>是访问修饰符，表示这些方法可以被任何其他类访问。</li>
<li><code class="notranslate">int</code>、<code class="notranslate">double</code>和<code class="notranslate">void</code>是返回类型。</li>
<li><code class="notranslate">add</code>、<code class="notranslate">subtract</code>和<code class="notranslate">displayWelcomeMessage</code>是方法名。</li>
<li><code class="notranslate">(int num1, int num2)</code>、<code class="notranslate">(double num1, double num2)</code>是参数列表。</li>
<li>方法体包含了具体的执行代码。</li>
<li><code class="notranslate">throws ArithmeticException</code>表示<code class="notranslate">subtract</code>方法可能会抛出<code class="notranslate">ArithmeticException</code>异常。</li>
</ul>
<p>方法声明定义了方法的接口，即其他代码如何与方法交互，以及方法将执行什么操作。</p>
<p>调用方法时通过方法名与形参列表确定方法</p>
<p>方法重载（Method Overloading）是面向对象编程中的一个特性，它允许在同一个类中存在多个同名方法，只要这些方法的参数列表不同。参数列表不同可以是参数的类型不同、参数的数量不同，或者两者都不同。方法重载的主要目的是提供相同功能的多种版本，以适应不同的输入。</p>
<h3>方法重载的规则：</h3>
<ol>
<li><strong>方法名相同</strong>：重载的方法必须在同一个类中，并且方法名相同。</li>
<li><strong>参数列表不同</strong>：参数的数量、类型或顺序必须至少有一个不同。</li>
<li><strong>返回类型不相关</strong>：方法的返回类型不作为区分重载方法的因素。</li>
<li><strong>访问修饰符不相关</strong>：方法的访问修饰符（如<code class="notranslate">public</code>、<code class="notranslate">private</code>等）也不影响方法重载。</li>
</ol>
<h3>方法重载的例子：</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Example</span> {

    <span class="pl-c">// 方法重载示例：根据参数数量不同</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Display with no arguments"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>(<span class="pl-smi">int</span> <span class="pl-s1">number</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Display with one argument: "</span> + <span class="pl-s1">number</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Display with one argument: "</span> + <span class="pl-s1">str</span>);
    }

    <span class="pl-c">// 方法重载示例：根据参数类型不同</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>) {
        <span class="pl-k">return</span> <span class="pl-s1">a</span> + <span class="pl-s1">b</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">add</span>(<span class="pl-smi">double</span> <span class="pl-s1">a</span>, <span class="pl-smi">double</span> <span class="pl-s1">b</span>) {
        <span class="pl-k">return</span> <span class="pl-s1">a</span> + <span class="pl-s1">b</span>;
    }
}</pre></div>
<p>在这个例子中：</p>
<ul>
<li><code class="notranslate">display</code>方法被重载了三次，每次的参数列表都不同：无参数、一个<code class="notranslate">int</code>参数、一个<code class="notranslate">String</code>参数。</li>
<li><code class="notranslate">add</code>方法也被重载了两次，每次接受的参数类型不同：两个<code class="notranslate">int</code>参数和两个<code class="notranslate">double</code>参数。</li>
</ul>
<h3>方法重载的优点：</h3>
<ol>
<li><strong>提高代码的可读性</strong>：通过提供多个重载方法，可以使得代码更加直观和易于理解。</li>
<li><strong>增加代码的灵活性</strong>：开发者可以根据需要调用不同参数的重载方法，使得代码更加灵活。</li>
<li><strong>减少错误</strong>：通过明确区分不同参数的方法，可以减少调用错误的可能性。</li>
</ol>
<p>方法重载是面向对象编程中一个非常有用的功能，它使得方法调用更加灵活和直观。</p>
<p>对象数组是数组的一种，它用于存储对象的引用。在面向对象编程中，对象数组允许你创建一个可以包含多个对象的数组，这些对象通常是同一个类或者同一个类的子类的实例。对象数组的声明、创建和使用与基本数据类型的数组类似，但是它们存储的是对象引用而不是实际的数据值。</p>
<h3>声明对象数组</h3>
<p>对象数组的声明需要指定对象的类型。例如，如果你有一个名为<code class="notranslate">Car</code>的类，你可以这样声明一个<code class="notranslate">Car</code>类型的对象数组：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Car</span>[] <span class="pl-s1">carArray</span>;</pre></div>
<h3>创建对象数组</h3>
<p>创建对象数组与创建基本数据类型数组类似，但是你需要使用<code class="notranslate">new</code>关键字来指定数组的大小，并初始化数组：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-s1">carArray</span> = <span class="pl-k">new</span> <span class="pl-smi">Car</span>[<span class="pl-c1">3</span>]; <span class="pl-c">// 创建一个可以存储3个Car对象的数组</span></pre></div>
<h3>初始化对象数组</h3>
<p>对象数组的每个元素都是一个引用，你需要为每个元素分配一个实际的对象：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-s1">carArray</span>[<span class="pl-c1">0</span>] = <span class="pl-k">new</span> <span class="pl-smi">Car</span>();
<span class="pl-s1">carArray</span>[<span class="pl-c1">1</span>] = <span class="pl-k">new</span> <span class="pl-smi">Car</span>();
<span class="pl-s1">carArray</span>[<span class="pl-c1">2</span>] = <span class="pl-k">new</span> <span class="pl-smi">Car</span>();</pre></div>
<p>或者，你可以在声明和创建数组的同时进行初始化：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Car</span>[] <span class="pl-s1">carArray</span> = {
    <span class="pl-k">new</span> <span class="pl-smi">Car</span>(),
    <span class="pl-k">new</span> <span class="pl-smi">Car</span>(),
    <span class="pl-k">new</span> <span class="pl-smi">Car</span>()
};</pre></div>
<h3>使用对象数组</h3>
<p>一旦对象数组被初始化，你就可以像使用普通数组一样使用它，通过索引来访问和操作数组中的每个对象：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-s1">carArray</span>[<span class="pl-c1">0</span>].<span class="pl-en">startEngine</span>(); <span class="pl-c">// 调用第一个Car对象的startEngine方法</span>
<span class="pl-s1">carArray</span>[<span class="pl-c1">1</span>].<span class="pl-en">stopEngine</span>();  <span class="pl-c">// 调用第二个Car对象的stopEngine方法</span></pre></div>
<h3>对象数组的特点</h3>
<ol>
<li><strong>灵活性</strong>：对象数组可以存储任何与数组类型兼容的对象，包括继承自同一基类的子类对象。</li>
<li><strong>多态性</strong>：在对象数组中，可以利用多态性存储不同子类的对象，并调用它们共有的方法。</li>
<li><strong>动态大小</strong>：虽然数组的大小在创建时被固定，但是可以使用集合类（如<code class="notranslate">ArrayList</code>）来创建动态大小的对象数组。</li>
<li><strong>内存管理</strong>：对象数组存储的是对象的引用，而不是对象本身。对象本身存储在堆内存中，而数组存储的是指向这些对象的引用。</li>
</ol>
<p>对象数组是面向对象编程中处理多个对象时常用的数据结构，它提供了一种方便的方式来组织和管理对象集合。</p>
<p>Java 是一种强类型、面向对象的编程语言，它提供了一系列的关键字来支持其语言特性和功能。以下是一些常用的 Java 关键字：</p>
<ol>
<li><strong>访问控制关键字</strong>：
<ul>
<li><code class="notranslate">public</code>：声明公共的类、接口、方法和变量，可以被任何其他类访问。</li>
<li><code class="notranslate">protected</code>：声明受保护的成员，可以被同一包中的类以及所有子类访问。</li>
<li><code class="notranslate">private</code>：声明私有成员，只能被声明它的类访问。</li>
<li><code class="notranslate">default</code>（没有关键字）：当没有指定访问修饰符时，默认的访问级别，只能被同一包中的类访问。</li>
</ul>
</li>
<li><strong>非访问控制关键字</strong>：
<ul>
<li><code class="notranslate">abstract</code>：声明抽象类或抽象方法，没有具体实现。</li>
<li><code class="notranslate">final</code>：声明一个类、方法或变量不可被改变或覆盖。</li>
<li><code class="notranslate">static</code>：声明静态成员，属于类而不是类的实例。</li>
<li><code class="notranslate">transient</code>：声明一个字段在序列化时应被忽略。</li>
<li><code class="notranslate">volatile</code>：声明一个变量在多个线程间共享时，总是从主内存中读取。</li>
<li><code class="notranslate">synchronized</code>：用于同步方法或代码块，确保在同一时刻只有一个线程执行。</li>
<li><code class="notranslate">strictfp</code>：用于声明严格模式的浮点数计算。</li>
</ul>
</li>
<li><strong>程序控制关键字</strong>：
<ul>
<li><code class="notranslate">if</code>：条件语句，根据条件是否满足来执行不同的代码块。</li>
<li><code class="notranslate">else</code>：与<code class="notranslate">if</code>配合使用，表示条件不满足时执行的代码块。</li>
<li><code class="notranslate">switch</code>：多条件分支语句。</li>
<li><code class="notranslate">case</code>：与<code class="notranslate">switch</code>配合使用，表示一个分支条件。</li>
<li><code class="notranslate">default</code>：与<code class="notranslate">switch</code>配合使用，表示默认的分支条件。</li>
<li><code class="notranslate">for</code>：用于循环，适用于已知循环次数的情况。</li>
<li><code class="notranslate">while</code>：当条件满足时重复执行代码块。</li>
<li><code class="notranslate">do</code>：至少执行一次代码块，然后检查条件是否满足以决定是否继续循环。</li>
<li><code class="notranslate">break</code>：跳出最近的循环或<code class="notranslate">switch</code>语句。</li>
<li><code class="notranslate">continue</code>：跳过当前循环的剩余部分，开始下一次循环。</li>
</ul>
</li>
<li><strong>类和对象关键字</strong>：
<ul>
<li><code class="notranslate">class</code>：声明一个类。</li>
<li><code class="notranslate">interface</code>：声明一个接口。</li>
<li><code class="notranslate">extends</code>：表示一个类继承另一个类。</li>
<li><code class="notranslate">implements</code>：表示一个类实现了一个或多个接口。</li>
<li><code class="notranslate">this</code>：引用当前对象的上下文。</li>
<li><code class="notranslate">super</code>：引用父类的上下文或父类的构造方法。</li>
</ul>
</li>
<li><strong>异常处理关键字</strong>：
<ul>
<li><code class="notranslate">try</code>：开始一个异常处理块。</li>
<li><code class="notranslate">catch</code>：捕获并处理<code class="notranslate">try</code>块中抛出的异常。</li>
<li><code class="notranslate">finally</code>：无论是否捕获到异常，都会执行的代码块。</li>
<li><code class="notranslate">throw</code>：抛出一个异常。</li>
<li><code class="notranslate">throws</code>：声明一个方法可能抛出的异常。</li>
</ul>
</li>
<li><strong>其他关键字</strong>：
<ul>
<li><code class="notranslate">boolean</code>、<code class="notranslate">byte</code>、<code class="notranslate">char</code>、<code class="notranslate">short</code>、<code class="notranslate">int</code>、<code class="notranslate">long</code>、<code class="notranslate">float</code>、<code class="notranslate">double</code>：基本数据类型关键字。</li>
<li><code class="notranslate">void</code>：表示没有返回值的方法。</li>
<li><code class="notranslate">null</code>：表示没有值。</li>
<li><code class="notranslate">true</code>、<code class="notranslate">false</code>：布尔值。</li>
</ul>
</li>
<li><strong>类型转换关键字</strong>：
<ul>
<li><code class="notranslate">instanceof</code>：检查一个对象是否是特定类的实例。</li>
</ul>
</li>
</ol>
<p>这些关键字是 Java 语言的基础，它们使得 Java 能够实现面向对象编程、异常处理、程序控制等核心功能。</p>
<p>面试：java封装性的体系</p>
<blockquote>
<p>java规定了四种选线修饰符，分别是private，缺省，protected，public我们可以使用四种权限修饰符来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小</p>
</blockquote>
<blockquote>
<p>场景1:私有化(private)类的属性，提供公共(public)的get和set方法，对此属性进行获取或修改<br>
场景2:将类中不需要对外暴露的方法，设置为private.<br>
场景3:单例模式中构造器private的了，避免在类的外部创建实例。(放到static关键字后讲)</p>
</blockquote>
<p>理论:程序设计的原则之一</p>
<p>理论上</p>
<p>高内聚`:类的内部数据操作细节自己完成，不允许外部干涉;</p>
<p>（java程序通常以类的形态呈现，相关的功能封装到方法中。)</p>
<p>低耦合、:仅暴露少量的方法给外部使用，尽量方便外部调用。</p>
<p>(给相关的类、方法设置权限，把该隐藏的隐藏起来，该暴露的暴露出去)</p>
<p>类的成员之三:构造器</p>
<p>如何定义:权限修饰符 类名(形参列表){}</p>
<p>构造器的作用:① 搭配上new，用来创建对象 ② 初始化对象的成员变量</p>
<p>Java 的引用类型有哪几种(阿*校招)</p>
<p>类、数组、接口;枚举、注解、记录</p>
<p>面向对象，你解释一下，项目中哪些地方用到面向对象?(燕*金融)</p>
<p>“万事万物皆对象”</p>
<p>对象存在Java内存的哪块区域里面?</p>
<p>堆空间。</p>
<p>main方法的public能不能换成private?为什么?(凡<em>科技、顺</em>)</p>
<p>能。但是改以后就不能作为程序的入口了，就只是一个普通的方法。</p>
<p>构造方法和普通方法的区别(凡<em>科技、软</em>动力、中*软)</p>
<p>编写代码的角度:没有共同点。声明格式、作用都不同。</p>
<p>字节码文件的角度:构造器会以()方法 的形态呈现;</p>
<p>2.构造器Constructor是否可被(重载)overload?(鸿*网络)</p>
<p>可以。</p>
<p>成员变量与局部变量的区别(艾*软件)</p>
<p>6个点。</p>
<p>变量赋值和构造方法加载的优先级问题(凡<em>科技、博</em>软件)</p>
<p>变量显式赋值先于构造器中的赋值。</p>
<p>如何证明?我看的字节码文件。</p>
<h2>1. 关键字：this</h2>
<h3>1.1 this是什么？</h3>
<ul>
<li>在Java中，this关键字不算难理解，它的作用和其词义很接近。
<ul>
<li>它在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li>this可以调用的结构：成员变量、方法和构造器</li>
</ul>
<h3>1.2 什么时候使用this</h3>
<h4>1.2.1 实例方法或构造器中使用当前对象的成员</h4>
<p>在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。</p>
<p>但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分<code class="notranslate">成员变量</code>和<code class="notranslate">局部变量</code>。比如：</p>
<p>另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。</p>
<p>在Java中，<code class="notranslate">this</code>关键字是一个特殊的引用，指向当前对象的实例。它在类的方法和构造函数中使用，主要有以下几个用途：</p>
<ol>
<li><strong>区分实例变量和参数</strong>：<br>
当方法或构造函数的参数与实例变量同名时，可以使用<code class="notranslate">this</code>来区分它们。例如：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>; <span class="pl-c">// this.name指的是实例变量，name指的是参数</span>
    }
}</pre></div>
<ol start="2">
<li><strong>调用当前对象的方法</strong>：<br>
可以使用<code class="notranslate">this</code>来调用当前对象的其他方法。例如：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Calculator</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">this</span>.<span class="pl-en">sum</span>(<span class="pl-s1">a</span>, <span class="pl-s1">b</span>)); <span class="pl-c">// 调用当前对象的sum方法</span>
    }

    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-en">sum</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>) {
        <span class="pl-k">return</span> <span class="pl-s1">a</span> + <span class="pl-s1">b</span>;
    }
}</pre></div>
<ol start="3">
<li><strong>在构造函数中调用其他构造函数</strong>：<br>
可以使用<code class="notranslate">this()</code>来调用同一类中的其他构造函数，这种调用必须是构造函数的第一行。例如：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Rectangle</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">width</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">height</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Rectangle</span>() {
        <span class="pl-smi">this</span>(<span class="pl-c1">10</span>, <span class="pl-c1">20</span>); <span class="pl-c">// 调用带参数的构造函数</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">Rectangle</span>(<span class="pl-smi">int</span> <span class="pl-s1">width</span>, <span class="pl-smi">int</span> <span class="pl-s1">height</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">width</span> = <span class="pl-s1">width</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">height</span> = <span class="pl-s1">height</span>;
    }
}</pre></div>
<ol start="4">
<li><strong>返回当前对象</strong>：<br>
在某些方法中，可以返回当前对象的引用，通常用于方法链。例如：</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Builder</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">value</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Builder</span> <span class="pl-en">setValue</span>(<span class="pl-smi">String</span> <span class="pl-s1">value</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">value</span> = <span class="pl-s1">value</span>;
        <span class="pl-k">return</span> <span class="pl-smi">this</span>; <span class="pl-c">// 返回当前对象</span>
    }
}</pre></div>
<p>总结来说，<code class="notranslate">this</code>关键字在Java中用于引用当前对象的实例，帮助区分变量、调用方法、构造函数等，增强代码的可读性和可维护性。</p>
<p>this 可以调用的结构，成员方法，构造器</p>
<p>一般情况:我们通过对象a调用方法，可以在方法内调用当前对象a的属性或其他方法。此时，我们可以在属性和其他方法前</p>
<p>使用"this."，表示当前属性或方法所属的对象a。但是，一般情况下，我们都选择省略此"this."结构。</p>
<p>特殊情况:如果方法的形参与对象的属性同名了，我们必须使用"this."进行区分。使用this.修饰的变量即为属性(或成员变量)</p>
<p>没有使用this.修饰的变量，即为局部变量。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">// 无参数的构造函数</span>
    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-c">// 模拟对象创建时，需要初始化50行代码。</span>
        <span class="pl-c">// 这里只是示例，所以没有写出50行代码</span>
    }

    <span class="pl-c">// 带一个参数name的构造函数</span>
    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>(); <span class="pl-c">// 调用无参数的构造函数</span>
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>; <span class="pl-c">// 设置name属性</span>
    }

    <span class="pl-c">// 带两个参数name和age的构造函数</span>
    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>(<span class="pl-s1">name</span>); <span class="pl-c">// 调用带一个参数的构造函数</span>
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>; <span class="pl-c">// 设置age属性</span>
    }
}</pre></div>
<p>代码说明：</p>
<ol>
<li><strong>类定义</strong>：定义了一个名为<code class="notranslate">User</code>的类，包含两个私有属性<code class="notranslate">name</code>和<code class="notranslate">age</code>。</li>
<li><strong>无参数的构造函数</strong>：
<ul>
<li><code class="notranslate">public User()</code>：这是一个无参数的构造函数，用于创建<code class="notranslate">User</code>对象时初始化对象。</li>
<li>在这个构造函数中，可以执行一些初始化操作，比如设置默认值或者执行一些必要的初始化代码。这里的注释说明了这一点，但实际代码中并没有写出50行初始化代码。</li>
</ul>
</li>
<li><strong>带一个参数的构造函数</strong>：
<ul>
<li><code class="notranslate">public User(String name)</code>：这是一个带有一个参数<code class="notranslate">name</code>的构造函数。</li>
<li><code class="notranslate">this()</code>：在构造函数的第一行调用了无参数的构造函数，这样可以确保在设置<code class="notranslate">name</code>之前，对象的其他属性已经被初始化。</li>
<li><code class="notranslate">this.name = name;</code>：使用<code class="notranslate">this</code>关键字来区分参数<code class="notranslate">name</code>和实例变量<code class="notranslate">name</code>，将传入的参数值赋给实例变量<code class="notranslate">name</code>。</li>
</ul>
</li>
<li><strong>带两个参数的构造函数</strong>：
<ul>
<li><code class="notranslate">public User(String name, int age)</code>：这是一个带有两个参数<code class="notranslate">name</code>和<code class="notranslate">age</code>的构造函数。</li>
<li><code class="notranslate">this(name)</code>：在构造函数的第一行调用了带有一个参数的构造函数，这样可以确保在设置<code class="notranslate">age</code>之前，对象的其他属性（包括<code class="notranslate">name</code>）已经被初始化。</li>
<li><code class="notranslate">this.age = age;</code>：使用<code class="notranslate">this</code>关键字来区分参数<code class="notranslate">age</code>和实例变量<code class="notranslate">age</code>，将传入的参数值赋给实例变量<code class="notranslate">age</code>。</li>
</ul>
</li>
</ol>
<p>通过这种方式，<code class="notranslate">User</code>类提供了灵活的构造函数，可以根据需要创建具有不同属性值的<code class="notranslate">User</code>对象。</p>
<p>4.2 this调用构造器</p>
<p>格式:"this(形参列表)"</p>
<p>我们可以在类的构造器中，调用当前类中指定的其它构造器</p>
<p>要求:"this(形参列表)"必须声明在当前构造器的首行</p>
<p>结论:"this(形参列表)"在构造器中最多声明一个</p>
<p>如果一个类中声明了n个构造器，则最多有n-1个构造器可以声明有"this(形参列表)"的结构</p>
<h1>继承性</h1>
<p>代码层面:</p>
<blockquote>
<p>自上而下:定义了一个类A，在定义另一个类B时，发现类B的功能与类A相似，考虑类B继承于类A<br>
自下而上:定义了类B,C，0等，发现B、C、0有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取。<br>
封装到类A中，让类B、C、D继承于类A,同时，B、C、D中的相似的功能就可以刚除了。</p>
</blockquote>
<p>有了继承，子类就获取了父类的所有属性和方法</p>
<p>私有权限不能继承</p>
<p>Java是一种面向对象的编程语言，继承性是面向对象编程的核心概念之一。继承性允许我们创建一个类（称为子类或派生类）来继承另一个类（称为父类或基类）的属性和方法。以下是Java继承性的几个关键点：</p>
<ol>
<li><strong>代码重用</strong>：继承性使得代码重用变得简单。子类可以继承父类的属性和方法，从而避免重复编写相同的代码。</li>
<li><strong>层次结构</strong>：继承性允许创建类之间的层次结构。一个父类可以有多个子类，子类继承父类的特性，并可以添加自己的特性。</li>
<li><strong>多态性</strong>：继承性是多态性的基础。多态性允许我们用父类类型的引用来引用子类的对象，使得同一个方法调用可以有不同的行为。</li>
<li><strong>访问控制</strong>：在Java中，子类可以访问父类的公共（public）和受保护（protected）成员，但不能访问私有（private）成员。</li>
<li><strong>方法覆盖（Override）</strong>：子类可以覆盖父类的方法，即提供一个新的实现。这要求子类的方法签名必须与父类中被覆盖的方法完全相同。</li>
<li><strong>构造方法</strong>：子类不能继承父类的构造方法，但可以在其构造方法中通过<code class="notranslate">super()</code>调用父类的构造方法。</li>
<li><strong>super关键字</strong>：<code class="notranslate">super</code>关键字用于访问父类的属性和方法，也用于在子类的构造方法中调用父类的构造方法。</li>
<li><strong>final类和方法</strong>：如果一个类被声明为<code class="notranslate">final</code>，则不能被继承。如果一个方法被声明为<code class="notranslate">final</code>，则不能被覆盖。</li>
<li><strong>抽象类和接口</strong>：Java中的抽象类和接口也是继承性的一部分。抽象类可以包含抽象方法，这些方法没有实现，必须由子类实现。接口定义了一组方法规范，任何实现该接口的类都必须实现这些方法。</li>
<li><strong>继承的传递性</strong>：如果类B继承自类A，类C继承自类B，那么类C间接继承了类A的所有属性和方法。</li>
</ol>
<p>继承性是Java编程中的一个重要特性，它提供了一种机制，允许开发者在现有代码的基础上构建新的功能，同时保持代码的清晰和可维护性。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ExtendsTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Person</span> <span class="pl-s1">p1</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
       
        <span class="pl-s1">p1</span>.<span class="pl-en">eat</span>();
        <span class="pl-smi">student</span> <span class="pl-s1">s1</span> = <span class="pl-k">new</span> <span class="pl-smi">student</span>();
        <span class="pl-s1">s1</span>.<span class="pl-en">eat</span>();
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> <span class="pl-k">extends</span> <span class="pl-smi">student</span>{
    <span class="pl-c">//java继承性</span>

    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">// public void eat(){</span>
    <span class="pl-c">//     System.out.println("吃饭");</span>
    <span class="pl-c">// }</span>

    <span class="pl-c">// public void sleep(){</span>
    <span class="pl-c">//     System.out.println("睡觉");</span>
    <span class="pl-c">// }</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">study</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学习"</span>);
    }


}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">student</span> {
    
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c">//方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人吃饭"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人睡觉"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">study</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人学习"</span>);
    }

}</pre></div>
<p>4.有了继承性以后:</p>
<p>子类就获取到了父类中声明的所有的属性和方法。</p>
<p>但是，由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法</p>
<p>子类在继承父类以后，还可以扩展自己特有的功能(体现:增加特有的性、方法)</p>
<p>extends:延展、扩展、延伸</p>
<p>理解：子类和父类要区别于集合和子集</p>
<p>不要为了继承而继承，在继承前要判断是否存在 is a 的关系</p>
<p>语法示例  public class Student extends Person{ }</p>
<p>//超纲:获取s1所属类的父类</p>
<p>System.out.println(s1.getclass().getSuperclass());</p>
<p>//超纲:获取p1所属类的父类</p>
<p>System.out.println(p1.getclass().getSuperclass());</p>
<p>Java 中声明的类，如果没有显示声明其父类时，则默认继承于 java.lang.Object</p>
<p>java 继承时单继承 不支持继承多个父类（不能认义父）</p>
<p>其它：直接父类，间接父类</p>
<p>子父类的概念是相对的</p>
<p><strong>Java支持多层继承(继承体系)</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">C</span> <span class="pl-k">extends</span> <span class="pl-smi">B</span>{}</pre></div>
<blockquote>
<p>说明：</p>
<ul>
<li>子类和父类是一种相对的概念</li>
<li>顶层父类是Object类。所有的类默认继承Object，作为父类。</li>
</ul>
</blockquote>
<p><strong>一个父类可以同时拥有多个子类</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">D</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">E</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{}</pre></div>
<p><strong>Java只支持单继承，不支持多重继承</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">A</span>{}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{}

<span class="pl-c">//一个类只能有一个父类，不可以有多个直接父类。</span>
<span class="pl-k">class</span> <span class="pl-smi">C</span> <span class="pl-k">extends</span> <span class="pl-smi">B</span>{} 	<span class="pl-c">//ok</span>
<span class="pl-k">class</span> <span class="pl-s1">C</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>,<span class="pl-s1">B</span>...	<span class="pl-c">//error</span></pre></div>
<h3></h3>
<p>继承性 练习<strong>练习2：</strong></p>
<p>(1)定义一个ManKind类，包括</p>
<ul>
<li>成员变量int sex和int salary；</li>
<li>方法void manOrWoman()：根据sex的值显示“man”(sex1)或者“woman”(sex0)；</li>
<li>方法void employeed()：根据salary的值显示“no job”(salary==0)或者“ job”(salary!=0)。</li>
</ul>
<p>(2)定义类Kids继承ManKind，并包括</p>
<ul>
<li>成员变量int yearsOld；</li>
<li>方法printAge()打印yearsOld的值。</li>
</ul>
<p>(3)定义类KidsTest，在类的main方法中实例化Kids的对象someKid，用该对象访问其父类的成员变量及方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">KindTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">kinds</span> <span class="pl-s1">kid</span> = <span class="pl-k">new</span> <span class="pl-smi">kinds</span>();

        <span class="pl-s1">kid</span>.<span class="pl-en">setSalary</span>(<span class="pl-c1">100</span>);
        <span class="pl-s1">kid</span>.<span class="pl-en">setSex</span>(<span class="pl-c1">1</span>);
        <span class="pl-s1">kid</span>.<span class="pl-en">setYearOld</span>(<span class="pl-c1">12</span>);

        <span class="pl-s1">kid</span>.<span class="pl-en">printAge</span>();
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Mankind</span>{
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">sex</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">salary</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Mankind</span>() {

    }   


    <span class="pl-k">public</span> <span class="pl-smi">Mankind</span>(<span class="pl-smi">int</span> <span class="pl-s1">sex</span>,<span class="pl-smi">int</span> <span class="pl-s1">salary</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">sex</span>=<span class="pl-s1">sex</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">salary</span>=<span class="pl-s1">salary</span>;

    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getSex</span>(){
        <span class="pl-k">return</span> <span class="pl-s1">sex</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setSex</span>(<span class="pl-smi">int</span> <span class="pl-s1">sex</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">sex</span>=<span class="pl-s1">sex</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getSalary</span>(){
        <span class="pl-k">return</span> <span class="pl-s1">salary</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setSalary</span>(<span class="pl-smi">int</span> <span class="pl-s1">salary</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">salary</span>=<span class="pl-s1">salary</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">manWoman</span>(){
        <span class="pl-k">if</span>(<span class="pl-s1">sex</span>==<span class="pl-c1">1</span>){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Man"</span>);
        }<span class="pl-k">else</span>{
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Woman"</span>);
        }
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">employeed</span>() {
        <span class="pl-k">if</span>(<span class="pl-s1">salary</span>==<span class="pl-c1">0</span>){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"no job"</span>);
        }<span class="pl-k">else</span>{
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"job"</span>);
        }
    }


}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">kinds</span> <span class="pl-k">extends</span> <span class="pl-smi">Mankind</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">yearOld</span>;

    <span class="pl-k">public</span> <span class="pl-smi">kinds</span>(){

    }

    <span class="pl-k">public</span> <span class="pl-smi">kinds</span>(<span class="pl-smi">int</span> <span class="pl-s1">yearOld</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">yearOld</span> = <span class="pl-s1">yearOld</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setYearOld</span>(<span class="pl-smi">int</span> <span class="pl-s1">yearOld</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">yearOld</span> = <span class="pl-s1">yearOld</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setYearOld</span>(<span class="pl-smi">int</span> <span class="pl-s1">sex</span>,<span class="pl-smi">int</span> <span class="pl-s1">salary</span>, <span class="pl-smi">int</span> <span class="pl-s1">yearOld</span>) {
        <span class="pl-en">setSalary</span>(<span class="pl-s1">salary</span>);
        <span class="pl-en">setSex</span>(<span class="pl-s1">sex</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getYearOld</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">yearOld</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">printAge</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"I am "</span> + <span class="pl-s1">yearOld</span> + <span class="pl-s">" years old."</span>);
    }
    
}</pre></div>
<p>求原著的底面积 体积</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CylinderTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Cylinder</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Cylinder</span>();
        <span class="pl-s1">c</span>.<span class="pl-en">setRadius</span>(<span class="pl-c1">2</span>);
        <span class="pl-s1">c</span>.<span class="pl-en">setLength</span>(<span class="pl-c1">3.4</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"半径为"</span> + <span class="pl-s1">c</span>.<span class="pl-en">getRadius</span>() + <span class="pl-s">"，高为"</span> + <span class="pl-s1">c</span>.<span class="pl-en">getLength</span>() + <span class="pl-s">"的圆柱体体积为："</span> + <span class="pl-s1">c</span>.<span class="pl-en">getVolume</span>(<span class="pl-s1">c</span>.<span class="pl-en">getRadius</span>()));
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Cylinder</span> <span class="pl-k">extends</span> <span class="pl-smi">circle</span>{
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">length</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Cylinder</span>() {
        <span class="pl-s1">length</span> = <span class="pl-c1">1</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Cylinder</span>(<span class="pl-smi">double</span> <span class="pl-s1">length</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">length</span> = <span class="pl-s1">length</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">getLength</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">length</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setLength</span>(<span class="pl-smi">double</span> <span class="pl-s1">length</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">length</span> = <span class="pl-s1">length</span>;
    }

    <span class="pl-c">//求体积</span>
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">getVolume</span>(<span class="pl-smi">double</span> <span class="pl-s1">radius</span>) {
        <span class="pl-k">return</span> <span class="pl-smi">Math</span>.<span class="pl-c1">PI</span> * <span class="pl-en">getRadius</span>() * <span class="pl-en">getRadius</span>() * <span class="pl-en">getLength</span>();
    }

}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">circle</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">radius</span>; 

    <span class="pl-k">public</span> <span class="pl-smi">circle</span>() {
        <span class="pl-smi">this</span>.<span class="pl-s1">radius</span> = <span class="pl-c1">1</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">circle</span>(<span class="pl-smi">int</span> <span class="pl-s1">radius</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">radius</span> = <span class="pl-s1">radius</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getRadius</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">radius</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setRadius</span>(<span class="pl-smi">int</span> <span class="pl-s1">radius</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">radius</span> = <span class="pl-s1">radius</span>;
    }

    <span class="pl-c">//计算圆的面积</span>
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">getArea</span>() {
        <span class="pl-k">return</span> <span class="pl-smi">Math</span>.<span class="pl-c1">PI</span> * <span class="pl-en">getRadius</span>() * <span class="pl-en">getRadius</span>();
    }
    

    
}</pre></div>
<blockquote>
<p><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/OverRide/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/OverRide">@OverRide</a>使用说明：</p>
<p>写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。</p>
</blockquote>
<h3>3.2 方法重写的要求</h3>
<ol>
<li>子类重写的方法<code class="notranslate">必须</code>和父类被重写的方法具有相同的<code class="notranslate">方法名称</code>、<code class="notranslate">参数列表</code>。</li>
<li>子类重写的方法的返回值类型<code class="notranslate">不能大于</code>父类被重写的方法的返回值类型。（例如：Student &lt; Person）。</li>
</ol>
<blockquote>
<p>注意：如果返回值类型是基本数据类型和void，那么必须是相同</p>
</blockquote>
<ol start="3">
<li>子类重写的方法使用的访问权限<code class="notranslate">不能小于</code>父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）</li>
</ol>
<blockquote>
<p>注意：① 父类私有方法不能重写   ② 跨包的父类缺省的方法也不能重写</p>
</blockquote>
<ol start="4">
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<p>此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<h3>3.3 小结：方法的重载与重写</h3>
<p>方法的重载：方法名相同，形参列表不同。不看返回值类型。</p>
<p>方法的重写：见上面。</p>
<p>（1）同一个类中</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">inherited</span>.<span class="pl-s1">method</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestOverload</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">max</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>){
        <span class="pl-k">return</span> <span class="pl-s1">a</span> &gt; <span class="pl-s1">b</span> ? <span class="pl-s1">a</span> : <span class="pl-s1">b</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">max</span>(<span class="pl-smi">double</span> <span class="pl-s1">a</span>, <span class="pl-smi">double</span> <span class="pl-s1">b</span>){
        <span class="pl-k">return</span> <span class="pl-s1">a</span> &gt; <span class="pl-s1">b</span> ? <span class="pl-s1">a</span> : <span class="pl-s1">b</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">max</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>,<span class="pl-smi">int</span> <span class="pl-s1">c</span>){
        <span class="pl-k">return</span> <span class="pl-en">max</span>(<span class="pl-en">max</span>(<span class="pl-s1">a</span>,<span class="pl-s1">b</span>),<span class="pl-s1">c</span>);
    }
}</pre></div>
<p>（2）父子类中</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">inherited</span>.<span class="pl-s1">method</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestOverloadOverride</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Son</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>);<span class="pl-c">//只有一个形式的method方法</span>

        <span class="pl-smi">Daughter</span> <span class="pl-s1">d</span> = <span class="pl-k">new</span> <span class="pl-smi">Daughter</span>();
        <span class="pl-s1">d</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>);
        <span class="pl-s1">d</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>);<span class="pl-c">//有两个形式的method方法</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.method"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>){<span class="pl-c">//重写</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Son.method"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Daughter</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>,<span class="pl-smi">int</span> <span class="pl-s1">j</span>){<span class="pl-c">//重载</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Daughter.method"</span>);
    }
}</pre></div>
<p>为什么需要方法重写？</p>
<p>子类在继承父类后，就获取了父类中申明的所有方法。但是父类可能不太适用于子类。子类需要对父类继承过来的方法进行覆盖，覆写操作。</p>
<p>方法重写（Method Overriding）是面向对象编程（OOP）中的一个概念，它指的是在派生类（子类）中重新定义基类（父类）中已有的方法。这样做的目的通常是为了改变原有方法的行为，或者根据子类的具体需求来提供特定的实现。</p>
<p>以下是方法重写的关键点：</p>
<ol>
<li><strong>继承关系</strong>：重写发生在具有继承关系的类之间，即子类重写了父类的方法。</li>
<li><strong>方法签名</strong>：重写的方法必须具有与父类中被重写方法相同的方法签名，即相同的方法名和参数列表。</li>
<li><strong>访问级别</strong>：子类中重写的方法不能拥有比父类方法更严格的访问级别。</li>
<li><strong>返回类型</strong>：重写的方法返回类型必须与父类方法的返回类型相同或者更具体（协变返回类型）。</li>
<li><strong>异常</strong>：重写的方法可以抛出父类方法声明的所有异常，或者不抛出任何异常，但不能抛出更广泛的异常类型。</li>
<li><strong>多态性</strong>：方法重写是实现多态性的一种方式。多态性允许你通过父类的引用来调用子类的方法。</li>
<li><strong><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/OverRide/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/OverRide">@OverRide</a> 注解</strong>：在某些编程语言（如Java）中，可以使用<code class="notranslate">@Override</code>注解来明确指出一个方法是重写了父类的方法。如果方法没有正确重写父类的方法，编译器会报错。</li>
<li><strong>super关键字</strong>：在子类的方法中，可以使用<code class="notranslate">super</code>关键字来调用父类中被重写的方法。</li>
<li><strong>构造方法不能被重写</strong>：构造方法不能被重写，因为它们不参与多态性。</li>
<li><strong>静态方法和最终方法</strong>：静态方法和被声明为<code class="notranslate">final</code>的方法不能被重写。</li>
</ol>
<p>方法重写是面向对象编程中实现代码复用和扩展功能的重要机制，它允许开发者在不修改原有代码的情况下，通过扩展已有的类来增加新的行为。</p>
<p>子类不能重写父类 private 权限方法</p>
<h3>3.2 方法重写的要求</h3>
<ol>
<li>子类重写的方法<code class="notranslate">必须</code>和父类被重写的方法具有相同的<code class="notranslate">方法名称</code>、<code class="notranslate">参数列表</code>。</li>
<li>子类重写的方法的返回值类型<code class="notranslate">不能大于</code>父类被重写的方法的返回值类型。（例如：Student &lt; Person）。</li>
</ol>
<blockquote>
<p>注意：如果返回值类型是基本数据类型和void，那么必须是相同</p>
</blockquote>
<ol start="3">
<li>子类重写的方法使用的访问权限<code class="notranslate">不能小于</code>父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）</li>
</ol>
<blockquote>
<p>注意：① 父类私有方法不能重写   ② 跨包的父类缺省的方法也不能重写</p>
</blockquote>
<ol start="4">
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<p>此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<h3>3.3 小结：方法的重载与重写</h3>
<p>方法的重载：方法名相同，形参列表不同。不看返回值类型。</p>
<p>方法的重写：见上面。</p>
<p>（1）同一个类中</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">inherited</span>.<span class="pl-s1">method</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestOverload</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">max</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>){
        <span class="pl-k">return</span> <span class="pl-s1">a</span> &gt; <span class="pl-s1">b</span> ? <span class="pl-s1">a</span> : <span class="pl-s1">b</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">max</span>(<span class="pl-smi">double</span> <span class="pl-s1">a</span>, <span class="pl-smi">double</span> <span class="pl-s1">b</span>){
        <span class="pl-k">return</span> <span class="pl-s1">a</span> &gt; <span class="pl-s1">b</span> ? <span class="pl-s1">a</span> : <span class="pl-s1">b</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">max</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>,<span class="pl-smi">int</span> <span class="pl-s1">c</span>){
        <span class="pl-k">return</span> <span class="pl-en">max</span>(<span class="pl-en">max</span>(<span class="pl-s1">a</span>,<span class="pl-s1">b</span>),<span class="pl-s1">c</span>);
    }
}</pre></div>
<p>（2）父子类中</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">inherited</span>.<span class="pl-s1">method</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestOverloadOverride</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Son</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>);<span class="pl-c">//只有一个形式的method方法</span>

        <span class="pl-smi">Daughter</span> <span class="pl-s1">d</span> = <span class="pl-k">new</span> <span class="pl-smi">Daughter</span>();
        <span class="pl-s1">d</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>);
        <span class="pl-s1">d</span>.<span class="pl-en">method</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>);<span class="pl-c">//有两个形式的method方法</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.method"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>){<span class="pl-c">//重写</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Son.method"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Daughter</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span>,<span class="pl-smi">int</span> <span class="pl-s1">j</span>){<span class="pl-c">//重载</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Daughter.method"</span>);
    }
}</pre></div>
<h2>5. 关键字：super</h2>
<h3>5.1 super的理解</h3>
<p>在Java类中使用super来调用父类中的指定操作：</p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
<p>为什么需要 super？</p>
<p>子类继承父类以后，对父类方法进行了重写，那么在子类中，是否花裤对父类中被重写的类进行调用?（可以）</p>
<p>子类继承父类以后，发现子类和父类中定义了同名属性，是否可以区分子类中两个同名的属性？（可以）</p>
<p>使用 super 关键字即可做到</p>
<p>super 的理解： 父类的</p>
<h3>5.2 super的使用场景</h3>
<h4>5.2.1 子类中调用父类被重写的方法</h4>
<ul>
<li>如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；</li>
<li>如果子类重写了父类的方法，在子类中需要通过<code class="notranslate">super.</code>才能调用父类被重写的方法，否则默认调用的子类重写的方法</li>
</ul>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">inherited</span>.<span class="pl-s1">method</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Phone</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sendMessage</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"发短信"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">call</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"打电话"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">showNum</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"来电显示号码"</span>);
    }
}

<span class="pl-c">//smartphone：智能手机</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">SmartPhone</span> <span class="pl-k">extends</span> <span class="pl-smi">Phone</span>{
    <span class="pl-c">//重写父类的来电显示功能的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">showNum</span>(){
        <span class="pl-c">//来电显示姓名和图片功能</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"显示来电姓名"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"显示头像"</span>);

        <span class="pl-c">//保留父类来电显示号码的功能</span>
        <span class="pl-en">super</span>.<span class="pl-en">showNum</span>();<span class="pl-c">//此处必须加super.，否则就是无限递归，那么就会栈内存溢出</span>
    }
}</pre></div>
<p>总结：</p>
<ul>
<li><strong>方法前面没有super.和this.</strong>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><strong>方法前面有this.</strong>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><strong>方法前面有super.</strong>
<ul>
<li>从当前子类的直接父类找，如果没有，继续往上追溯</li>
</ul>
</li>
</ul>
<h4>5.2.2 子类中调用父类中同名的成员变量</h4>
<ul>
<li>如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别</li>
<li>如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量</li>
<li>如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问</li>
</ul>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Father</span>{
    <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">b</span> = <span class="pl-c1">11</span>;
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">20</span>;
    
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test</span>(){
        <span class="pl-c">//子类与父类的属性同名，子类对象中就有两个a</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"子类的a："</span> + <span class="pl-s1">a</span>);<span class="pl-c">//20  先找局部变量找，没有再从本类成员变量找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"子类的a："</span> + <span class="pl-smi">this</span>.<span class="pl-s1">a</span>);<span class="pl-c">//20   先从本类成员变量找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"父类的a："</span> + <span class="pl-en">super</span>.<span class="pl-s1">a</span>);<span class="pl-c">//10    直接从父类成员变量找</span>
        
        <span class="pl-c">//子类与父类的属性不同名，是同一个b</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-s1">b</span>);<span class="pl-c">//11  先找局部变量找，没有再从本类成员变量找，没有再从父类找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-smi">this</span>.<span class="pl-s1">b</span>);<span class="pl-c">//11   先从本类成员变量找，没有再从父类找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-en">super</span>.<span class="pl-s1">b</span>);<span class="pl-c">//11  直接从父类局部变量找</span>
    }
    
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span> <span class="pl-s1">b</span>){
        <span class="pl-c">//子类与父类的属性同名，子类对象中就有两个成员变量a，此时方法中还有一个局部变量a		</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"局部变量的a："</span> + <span class="pl-s1">a</span>);<span class="pl-c">//30  先找局部变量</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"子类的a："</span> + <span class="pl-smi">this</span>.<span class="pl-s1">a</span>);<span class="pl-c">//20  先从本类成员变量找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"父类的a："</span> + <span class="pl-en">super</span>.<span class="pl-s1">a</span>);<span class="pl-c">//10  直接从父类成员变量找</span>

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-s1">b</span>);<span class="pl-c">//13  先找局部变量</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-smi">this</span>.<span class="pl-s1">b</span>);<span class="pl-c">//11  先从本类成员变量找</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-en">super</span>.<span class="pl-s1">b</span>);<span class="pl-c">//11  直接从父类局部变量找</span>
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">Son</span> <span class="pl-s1">son</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">son</span>.<span class="pl-en">test</span>();
        <span class="pl-s1">son</span>.<span class="pl-en">method</span>(<span class="pl-c1">30</span>,<span class="pl-c1">13</span>);  
    }
}</pre></div>
<p>总结：起点不同（就近原则）</p>
<ul>
<li><strong>变量前面没有super.和this.</strong>
<ul>
<li>在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的<code class="notranslate">局部变量</code>，</li>
<li>如果不是局部变量，先从当前执行代码的<code class="notranslate">本类去找成员变量</code></li>
<li>如果从当前执行代码的本类中没有找到，会往上找<code class="notranslate">父类声明的成员变量</code>（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><strong>变量前面有this.</strong>
<ul>
<li>通过this找成员变量时，先从当前执行代码的本类去找成员变量</li>
<li>如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><strong>变量前面super.</strong>
<ul>
<li>通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）</li>
<li>如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
</ul>
<p><strong>特别说明：应该避免子类声明和父类重名的成员变量</strong></p>
<p>在阿里的开发规范等文档中都做出明确说明：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20211230110411580.png"><img src="images/image-20211230110411580.png" alt="" style="max-width: 100%;"></a></p>
<h4>5.2.3 子类构造器中调用父类构造器</h4>
<p>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。</p>
<p>② 规定：“super(形参列表)”，必须声明在构造器的首行。</p>
<p>③ 我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载的构造器，<br>
结合②，结论：在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。</p>
<p>④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，<br>
则子类此构造器默认调用"super()"，即调用父类中空参的构造器。</p>
<p>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>
只能是这两种情况之一。</p>
<p>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。</p>
<blockquote>
<p>开发中常见错误：</p>
<p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code class="notranslate">编译出错</code>。</p>
</blockquote>
<p>情景举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{

}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{

}

<span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类和B类都是默认有一个无参构造，B类的默认无参构造中还会默认调用A类的默认无参构造</span>
        <span class="pl-c">//但是因为都是默认的，没有打印语句，看不出来</span>
    }
}</pre></div>
<p>情景举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{

}
<span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类显示声明一个无参构造，</span>
        <span class="pl-c">//B类默认有一个无参构造，</span>
        <span class="pl-c">//B类的默认无参构造中会默认调用A类的无参构造</span>
        <span class="pl-c">//可以看到会输出“A类无参构造器"</span>
    }
}</pre></div>
<p>情景举例3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类显示声明一个无参构造，</span>
        <span class="pl-c">//B类显示声明一个无参构造，        </span>
        <span class="pl-c">//B类的无参构造中虽然没有写super()，但是仍然会默认调用A类的无参构造</span>
        <span class="pl-c">//可以看到会输出“A类无参构造器"和"B类无参构造器")</span>
    }
}</pre></div>
<p>情景举例4：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(){
        <span class="pl-en">super</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类显示声明一个无参构造，</span>
        <span class="pl-c">//B类显示声明一个无参构造，        </span>
        <span class="pl-c">//B类的无参构造中明确写了super()，表示调用A类的无参构造</span>
        <span class="pl-c">//可以看到会输出“A类无参构造器"和"B类无参构造器")</span>
    }
}</pre></div>
<p>情景举例5：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test05</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span>
        <span class="pl-c">//B类显示声明一个无参构造，        </span>
        <span class="pl-c">//B类的无参构造没有写super(...)，表示默认调用A类的无参构造</span>
        <span class="pl-c">//编译报错，因为A类没有无参构造</span>
    }
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20200227141228450.png"><img src="images/image-20200227141228450.png" alt="" style="max-width: 100%;"></a></p>
<p>情景举例6：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(){
        <span class="pl-en">super</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类无参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test06</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-c">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span>
        <span class="pl-c">//B类显示声明一个无参构造，        </span>
        <span class="pl-c">//B类的无参构造明确写super()，表示调用A类的无参构造</span>
        <span class="pl-c">//编译报错，因为A类没有无参构造</span>
    }
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20200303183542807.png"><img src="images/image-20200303183542807.png" alt="" style="max-width: 100%;"></a></p>
<p>情景举例7：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-en">super</span>(<span class="pl-s1">a</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test07</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>(<span class="pl-c1">10</span>);
        <span class="pl-c">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span>
        <span class="pl-c">//B类显示声明一个有参构造，        </span>
        <span class="pl-c">//B类的有参构造明确写super(a)，表示调用A类的有参构造</span>
        <span class="pl-c">//会打印“A类有参构造器"和"B类有参构造器"</span>
    }
}</pre></div>
<p>情景举例8：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">A</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类无参构造器"</span>);
    }
    <span class="pl-smi">A</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"A类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">B</span>(){
        <span class="pl-en">super</span>();<span class="pl-c">//可以省略，调用父类的无参构造</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类无参构造器"</span>);
    }
    <span class="pl-smi">B</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>){
        <span class="pl-en">super</span>(<span class="pl-s1">a</span>);<span class="pl-c">//调用父类有参构造</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"B类有参构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Test8</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">B</span> <span class="pl-s1">b1</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>();
        <span class="pl-smi">B</span> <span class="pl-s1">b2</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>(<span class="pl-c1">10</span>);
    }
}</pre></div>
<h3>5.3 小结：this与super</h3>
<p><strong>1、this和super的意义</strong></p>
<p>this：当前对象</p>
<ul>
<li>在构造器和非静态代码块中，表示正在new的对象</li>
<li>在实例方法中，表示调用当前方法的对象</li>
</ul>
<p>super：引用父类声明的成员</p>
<p><strong>2、this和super的使用格式</strong></p>
<ul>
<li>this
<ul>
<li>this.成员变量：表示当前对象的某个成员变量，而不是局部变量</li>
<li>this.成员方法：表示当前对象的某个成员方法，完全可以省略this.</li>
<li>this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错</li>
</ul>
</li>
<li>super
<ul>
<li>super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的</li>
<li>super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的</li>
<li>super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错</li>
</ul>
</li>
</ul>
<p>super 使用例子</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">Student</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();

        <span class="pl-s1">s</span>.<span class="pl-en">eat</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">sleep</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">study</span>();

        <span class="pl-s1">s</span>.<span class="pl-en">show</span>();

        
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Student</span> <span class="pl-k">extends</span> <span class="pl-smi">Person</span>{
    
    <span class="pl-smi">String</span> <span class="pl-s1">school</span>;
    <span class="pl-c">//方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生吃饭....."</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生睡觉..........."</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">study</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生认真学习"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-en">eat</span>();
        <span class="pl-c">//调用重写的方法</span>

        <span class="pl-smi">this</span>.<span class="pl-en">eat</span>();
        <span class="pl-c">//调用本类的方法</span>

        <span class="pl-en">super</span>.<span class="pl-en">eat</span>();
        <span class="pl-c">//调用父类的方法</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show1</span>(){
        <span class="pl-smi">this</span>.<span class="pl-en">doSport</span>();
        <span class="pl-en">super</span>.<span class="pl-en">doSport</span>();
    }

}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-c">//属性</span>

    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人吃饭"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人睡觉"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">doSport</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人运动"</span>);
    }
}</pre></div>
<p>不加 super 即省略 this</p>
<p>现在本地找，后在父类找</p>
<p>3.1 super调用属性、方法</p>
<p>子类继承父类以后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法。(满足封装性的前提下)</p>
<p>如何调用呢?需要使用"super."的结构，表示调用父类的属性或方法。</p>
<p>一般情况下，我们可以考虑省略"super."的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时</p>
<p>则必须使用"super."的声明，显式的调用父类被重写的方法或父类中声明的同名的属性。</p>
<p>Super 调用构造器</p>
<ol>
<li>子类继承父类时，不会继承父类的构造器。只能通过 "super(参数列表)" 的方式调用父类指定的构造器。</li>
<li>规定："super(参数列表)" 必须声明在构造器的首行。</li>
<li>我们前面讲过，在构造器的首行可以使用 "this(参数列表)"，调用本类中重载的构造器。</li>
<li>结合②和③，结论：在构造器的首行，"this(参数列表)" 和 "super(参数列表)" 只能二选一。</li>
<li>如果在子类构造器的首行既没有显示调用 "this(参数列表)"，也没有显式调用 "super(参数列表)"，则子类此构造器默认调用 "super()"，即调用父类中空参数的构造器。</li>
<li>由④和⑤得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器，只能是这两种情况之一。</li>
<li>由⑥得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了 "this(参数列表)"，则剩下的那个一定使用了 "super(参数列表)"。</li>
<li>我们在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接地调用到父类的构造器。</li>
<li>也正因为调用过父类的构造器，我们才会将父类中声明的属性或方法加载到内存中，供子类对象使用。</li>
</ol>
<p>以下是瞎写的代码</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">Student</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();

        <span class="pl-s1">s</span>.<span class="pl-en">eat</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">sleep</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">study</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>();

        <span class="pl-s1">s</span>.<span class="pl-en">show</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>();

        <span class="pl-smi">Student</span> <span class="pl-s1">s1</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();
        <span class="pl-s1">s1</span>.<span class="pl-en">show</span>();
        <span class="pl-c">//调用构造器</span>
        <span class="pl-smi">Student</span> <span class="pl-s1">s2</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>(<span class="pl-s">"张三"</span>, <span class="pl-c1">18</span>, <span class="pl-s">"男"</span>);
        <span class="pl-s1">s2</span>.<span class="pl-en">show</span>();




    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Student</span> <span class="pl-k">extends</span> <span class="pl-smi">Person</span>{
    
    <span class="pl-smi">String</span> <span class="pl-s1">school</span>;
    <span class="pl-c">//方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生吃饭....."</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生睡觉..........."</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">study</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生认真学习"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-en">eat</span>();
        <span class="pl-c">//调用重写的方法</span>

        <span class="pl-smi">this</span>.<span class="pl-en">eat</span>();
        <span class="pl-c">//调用本类的方法</span>

        <span class="pl-en">super</span>.<span class="pl-en">eat</span>();
        <span class="pl-c">//调用父类的方法</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show1</span>(){
        <span class="pl-smi">this</span>.<span class="pl-en">doSport</span>();
        <span class="pl-en">super</span>.<span class="pl-en">doSport</span>();
    }

    <span class="pl-c">//super调用父类构造器例子</span>
    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(){
        <span class="pl-en">super</span>(<span class="pl-s">"张三"</span>,<span class="pl-c1">18</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Student无参构造器"</span>);

    }
    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>,<span class="pl-smi">int</span> <span class="pl-s1">age</span>){
        <span class="pl-en">super</span>(<span class="pl-s1">name</span>,<span class="pl-s1">age</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Student有2参构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>,<span class="pl-smi">int</span> <span class="pl-s1">age</span>,<span class="pl-smi">String</span> <span class="pl-s1">school</span>){
        <span class="pl-en">super</span>(<span class="pl-s1">name</span>,<span class="pl-s1">age</span>);
        <span class="pl-smi">this</span>.<span class="pl-s1">school</span>=<span class="pl-s1">school</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Student有3参构造器"</span>);
    }


}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-c">//属性</span>

    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人吃饭"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人睡觉"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">doSport</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人运动"</span>);
    }

    <span class="pl-c">//子类调用父类构造器例子</span>
    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>,<span class="pl-smi">int</span> <span class="pl-s1">age</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"父类1"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(){
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-c1">18</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"父类2"</span>);
    }

}</pre></div>
<p>就近原则</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/29aecec4f28b836d95d2c72317f0553a35c18126da431c522e27831eca0dd5e5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733303531393237383737312d32313264353839612d386331392d343262612d386138362d3736386631366635313966622e706e67"><img src="https://camo.githubusercontent.com/29aecec4f28b836d95d2c72317f0553a35c18126da431c522e27831eca0dd5e5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733303531393237383737312d32313264353839612d386331392d343262612d386138362d3736386631366635313966622e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1730519278771-212d589a-8c19-42ba-8a86-768f16f519fb.png" style="max-width: 100%;"></a></p>
<p>子类的实例化过程涉及到对象的创建和初始化，这个过程遵循特定的顺序和规则。以下是子类实例化过程的详细步骤：</p>
<ol>
<li><strong>分配内存</strong>：<br>
在实例化对象之前，Java虚拟机（JVM）首先为新对象分配内存空间。</li>
<li><strong>执行父类的构造器</strong>：<br>
在子类的构造器执行之前，必须先执行父类的构造器。如果子类的构造器中没有显式地通过 <code class="notranslate">super</code> 调用父类的构造器，那么JVM会自动插入一个对父类无参构造器的调用（<code class="notranslate">super()</code>）。如果父类没有无参构造器，并且子类没有显式调用一个匹配的父类构造器，那么编译会失败。</li>
<li><strong>初始化父类的成员变量</strong>：<br>
父类的构造器会初始化父类的成员变量。</li>
<li><strong>执行子类的构造器</strong>：<br>
父类的构造器执行完毕后，开始执行子类的构造器。子类的构造器可以进一步初始化子类特有的成员变量，或者调用子类中重载的其他构造器（通过 <code class="notranslate">this</code> 关键字）。</li>
<li><strong>初始化子类的成员变量</strong>：<br>
在子类构造器的主体中，子类的成员变量会被初始化。</li>
<li><strong>执行构造代码块</strong>：<br>
如果有静态代码块（static blocks）和非静态代码块（instance initializers），它们会在成员变量初始化之后、构造器主体之前执行。</li>
<li><strong>执行构造器主体</strong>：<br>
最后，执行构造器主体中的代码。</li>
<li><strong>对象创建完成</strong>：<br>
一旦构造器执行完毕，对象就被认为是完全初始化了，可以被使用。</li>
</ol>
<p>以下是一个简单的Java代码示例，展示了子类实例化的过程：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Parent</span> {
    {
        <span class="pl-c">// 父类的非静态代码块</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Parent's instance initializer"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Parent</span>() {
        <span class="pl-c">// 父类的构造器</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Parent's constructor"</span>);
    }

    <span class="pl-k">static</span> {
        <span class="pl-c">// 父类的静态代码块</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Parent's static initializer"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Child</span> <span class="pl-k">extends</span> <span class="pl-smi">Parent</span> {
    {
        <span class="pl-c">// 子类的非静态代码块</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Child's instance initializer"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Child</span>() {
        <span class="pl-c">// 子类的构造器</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Child's constructor"</span>);
    }

    <span class="pl-k">static</span> {
        <span class="pl-c">// 子类的静态代码块</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Child's static initializer"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Memory allocation for Child object"</span>);
        <span class="pl-smi">Child</span> <span class="pl-s1">child</span> = <span class="pl-k">new</span> <span class="pl-smi">Child</span>();
    }
}</pre></div>
<p>当运行 <code class="notranslate">Main</code> 类的 <code class="notranslate">main</code> 方法时，以下是执行的顺序：</p>
<ol>
<li>输出 "Memory allocation for Child object"（在 <code class="notranslate">main</code> 方法中）。</li>
<li>输出 "Parent's static initializer"（父类的静态代码块）。</li>
<li>输出 "Child's static initializer"（子类的静态代码块）。</li>
<li>输出 "Parent's instance initializer"（父类的非静态代码块）。</li>
<li>输出 "Parent's constructor"（父类的构造器）。</li>
<li>输出 "Child's instance initializer"（子类的非静态代码块）。</li>
<li>输出 "Child's constructor"（子类的构造器）。</li>
</ol>
<p>这个顺序展示了从静态成员初始化到对象完全初始化的整个过程。</p>
<p>1，从结果的角度来看，显示为 类的继承性</p>
<p>当我们创建子类对象后，子类对象就获取了其父类中声明的所有的属性和方法，在权限允许的情况下，可以直接调用</p>
<p>2, 从过程的角度来看</p>
<p>当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接地调用其父类的构造器，而这个调用过程会一直向上追溯，直到调用了 <code class="notranslate">Object</code> 类中的构造器为止。同样地，子类的构造器也会直接或间接地调用其父类的父类的构造器，以此类推。正因为我们调用了子类所有的父类的构造器，所以我们会将这些父类中声明的属性和方法加载到内存中，供子类的对象使用。</p>
<h2>7. 面向对象特征三：多态性</h2>
<blockquote>
<p>一千个读者眼中有一千个哈姆雷特。</p>
</blockquote>
<h3>7.1 多态的形式和体现</h3>
<h4>7.1.1 对象的多态性</h4>
<p>多态性，是面向对象中最重要的概念，在Java中的体现：<strong>对象的多态性：父类的引用指向子类的对象</strong></p>
<p>格式：（父类类型：指子类继承的父类类型，或者实现的接口类型）</p>
<div class="highlight highlight-source-java"><pre class="notranslate">父类类型 变量名 = 子类对象；</pre></div>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">p</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();

<span class="pl-smi">Object</span> <span class="pl-s1">o</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();<span class="pl-c">//Object类型的变量o，指向Person类型的对象</span>

<span class="pl-s1">o</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>(); <span class="pl-c">//Object类型的变量o，指向Student类型的对象</span></pre></div>
<p>对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象</p>
<h4>7.1.2 多态的理解</h4>
<p>Java引用变量有两个类型：<code class="notranslate">编译时类型</code>和<code class="notranslate">运行时类型</code>。编译时类型由<code class="notranslate">声明</code>该变量时使用的类型决定，运行时类型由<code class="notranslate">实际赋给该变量的对象</code>决定。简称：<strong>编译 时，看左边；运行时，看右边。</strong></p>
<ul>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li>
<li>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）<br>
“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
<p>多态的使用前提：① 类的继承关系  ② 方法的重写</p>
<p>生活举例</p>
<blockquote>
<p>女朋友:我想养一个宠物。</p>
</blockquote>
<blockquote>
<p>孩子:我想要一个玩具。</p>
</blockquote>
<blockquote>
<p>老板:张秘书，安排一个技术科的同事，跟我一起下周出差。</p>
</blockquote>
<h4>7.1.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Pet</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">nickname</span>; <span class="pl-c">//昵称</span>

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getNickname</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">nickname</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setNickname</span>(<span class="pl-smi">String</span> <span class="pl-s1">nickname</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">nickname</span> = <span class="pl-s1">nickname</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">nickname</span> + <span class="pl-s">"吃东西"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Cat</span> <span class="pl-k">extends</span> <span class="pl-smi">Pet</span> {
    <span class="pl-c">//子类重写父类的方法</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"猫咪"</span> + <span class="pl-en">getNickname</span>() + <span class="pl-s">"吃鱼仔"</span>);
    }

    <span class="pl-c">//子类扩展的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">catchMouse</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"抓老鼠"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Dog</span> <span class="pl-k">extends</span> <span class="pl-smi">Pet</span> {
    <span class="pl-c">//子类重写父类的方法</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"狗子"</span> + <span class="pl-en">getNickname</span>() + <span class="pl-s">"啃骨头"</span>);
    }

    <span class="pl-c">//子类扩展的方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">watchHouse</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"看家"</span>);
    }
}</pre></div>
<p><strong>1、方法内局部变量的赋值体现多态</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestPet</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//多态引用</span>
        <span class="pl-smi">Pet</span> <span class="pl-s1">pet</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
        <span class="pl-s1">pet</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"小白"</span>);

        <span class="pl-c">//多态的表现形式</span>
        <span class="pl-c">/*</span>
<span class="pl-c">        编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法；</span>
<span class="pl-c">        运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体；</span>
<span class="pl-c">         */</span>
        <span class="pl-s1">pet</span>.<span class="pl-en">eat</span>();<span class="pl-c">//运行时执行子类Dog重写的方法</span>
<span class="pl-c">//      pet.watchHouse();//不能调用Dog子类扩展的方法</span>

        <span class="pl-s1">pet</span> = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>();
        <span class="pl-s1">pet</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"雪球"</span>);
        <span class="pl-s1">pet</span>.<span class="pl-en">eat</span>();<span class="pl-c">//运行时执行子类Cat重写的方法</span>
    }
}</pre></div>
<p><strong>2、方法的形参声明体现多态</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-k">private</span> <span class="pl-smi">Pet</span> <span class="pl-s1">pet</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">adopt</span>(<span class="pl-smi">Pet</span> <span class="pl-s1">pet</span>) {<span class="pl-c">//形参是父类类型，实参是子类对象</span>
        <span class="pl-smi">this</span>.<span class="pl-s1">pet</span> = <span class="pl-s1">pet</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">feed</span>(){
        <span class="pl-s1">pet</span>.<span class="pl-en">eat</span>();<span class="pl-c">//pet实际引用的对象类型不同，执行的eat方法也不同</span>
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestPerson</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Person</span> <span class="pl-s1">person</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();

        <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
        <span class="pl-s1">dog</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"小白"</span>);
        <span class="pl-s1">person</span>.<span class="pl-en">adopt</span>(<span class="pl-s1">dog</span>);<span class="pl-c">//实参是dog子类对象，形参是父类Pet类型</span>
        <span class="pl-s1">person</span>.<span class="pl-en">feed</span>();

        <span class="pl-smi">Cat</span> <span class="pl-s1">cat</span> = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>();
        <span class="pl-s1">cat</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"雪球"</span>);
        <span class="pl-s1">person</span>.<span class="pl-en">adopt</span>(<span class="pl-s1">cat</span>);<span class="pl-c">//实参是cat子类对象，形参是父类Pet类型</span>
        <span class="pl-s1">person</span>.<span class="pl-en">feed</span>();
    }
}</pre></div>
<p><strong>3、方法返回值类型体现多态</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">PetShop</span> {
    <span class="pl-c">//返回值类型是父类类型，实际返回的是子类对象</span>
    <span class="pl-k">public</span> <span class="pl-smi">Pet</span> <span class="pl-en">sale</span>(<span class="pl-smi">String</span> <span class="pl-s1">type</span>){
        <span class="pl-k">switch</span> (<span class="pl-s1">type</span>){
            <span class="pl-k">case</span> <span class="pl-s">"Dog"</span>:
                <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
            <span class="pl-k">case</span> <span class="pl-s">"Cat"</span>:
                <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Cat</span>();
        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestPetShop</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">PetShop</span> <span class="pl-s1">shop</span> = <span class="pl-k">new</span> <span class="pl-smi">PetShop</span>();

        <span class="pl-smi">Pet</span> <span class="pl-s1">dog</span> = <span class="pl-s1">shop</span>.<span class="pl-en">sale</span>(<span class="pl-s">"Dog"</span>);
        <span class="pl-s1">dog</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"小白"</span>);
        <span class="pl-s1">dog</span>.<span class="pl-en">eat</span>();

        <span class="pl-smi">Pet</span> <span class="pl-s1">cat</span> = <span class="pl-s1">shop</span>.<span class="pl-en">sale</span>(<span class="pl-s">"Cat"</span>);
        <span class="pl-s1">cat</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"雪球"</span>);
        <span class="pl-s1">cat</span>.<span class="pl-en">eat</span>();
    }
}</pre></div>
<h3>7.2 为什么需要多态性(polymorphism)？</h3>
<p>开发中，有时我们在设计一个数组、或一个成员变量、或一个方法的形参、返回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型。</p>
<p>案例：</p>
<p>（1）声明一个Dog类，包含public void eat()方法，输出“狗啃骨头”</p>
<p>（2）声明一个Cat类，包含public void eat()方法，输出“猫吃鱼仔”</p>
<p>（3）声明一个Person类，功能如下：</p>
<ul>
<li>包含宠物属性</li>
<li>包含领养宠物方法 public void adopt(宠物类型Pet)</li>
<li>包含喂宠物吃东西的方法 public void feed()，实现为调用宠物对象.eat()方法</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Dog</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"狗啃骨头"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Cat</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"猫吃鱼仔"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">private</span> <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span>;

    <span class="pl-c">//adopt：领养</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">adopt</span>(<span class="pl-smi">Dog</span> <span class="pl-s1">dog</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">dog</span> = <span class="pl-s1">dog</span>;
    }

    <span class="pl-c">//feed：喂食</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">feed</span>(){
        <span class="pl-k">if</span>(<span class="pl-s1">dog</span> != <span class="pl-c1">null</span>){
            <span class="pl-s1">dog</span>.<span class="pl-en">eat</span>();
        }
    }
    <span class="pl-c">/*</span>
<span class="pl-c">    问题：</span>
<span class="pl-c">    1、从养狗切换到养猫怎么办？   </span>
<span class="pl-c">        修改代码把Dog修改为养猫？</span>
<span class="pl-c">    2、或者有的人养狗，有的人养猫怎么办？  </span>
<span class="pl-c">    3、要是还有更多其他宠物类型怎么办？</span>
<span class="pl-c">    如果Java不支持多态，那么上面的问题将会非常麻烦，代码维护起来很难，扩展性很差。</span>
<span class="pl-c">    */</span>
}</pre></div>
<h3>7.3 多态的好处和弊端</h3>
<p><strong>好处</strong>：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。</p>
<p><strong>弊端</strong>：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Student</span> <span class="pl-s1">m</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();
<span class="pl-s1">m</span>.<span class="pl-s1">school</span> = <span class="pl-s">"pku"</span>; 	<span class="pl-c">//合法,Student类有school成员变量</span>
<span class="pl-smi">Person</span> <span class="pl-s1">e</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>(); 
<span class="pl-s1">e</span>.<span class="pl-s1">school</span> = <span class="pl-s">"pku"</span>;	<span class="pl-c">//非法,Person类没有school成员变量</span>

<span class="pl-c">// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</span></pre></div>
<blockquote>
<p>开发中：</p>
<p>使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。</p>
<p>【开闭原则OCP】</p>
<ul>
<li>对扩展开放，对修改关闭</li>
<li>通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能</li>
</ul>
</blockquote>
<h3>7.4 虚方法调用(Virtual Method Invocation)</h3>
<p>在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">e</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();
<span class="pl-s1">e</span>.<span class="pl-en">getInfo</span>();	<span class="pl-c">//调用Student类的getInfo()方法</span></pre></div>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<p>举例：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220324234208997.png"><img src="images/image-20220324234208997.png" alt="" style="max-width: 100%;"></a></p>
<p>前提：Person类中定义了welcome()方法，各个子类重写了welcome()。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220324234214932.png"><img src="images/image-20220324234214932.png" alt="" style="max-width: 100%;"></a></p>
<p>执行：多态的情况下，调用对象的welcome()方法，实际执行的是子类重写的方法。</p>
<blockquote>
<p>拓展：</p>
<p><code class="notranslate">静态链接（或早起绑定）</code>：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。</p>
<p><code class="notranslate">动态链接（或晚期绑定）</code>：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。</p>
</blockquote>
<h3>7.5 成员变量没有多态性</h3>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestVariable</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Base</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">Sub</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>.<span class="pl-s1">a</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(((<span class="pl-smi">Sub</span>)<span class="pl-s1">b</span>).<span class="pl-s1">a</span>);

        <span class="pl-smi">Sub</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Sub</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s</span>.<span class="pl-s1">a</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(((<span class="pl-smi">Base</span>)<span class="pl-s1">s</span>).<span class="pl-s1">a</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Base</span>{
    <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">1</span>;
}
<span class="pl-k">class</span> <span class="pl-smi">Sub</span> <span class="pl-k">extends</span> <span class="pl-smi">Base</span>{
    <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">2</span>;
}</pre></div>
<h3>7.6 向上转型与向下转型</h3>
<p>首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型用于不会变。但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。</p>
<h4>7.6.1 为什么要类型转换</h4>
<p>因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在<code class="notranslate">编译期间</code>，就会出现类型转换的现象。</p>
<p>但是，使用父类变量接收了子类对象之后，我们就<code class="notranslate">不能调用</code>子类拥有，而父类没有的方法了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做类型转换，使得<code class="notranslate">编译通过</code>。</p>
<ul>
<li><strong>向上转型</strong>：当左边的变量的类型（父类） &gt; 右边对象/变量的类型（子类），我们就称为向上转型
<ul>
<li>此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了</li>
<li>但是，<strong>运行时，仍然是对象本身的类型</strong>，所以执行的方法是子类重写的方法体。</li>
<li>此时，一定是安全的，而且也是自动完成的</li>
</ul>
</li>
<li><strong>向下转型</strong>：当左边的变量的类型（子类）&lt;右边对象/变量的编译时类型（父类），我们就称为向下转型
<ul>
<li>此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了</li>
<li>但是，<strong>运行时，仍然是对象本身的类型</strong></li>
<li>不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断</li>
</ul>
</li>
</ul>
<h4>7.6.2 如何向上或向下转型</h4>
<p>向上转型：自动完成</p>
<p>向下转型：（子类类型）父类变量</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ClassCastTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//没有类型转换</span>
        <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();<span class="pl-c">//dog的编译时类型和运行时类型都是Dog</span>

        <span class="pl-c">//向上转型</span>
        <span class="pl-smi">Pet</span> <span class="pl-s1">pet</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();<span class="pl-c">//pet的编译时类型是Pet，运行时类型是Dog</span>
        <span class="pl-s1">pet</span>.<span class="pl-en">setNickname</span>(<span class="pl-s">"小白"</span>);
        <span class="pl-s1">pet</span>.<span class="pl-en">eat</span>();<span class="pl-c">//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体</span>
<span class="pl-c">//        pet.watchHouse();//不能调用父类没有的方法watchHouse</span>

        <span class="pl-smi">Dog</span> <span class="pl-s1">d</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">pet</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"d.nickname = "</span> + <span class="pl-s1">d</span>.<span class="pl-en">getNickname</span>());
        <span class="pl-s1">d</span>.<span class="pl-en">eat</span>();<span class="pl-c">//可以调用eat方法</span>
        <span class="pl-s1">d</span>.<span class="pl-en">watchHouse</span>();<span class="pl-c">//可以调用子类扩展的方法watchHouse</span>

        <span class="pl-smi">Cat</span> <span class="pl-s1">c</span> = (<span class="pl-smi">Cat</span>) <span class="pl-s1">pet</span>;<span class="pl-c">//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确</span>
        <span class="pl-c">//这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的</span>
    }
}</pre></div>
<p>//多态性之前的场景:</p>
<p>Person p1=new Person();</p>
<p>Man m1= new Man();</p>
<p>//多态性:</p>
<p>Person p2 = new Man();</p>
<p>//声明人 new 了男人</p>
<p>子类的对象赋给父类的引用</p>
<p>多态性的应用:虚拟方法调用</p>
<p>在多态的场景下，调用方法时。</p>
<p>编译时，认为方法是左边声明的父类的类型的方法(即被重写的方法</p>
<p>执行式，实际执行的是子类重写父类的方法。</p>
<p>多态性前提</p>
<p>要有继承关系</p>
<p>要有方法的重写</p>
<p>多态性适用于方法不适用于属性</p>
<p>多态的弊端?</p>
<p>问题:Person p2=new Man();</p>
<p>针对于创建的对象，在内存中是否加载了Man类中声明的特有的属性和方法?加载了!</p>
<p>问题:能不能直接调用Man中加载的特有的属性和方法呢?不能</p>
<p>6.多态的好处与弊端</p>
<p>6.1 弊端:</p>
<p>在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明为父类的引用</p>
<p>导致我们没有办法直接调用子类特有的属性和方法。</p>
<p>6.2 好处:</p>
<p>极大的减少了代码的冗余，不需要定义多个重载的方法。</p>
<h4>向下转型例子</h4>
<p>多态性是面向对象编程的一个重要概念，它允许我们通过父类的引用来调用子类的对象。向下转型（Downcasting）是指将父类类型的引用转换为子类类型的引用。在Java中，向下转型之前通常需要进行类型检查，以确保转型是安全的。</p>
<p>以下是一个多态性向下转型的例子：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">makeSound</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Some generic animal sound"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Dog</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">makeSound</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Woof woof"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Animal</span> <span class="pl-s1">myAnimal</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>(); <span class="pl-c">// 向上转型，多态</span>
        <span class="pl-s1">myAnimal</span>.<span class="pl-en">makeSound</span>(); <span class="pl-c">// 输出 "Woof woof"</span>

        <span class="pl-c">// 向下转型</span>
        <span class="pl-k">if</span> (<span class="pl-s1">myAnimal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>) {
            <span class="pl-smi">Dog</span> <span class="pl-s1">myDog</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">myAnimal</span>;
            <span class="pl-s1">myDog</span>.<span class="pl-en">makeSound</span>(); <span class="pl-c">// 输出 "Woof woof"</span>
        }
    }
}</pre></div>
<p>在这个例子中：</p>
<ol>
<li><code class="notranslate">Dog</code> 类继承自 <code class="notranslate">Animal</code> 类。</li>
<li><code class="notranslate">Animal</code> 类有一个 <code class="notranslate">makeSound</code> 方法，而 <code class="notranslate">Dog</code> 类重写了这个方法。</li>
<li>在 <code class="notranslate">main</code> 方法中，我们创建了一个 <code class="notranslate">Dog</code> 类型的对象，但是将其赋值给了一个 <code class="notranslate">Animal</code> 类型的引用 <code class="notranslate">myAnimal</code>。这是向上转型，因为子类对象可以被看作是父类类型。</li>
<li>当我们调用 <code class="notranslate">myAnimal.makeSound()</code> 时，由于多态性，实际调用的是 <code class="notranslate">Dog</code> 类中的 <code class="notranslate">makeSound</code> 方法。</li>
<li>然后我们进行了类型检查 <code class="notranslate">if (myAnimal instanceof Dog)</code>，以确保 <code class="notranslate">myAnimal</code> 引用的对象实际上是 <code class="notranslate">Dog</code> 类型或其子类型的实例。</li>
<li>如果类型检查通过，我们将 <code class="notranslate">myAnimal</code> 向下转型为 <code class="notranslate">Dog</code> 类型，并调用 <code class="notranslate">Dog</code> 类的 <code class="notranslate">makeSound</code> 方法。</li>
</ol>
<p>注意：向下转型之前必须进行类型检查，因为如果转型不成功，会抛出 <code class="notranslate">ClassCastException</code> 异常。<code class="notranslate">instanceof</code> 操作符用于检查一个对象是否是特定类的实例，这在向下转型前是一个安全的做法。</p>
<p><code class="notranslate">instanceof</code> 是Java中的一个一元操作符，用于测试一个对象是否是一个特定类的实例，或者是否与特定类兼容。它返回一个布尔值：如果对象是指定类的实例或者是该类的子类的实例，则返回 <code class="notranslate">true</code>；否则返回 <code class="notranslate">false</code>。</p>
<p>以下是 <code class="notranslate">instanceof</code> 的一些使用细节和规则：</p>
<h3>基本用法</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">if</span> (<span class="pl-s1">object</span> <span class="pl-k">instanceof</span> <span class="pl-smi">ClassType</span>) {
    <span class="pl-c">// 如果object是ClassType或其子类的实例，则为true</span>
}</pre></div>
<ul>
<li><code class="notranslate">object</code> 是要检查的对象。</li>
<li><code class="notranslate">ClassType</code> 是要检查的类类型。</li>
</ul>
<h3>示例</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Animal</span> {}
<span class="pl-k">class</span> <span class="pl-smi">Dog</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {}

<span class="pl-smi">Animal</span> <span class="pl-s1">myAnimal</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
<span class="pl-smi">boolean</span> <span class="pl-s1">isDog</span> = <span class="pl-s1">myAnimal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>; <span class="pl-c">// 返回true</span></pre></div>
<p>在这个例子中，<code class="notranslate">myAnimal</code> 是 <code class="notranslate">Dog</code> 类的实例，<code class="notranslate">Dog</code> 是 <code class="notranslate">Animal</code> 类的子类，所以 <code class="notranslate">myAnimal</code> 也是 <code class="notranslate">Animal</code> 类的实例。因此，<code class="notranslate">myAnimal instanceof Dog</code> 返回 <code class="notranslate">true</code>。</p>
<h3>多态和向下转型</h3>
<p><code class="notranslate">instanceof</code> 经常与多态和向下转型一起使用。在多态的情况下，可能有一个父类的引用指向子类的对象，<code class="notranslate">instanceof</code> 可以用来检查这个引用是否指向特定的子类，以便于进行安全的向下转型。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">if</span> (<span class="pl-s1">myAnimal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>) {
    <span class="pl-smi">Dog</span> <span class="pl-s1">myDog</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">myAnimal</span>;
    <span class="pl-c">// 现在可以安全地将myAnimal向下转型为Dog类型，并调用Dog类的方法</span>
}</pre></div>
<h3>注意事项</h3>
<ul>
<li><code class="notranslate">instanceof</code> 只能检测到类的继承层次结构，它不能检测接口的实现情况。如果需要检查一个类是否实现了特定的接口，可以使用 <code class="notranslate">Class</code> 类的 <code class="notranslate">isAssignableFrom</code> 方法。</li>
<li><code class="notranslate">instanceof</code> 是在运行时检查的，所以它不会在编译时防止错误，而是在运行时提供类型安全。</li>
<li>如果 <code class="notranslate">object</code> 是 <code class="notranslate">null</code>，<code class="notranslate">object instanceof ClassType</code> 的结果是 <code class="notranslate">false</code>，这不会引发空指针异常。</li>
</ul>
<p><code class="notranslate">instanceof</code> 是Java中处理多态和类型检查时的一个非常有用的工具，它帮助开发者在运行时确定对象的实际类型，并根据需要进行适当的类型转换。</p>
<h4>7.6.3 instanceof关键字</h4>
<p>为了避免ClassCastException的发生，Java提供了 <code class="notranslate">instanceof</code> 关键字，给引用变量做类型的校验。如下代码格式：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//检验对象a是否是数据类型A的对象，返回值为boolean型</span>
对象<span class="pl-s1">a</span> <span class="pl-k">instanceof</span> 数据类型<span class="pl-smi">A</span> </pre></div>
<ul>
<li>说明：
<ul>
<li>只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。</li>
<li>如果对象a属于类A的子类B，a instanceof A值也为true。</li>
<li>要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">polymorphism</span>.<span class="pl-s1">grammar</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestInstanceof</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Pet</span>[] <span class="pl-s1">pets</span> = <span class="pl-k">new</span> <span class="pl-smi">Pet</span>[<span class="pl-c1">2</span>];
        <span class="pl-s1">pets</span>[<span class="pl-c1">0</span>] = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();<span class="pl-c">//多态引用</span>
        <span class="pl-s1">pets</span>[<span class="pl-c1">0</span>].<span class="pl-en">setNickname</span>(<span class="pl-s">"小白"</span>);
        <span class="pl-s1">pets</span>[<span class="pl-c1">1</span>] = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>();<span class="pl-c">//多态引用</span>
        <span class="pl-s1">pets</span>[<span class="pl-c1">1</span>].<span class="pl-en">setNickname</span>(<span class="pl-s">"雪球"</span>);

        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">pets</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-s1">pets</span>[<span class="pl-s1">i</span>].<span class="pl-en">eat</span>();

            <span class="pl-k">if</span>(<span class="pl-s1">pets</span>[<span class="pl-s1">i</span>] <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>){
                <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">pets</span>[<span class="pl-s1">i</span>];
                <span class="pl-s1">dog</span>.<span class="pl-en">watchHouse</span>();
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-s1">pets</span>[<span class="pl-s1">i</span>] <span class="pl-k">instanceof</span> <span class="pl-smi">Cat</span>){
                <span class="pl-smi">Cat</span> <span class="pl-s1">cat</span> = (<span class="pl-smi">Cat</span>) <span class="pl-s1">pets</span>[<span class="pl-s1">i</span>];
                <span class="pl-s1">cat</span>.<span class="pl-en">catchMouse</span>();
            }
        }
    }
}</pre></div>
<p>强行转换例子</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">makeSound</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Some generic animal sound"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Dog</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">watchDoor</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Dog is watching the door"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Cat</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">catchMouse</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Cat is catching a mouse"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Animal</span> <span class="pl-s1">animal</span>;

        <span class="pl-c">// 假设animal被赋值为Dog或Cat的对象</span>
        <span class="pl-s1">animal</span> = <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
        <span class="pl-k">if</span> (<span class="pl-s1">animal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>) {
            <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">animal</span>;
            <span class="pl-s1">dog</span>.<span class="pl-en">watchDoor</span>();
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-s1">animal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Cat</span>) {
            <span class="pl-smi">Cat</span> <span class="pl-s1">cat</span> = (<span class="pl-smi">Cat</span>) <span class="pl-s1">animal</span>;
            <span class="pl-s1">cat</span>.<span class="pl-en">catchMouse</span>();
        }

        <span class="pl-c">// 再次改变animal的类型</span>
        <span class="pl-s1">animal</span> = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>();
        <span class="pl-k">if</span> (<span class="pl-s1">animal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Dog</span>) {
            <span class="pl-smi">Dog</span> <span class="pl-s1">dog</span> = (<span class="pl-smi">Dog</span>) <span class="pl-s1">animal</span>;
            <span class="pl-s1">dog</span>.<span class="pl-en">watchDoor</span>();
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-s1">animal</span> <span class="pl-k">instanceof</span> <span class="pl-smi">Cat</span>) {
            <span class="pl-smi">Cat</span> <span class="pl-s1">cat</span> = (<span class="pl-smi">Cat</span>) <span class="pl-s1">animal</span>;
            <span class="pl-s1">cat</span>.<span class="pl-en">catchMouse</span>();
        }
    }
}</pre></div>
<p>在这个示例中：</p>
<ol>
<li><code class="notranslate">Animal</code> 是一个基类，<code class="notranslate">Dog</code> 和 <code class="notranslate">Cat</code> 是继承自 <code class="notranslate">Animal</code> 的子类。</li>
<li><code class="notranslate">Dog</code> 类有一个 <code class="notranslate">watchDoor</code> 方法，<code class="notranslate">Cat</code> 类有一个 <code class="notranslate">catchMouse</code> 方法。</li>
<li>在 <code class="notranslate">main</code> 方法中，我们有一个 <code class="notranslate">Animal</code> 类型的引用 <code class="notranslate">animal</code>。</li>
<li>我们使用 <code class="notranslate">instanceof</code> 操作符来检查 <code class="notranslate">animal</code> 是否是 <code class="notranslate">Dog</code> 或 <code class="notranslate">Cat</code> 的实例。</li>
<li>如果 <code class="notranslate">animal</code> 是 <code class="notranslate">Dog</code> 的实例，我们将其向下转型为 <code class="notranslate">Dog</code> 类型，并调用 <code class="notranslate">watchDoor</code> 方法。</li>
<li>如果 <code class="notranslate">animal</code> 不是 <code class="notranslate">Dog</code> 的实例，我们再检查它是否是 <code class="notranslate">Cat</code> 的实例，如果是，则将其向下转型为 <code class="notranslate">Cat</code> 类型，并调用 <code class="notranslate">catchMouse</code> 方法。</li>
</ol>
<p>这样，根据 <code class="notranslate">animal</code> 的实际类型，我们可以调用相应的方法。</p>
<h3>7.7 练习</h3>
<p><strong>练习1：笔试&amp;面试</strong></p>
<p>题目1：继承成员变量和继承方法的区别</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Base</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">count</span> = <span class="pl-c1">10</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">this</span>.<span class="pl-s1">count</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Sub</span> <span class="pl-k">extends</span> <span class="pl-smi">Base</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">count</span> = <span class="pl-c1">20</span>;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">display</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">this</span>.<span class="pl-s1">count</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">FieldMethodTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">Sub</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Sub</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s</span>.<span class="pl-s1">count</span>);
        <span class="pl-s1">s</span>.<span class="pl-en">display</span>();
        <span class="pl-smi">Base</span> <span class="pl-s1">b</span> = <span class="pl-s1">s</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span> == <span class="pl-s1">s</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>.<span class="pl-s1">count</span>);
        <span class="pl-s1">b</span>.<span class="pl-en">display</span>();
    }
}</pre></div>
<p>题目2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//考查多态的笔试题目：</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InterviewTest1</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Base</span> <span class="pl-s1">base</span> = <span class="pl-k">new</span> <span class="pl-smi">Sub</span>();
        <span class="pl-s1">base</span>.<span class="pl-en">add</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>);

<span class="pl-c">//		Sub s = (Sub)base;</span>
<span class="pl-c">//		s.add(1,2,3);</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Base</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span>... <span class="pl-s1">arr</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"base"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Sub</span> <span class="pl-k">extends</span> <span class="pl-smi">Base</span> {

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">add</span>(<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-smi">int</span>[] <span class="pl-s1">arr</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"sub_1"</span>);
    }

<span class="pl-c">//	public void add(int a, int b, int c) {</span>
<span class="pl-c">//		System.out.println("sub_2");</span>
<span class="pl-c">//	}</span>

}</pre></div>
<p>题目3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//getXxx()和setXxx()声明在哪个类中，内部操作的属性就是哪个类里的。</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InterviewTest2</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Father</span> <span class="pl-s1">f</span> = <span class="pl-k">new</span> <span class="pl-smi">Father</span>();
        <span class="pl-smi">Son</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">f</span>.<span class="pl-en">getInfo</span>());<span class="pl-c">//atguigu</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s</span>.<span class="pl-en">getInfo</span>());<span class="pl-c">//尚硅谷</span>
        <span class="pl-s1">s</span>.<span class="pl-en">test</span>();<span class="pl-c">//尚硅谷  atguigu</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"-----------------"</span>);
        <span class="pl-s1">s</span>.<span class="pl-en">setInfo</span>(<span class="pl-s">"大硅谷"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">f</span>.<span class="pl-en">getInfo</span>());<span class="pl-c">//atguigu</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s</span>.<span class="pl-en">getInfo</span>());<span class="pl-c">//大硅谷</span>
        <span class="pl-s1">s</span>.<span class="pl-en">test</span>();<span class="pl-c">//大硅谷  atguigu</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">info</span> = <span class="pl-s">"atguigu"</span>;

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setInfo</span>(<span class="pl-smi">String</span> <span class="pl-s1">info</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">info</span> = <span class="pl-s1">info</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">info</span>;
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">info</span> = <span class="pl-s">"尚硅谷"</span>;
    
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setInfo</span>(<span class="pl-smi">String</span> <span class="pl-s1">info</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">info</span> = <span class="pl-s1">info</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">info</span>;
    }
    
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">this</span>.<span class="pl-en">getInfo</span>());
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-en">super</span>.<span class="pl-en">getInfo</span>());
    }
}</pre></div>
<p>题目4：多态是编译时行为还是运行时行为？</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//证明如下：</span>
<span class="pl-k">class</span> <span class="pl-smi">Animal</span>  {
    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"animal eat food"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Cat</span>  <span class="pl-k">extends</span> <span class="pl-smi">Animal</span>  {
    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"cat eat fish"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Dog</span>  <span class="pl-k">extends</span> <span class="pl-smi">Animal</span>  {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Dog eat bone"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Sheep</span>  <span class="pl-k">extends</span> <span class="pl-smi">Animal</span>  {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Sheep eat grass"</span>);
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InterviewTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Animal</span>  <span class="pl-en">getInstance</span>(<span class="pl-smi">int</span> <span class="pl-s1">key</span>) {
        <span class="pl-k">switch</span> (<span class="pl-s1">key</span>) {
        <span class="pl-k">case</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Cat</span> ();
        <span class="pl-k">case</span> <span class="pl-c1">1</span>:
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Dog</span> ();
        <span class="pl-k">default</span>:
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Sheep</span> ();
        }

    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">int</span> <span class="pl-s1">key</span> = <span class="pl-k">new</span> <span class="pl-smi">Random</span>().<span class="pl-en">nextInt</span>(<span class="pl-c1">3</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">key</span>);

        <span class="pl-smi">Animal</span>  <span class="pl-s1">animal</span> = <span class="pl-en">getInstance</span>(<span class="pl-s1">key</span>);
        <span class="pl-s1">animal</span>.<span class="pl-en">eat</span>(); 
    }
}</pre></div>
<p><strong>练习2：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">protected</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>=<span class="pl-s">"person"</span>;
    <span class="pl-k">protected</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>=<span class="pl-c1">50</span>;
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>() {
              <span class="pl-k">return</span> <span class="pl-s">"Name: "</span>+ <span class="pl-s1">name</span> + <span class="pl-s">"<span class="pl-cce">\n</span>"</span> +<span class="pl-s">"age: "</span>+ <span class="pl-s1">age</span>;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Student</span> <span class="pl-k">extends</span> <span class="pl-smi">Person</span> {
    <span class="pl-k">protected</span> <span class="pl-smi">String</span> <span class="pl-s1">school</span>=<span class="pl-s">"pku"</span>;
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>() {
                <span class="pl-k">return</span>  <span class="pl-s">"Name: "</span>+ <span class="pl-s1">name</span> + <span class="pl-s">"<span class="pl-cce">\n</span>age: "</span>+ <span class="pl-s1">age</span> 
              + <span class="pl-s">"<span class="pl-cce">\n</span>school: "</span>+ <span class="pl-s1">school</span>;
    }	
}
<span class="pl-k">class</span> <span class="pl-smi">Graduate</span> <span class="pl-k">extends</span> <span class="pl-smi">Student</span>{
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">major</span>=<span class="pl-s">"IT"</span>;
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>()
    {
        <span class="pl-k">return</span>  <span class="pl-s">"Name: "</span>+ <span class="pl-s1">name</span> + <span class="pl-s">"<span class="pl-cce">\n</span>age: "</span>+ <span class="pl-s1">age</span> 
              + <span class="pl-s">"<span class="pl-cce">\n</span>school: "</span>+ <span class="pl-s1">school</span>+<span class="pl-s">"<span class="pl-cce">\n</span>major:"</span>+<span class="pl-s1">major</span>;
    }
}</pre></div>
<p>建立InstanceTest 类，在类中定义方法method(Person e);<br>
在method中:<br>
(1)根据e的类型调用相应类的getInfo()方法。<br>
(2)根据e的类型执行：<br>
如果e为Person类的对象，输出：<br>
“a person”;<br>
如果e为Student类的对象，输出：<br>
“a student”<br>
“a person ”<br>
如果e为Graduate类的对象，输出：<br>
“a graduated student”<br>
“a student”<br>
“a person”</p>
<p><strong>练习3</strong>：定义三个类，父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。定义一个测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等（注意方法的参数类型，利用动态绑定技术），编写displayGeometricObject方法显示对象的面积（注意方法的参数类型，利用动态绑定技术）。</p>
<h2>Object 类</h2>
<h4>默认的父类</h4>
<p>Java 中声明的类，如果没有显示的声明其父类时，则默认继承 java.lang.Object</p>
<p>任何一个Java类(除0bject类)都直接或间接的继承于0bject类</p>
<p>Object类称为java类的根父类</p>
<h4>Object类中声明的结构(属性、方法等)就具有通用性</h4>
<blockquote>
<p>0bject类中没有声明属性</p>
</blockquote>
<blockquote>
<p>0bject类提供了一个空参的构造器</p>
</blockquote>
<blockquote>
<p>重点关注:0bject类中声明的方法</p>
</blockquote>
<h4>方法</h4>
<p>重点方法 equals() toString()</p>
<p>了解方法 clone() finalsize()</p>
<p>目前不需要关注 getClass() hashCode()</p>
<p>notifyAll() wait() wait(xx) wait(xx,yy)</p>
<p>clone 复制的是内容不是地址，如果使用==判断结果为 false</p>
<p>其它：finalsize()调用时出现的划线表示为过时（JDK8 中可用，从 9 开始），不建议使用</p>
<h4>面试题 final finally finalize 的区别</h4>
<p>在Java编程语言中，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final&lt;/font&gt;</code>、<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finally&lt;/font&gt;</code>和<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finalize()&lt;/font&gt;</code>是三个完全不同的概念，它们各自有不同的用途和含义：</p>
<ol>
<li><strong>final关键字</strong>：
<ul>
<li><strong>变量</strong>：当用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final&lt;/font&gt;</code>修饰一个变量时，表示这个变量的值一旦被初始化后就不能被改变。例如，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final int number = 10;&lt;/font&gt;</code>，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;number&lt;/font&gt;</code>的值就不能被修改。</li>
<li><strong>方法</strong>：当用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final&lt;/font&gt;</code>修饰一个方法时，表示这个方法不能被子类重写。</li>
<li><strong>类</strong>：当用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final&lt;/font&gt;</code>修饰一个类时，表示这个类不能被继承。</li>
</ul>
</li>
<li><strong>finally块</strong>：
<ul>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finally&lt;/font&gt;</code>是Java异常处理结构的一部分，与<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;try&lt;/font&gt;</code>和<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;catch&lt;/font&gt;</code>一起使用。它是一个代码块，位于<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;try&lt;/font&gt;</code>和<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;catch&lt;/font&gt;</code>块之后，用于执行清理工作，比如关闭文件流、释放数据库连接等。无论是否发生异常，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finally&lt;/font&gt;</code>块中的代码都会被执行。</li>
</ul>
</li>
<li><strong>finalize()方法</strong>：
<ul>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finalize()&lt;/font&gt;</code>是一个在<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;java.lang.Object&lt;/font&gt;</code>类中定义的方法，Java虚拟机（JVM）在对象被垃圾回收之前调用这个方法。这个方法可以被子类重写，用于在对象被回收前执行一些清理工作。然而，由于垃圾回收机制的不确定性，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finalize()&lt;/font&gt;</code>方法的调用时机是不可预测的，因此它的使用并不推荐，更推荐使用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;try-with-resources&lt;/font&gt;</code>语句或自动资源管理来管理资源。</li>
</ul>
</li>
</ol>
<p>总结来说，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;final&lt;/font&gt;</code>用于声明不可变的对象、方法和类，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finally&lt;/font&gt;</code>用于异常处理中的资源清理，而<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;finalize()&lt;/font&gt;</code>是一个对象被垃圾回收前调用的方法，用于资源释放和清理工作。</p>
<h3>如何理解根父类</h3>
<p>类 <code class="notranslate">java.lang.Object</code>是类层次结构的根类，即所有其它类的父类。每个类都使用 <code class="notranslate">Object</code> 作为超类。</p>
<ul>
<li>Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-en">method</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>){…} <span class="pl-c">//可以接收任何类作为其参数</span>

<span class="pl-smi">Person</span> <span class="pl-s1">o</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();  
<span class="pl-en">method</span>(<span class="pl-s1">o</span>);</pre></div>
<ul>
<li>所有对象（包括数组）都实现这个类的方法。</li>
<li>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {
    ...
}
<span class="pl-c">//等价于：</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> <span class="pl-k">extends</span> <span class="pl-smi">Object</span> {
    ...
}</pre></div>
<h3>Object类的方法</h3>
<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个：</p>
<h4>1、(重点)equals()</h4>
<p>equals 的适用性：任何引用类型都能使用</p>
<p><strong>equals 重写的例子</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UserTest</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">User</span> <span class="pl-s1">user</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"adouzi"</span>, <span class="pl-c1">18</span>);
        <span class="pl-smi">User</span> <span class="pl-s1">user2</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"adouzi"</span>, <span class="pl-c1">18</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">user</span>.<span class="pl-en">equals</span>(<span class="pl-s1">user2</span>));
        <span class="pl-c">// 输出结果为false</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * public boolean equals(Object obj) {</span>
<span class="pl-c">         * return (this == obj);</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         */</span>

        <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">str2</span>));
        <span class="pl-c">// 输出结果为true</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * public boolean equals(Object anObject) {</span>
<span class="pl-c">         * if (this == anObject) {</span>
<span class="pl-c">         * return true;</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         * return (anObject instanceof String aString)</span>
<span class="pl-c">         * &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)</span>
<span class="pl-c">         * &amp;&amp; StringLatin1.equals(value, aString.value);</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         */</span>

    }
}

<span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

}</pre></div>
<p><strong>我们使用 ctrl 键来看看 java.lang.Object 类中 equals()的定义</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-s1">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>) {
        <span class="pl-k">return</span> (<span class="pl-smi">this</span> == <span class="pl-s1">obj</span>);
}</pre></div>
<p><code class="notranslate">&lt;font style="color:rgb(6, 6, 7);"&gt;this == obj&lt;/font&gt;</code>是一个比较操作，它检查当前对象的内存地址是否与传入参数对象的内存地址相同。如果相同，意味着它们是同一个对象，因此返回<code class="notranslate">&lt;font style="color:rgb(6, 6, 7);"&gt;true&lt;/font&gt;</code>；如果不同，意味着它们是不同的对象，因此返回<code class="notranslate">&lt;font style="color:rgb(6, 6, 7);"&gt;false&lt;/font&gt;</code>。</p>
<p></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);
<span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">str2</span>));
         <span class="pl-c">//输出结果为true</span></pre></div>
<p></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-s1">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">anObject</span>) {
        <span class="pl-k">if</span> (<span class="pl-smi">this</span> == <span class="pl-s1">anObject</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> (<span class="pl-s1">anObject</span> <span class="pl-k">instanceof</span> <span class="pl-smi">String</span> <span class="pl-s1">aString</span>)
                &amp;&amp; (!<span class="pl-c1">COMPACT_STRINGS</span> || <span class="pl-smi">this</span>.<span class="pl-s1">coder</span> == <span class="pl-s1">aString</span>.<span class="pl-s1">coder</span>)
                &amp;&amp; <span class="pl-smi">StringLatin1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">value</span>, <span class="pl-s1">aString</span>.<span class="pl-s1">value</span>);
    }</pre></div>
<p>子类使用说明:</p>
<p>自定义的类在没有重写0bject中equals()方法的情况下，调用的就是0bject类中声明的equals()，比较两个对象的引用地址是否相同。(或比较两个对象是否指向了堆空间中的同一个对象实体)</p>
<p>对于像String、File、Date和包装类等，它们都重写了0bject类中的equals()方法，用于比较两个对象的实体内容是否相等。</p>
<p>重写 equals</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//重写equals方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-s1">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>) {
        <span class="pl-k">if</span> (<span class="pl-smi">this</span> == <span class="pl-s1">obj</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">if</span> (<span class="pl-s1">obj</span> <span class="pl-k">instanceof</span> <span class="pl-smi">User</span>) {
            <span class="pl-smi">User</span> <span class="pl-s1">user</span> = (<span class="pl-smi">User</span>) <span class="pl-s1">obj</span>;
            <span class="pl-k">return</span> <span class="pl-smi">this</span>.<span class="pl-s1">name</span>.<span class="pl-en">equals</span>(<span class="pl-s1">user</span>.<span class="pl-s1">name</span>);
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        
    }</pre></div>
<p>示例代码：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UserTest</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">User</span> <span class="pl-s1">user</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"adouzi"</span>, <span class="pl-c1">18</span>);
        <span class="pl-smi">User</span> <span class="pl-s1">user2</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"adouzi"</span>, <span class="pl-c1">18</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">user</span>.<span class="pl-en">equals</span>(<span class="pl-s1">user2</span>));
        <span class="pl-c">// 输出结果为false</span>
        <span class="pl-c">//重写后输出结果为true</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * public boolean equals(Object obj) {</span>
<span class="pl-c">         * return (this == obj);</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         */</span>

        <span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"adouzi"</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">str2</span>));
        <span class="pl-c">// 输出结果为true</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * public boolean equals(Object anObject) {</span>
<span class="pl-c">         * if (this == anObject) {</span>
<span class="pl-c">         * return true;</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         * return (anObject instanceof String aString)</span>
<span class="pl-c">         * &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)</span>
<span class="pl-c">         * &amp;&amp; StringLatin1.equals(value, aString.value);</span>
<span class="pl-c">         * }</span>
<span class="pl-c">         */</span>

    }
}

<span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-c">//重写equals方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-en">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>) {
        <span class="pl-k">if</span> (<span class="pl-smi">this</span> == <span class="pl-s1">obj</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">if</span> (<span class="pl-s1">obj</span> <span class="pl-k">instanceof</span> <span class="pl-smi">User</span>) {
            <span class="pl-smi">User</span> <span class="pl-s1">user</span> = (<span class="pl-smi">User</span>) <span class="pl-s1">obj</span>;
            <span class="pl-k">return</span> <span class="pl-smi">this</span>.<span class="pl-s1">name</span>.<span class="pl-en">equals</span>(<span class="pl-s1">user</span>.<span class="pl-s1">name</span>);
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        
    }

}</pre></div>
<p>输出为</p>
<blockquote>
<p>true</p>
<p>true</p>
</blockquote>
<p>在 idea 中能自动重写，使用 alt insert</p>
<p>开发中使用说明</p>
<p>在实际开发中，针对于自定义的类，常常会判断两个对象是否 equals() 而此时主要是判断两个对象的属性是否相等</p>
<p>所以我们要重写 equals()方法（推荐使用 idea 自动生成 手动实现比较麻烦）</p>
<p><strong>面试 区分== 和 equals()</strong></p>
<p>在Java中，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code> 和 <code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 是两个用于比较对象的运算符和方法，但它们在比较对象时的行为和用途有所不同：</p>
<ol>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code>（双等号）：
<ul>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code> 是一个运算符，用于比较两个引用是否指向同一个对象（即它们是否具有相同的内存地址）。</li>
<li>对于基本数据类型（如int、double等），<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code> 比较的是值是否相等。</li>
<li>对于对象引用，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code> 比较的是两个引用是否指向堆内存中的同一个对象实例。</li>
<li>示例：</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"Hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"Hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"Hello"</span>);

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s2</span>); <span class="pl-c">// true，因为s1和s2指向JVM字符串常量池中的同一个对象</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span> == <span class="pl-s1">s3</span>); <span class="pl-c">// false，因为s1指向字符串常量池中的对象，而s3指向堆中的新对象</span></pre></div>
<ol start="2">
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 方法：
<ul>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 是一个方法，定义在<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;Object&lt;/font&gt;</code>类中，用于比较对象的内容是否相等。</li>
<li>默认情况下，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 方法的行为与<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code>相同，即比较对象的内存地址。</li>
<li>但是，<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 方法可以被重写，以提供更复杂的比较逻辑，比如比较对象的属性值是否相等。</li>
<li>对于字符串（<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;String&lt;/font&gt;</code>类）和其他一些类（如<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;Integer&lt;/font&gt;</code>、<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;Double&lt;/font&gt;</code>等），<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 方法已经被重写，以比较对象的内容。</li>
<li>示例：</li>
</ul>
</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">String</span> <span class="pl-s1">s1</span> = <span class="pl-s">"Hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s2</span> = <span class="pl-s">"Hello"</span>;
<span class="pl-smi">String</span> <span class="pl-s1">s3</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"Hello"</span>);

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">s2</span>)); <span class="pl-c">// true，因为equals()比较的是字符串的内容</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">s3</span>)); <span class="pl-c">// true，因为equals()比较的是字符串的内容</span></pre></div>
<p>区分<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code>和<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code>的关键点在于：</p>
<ul>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code> 比较的是对象的引用是否相同，即是否指向内存中的同一个位置。</li>
<li><code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code> 默认比较的是对象的引用，但可以被重写来比较对象的属性或状态是否相等。</li>
</ul>
<p>因此，当你需要比较两个对象是否逻辑上相等（即它们的属性值是否相同），你应该使用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;equals()&lt;/font&gt;</code>方法。而当你需要检查两个引用是否指向同一个对象时，你应该使用<code class="notranslate">&lt;font style="background-color:#FCE75A;"&gt;==&lt;/font&gt;</code>运算符。</p>
<p><strong>= =：</strong></p>
<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-s1">a</span>=<span class="pl-c1">5</span>; 
<span class="pl-k">if</span>(<span class="pl-s1">a</span>==<span class="pl-c1">6</span>){…}</pre></div>
<ul>
<li>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Person</span> <span class="pl-s1">p1</span>=<span class="pl-k">new</span> <span class="pl-smi">Person</span>();  	    
<span class="pl-smi">Person</span> <span class="pl-s1">p2</span>=<span class="pl-k">new</span> <span class="pl-smi">Person</span>();
<span class="pl-k">if</span> (<span class="pl-s1">p1</span>==<span class="pl-s1">p2</span>){…}</pre></div>
<pre class="notranslate"><code class="notranslate">- 用“==”进行比较时，符号两边的`数据类型必须兼容`(可自动转换的基本数据类型除外)，否则编译出错
</code></pre>
<p>**equals()：**所有类都继承了Object，也就获得了equals()方法。还可以重写。</p>
<ul>
<li>只能比较引用类型，Object类源码中equals()的作用与“==”相同：比较是否指向同一个对象。</li>
<li>格式:obj1.equals(obj2)</li>
<li>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；
<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
</li>
<li>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</li>
<li>重写equals()方法的原则
<ul>
<li><code class="notranslate">对称性</code>：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li>
<li><code class="notranslate">自反性</code>：x.equals(x)必须返回是“true”。</li>
<li><code class="notranslate">传递性</code>：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</li>
<li><code class="notranslate">一致性</code>：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</li>
<li>任何情况下，x.equals(null)，永远返回是“false”；    x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
</li>
<li>重写举例：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">User</span>{
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">host</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;
    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">host</span>, <span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-en">super</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">host</span> = <span class="pl-s1">host</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-en">super</span>();
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getHost</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">host</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setHost</span>(<span class="pl-smi">String</span> <span class="pl-s1">host</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">host</span> = <span class="pl-s1">host</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"User [host="</span> + <span class="pl-s1">host</span> + <span class="pl-s">", username="</span> + <span class="pl-s1">username</span> + <span class="pl-s">", password="</span> + <span class="pl-s1">password</span> + <span class="pl-s">"]"</span>;
    }
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-en">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>) {
        <span class="pl-k">if</span> (<span class="pl-smi">this</span> == <span class="pl-s1">obj</span>)
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">if</span> (<span class="pl-s1">obj</span> == <span class="pl-c1">null</span>)
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">if</span> (<span class="pl-en">getClass</span>() != <span class="pl-s1">obj</span>.<span class="pl-en">getClass</span>())
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-smi">User</span> <span class="pl-s1">other</span> = (<span class="pl-smi">User</span>) <span class="pl-s1">obj</span>;
        <span class="pl-k">if</span> (<span class="pl-s1">host</span> == <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (<span class="pl-s1">other</span>.<span class="pl-s1">host</span> != <span class="pl-c1">null</span>)
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (!<span class="pl-s1">host</span>.<span class="pl-en">equals</span>(<span class="pl-s1">other</span>.<span class="pl-s1">host</span>))
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">if</span> (<span class="pl-s1">password</span> == <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (<span class="pl-s1">other</span>.<span class="pl-s1">password</span> != <span class="pl-c1">null</span>)
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (!<span class="pl-s1">password</span>.<span class="pl-en">equals</span>(<span class="pl-s1">other</span>.<span class="pl-s1">password</span>))
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">if</span> (<span class="pl-s1">username</span> == <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (<span class="pl-s1">other</span>.<span class="pl-s1">username</span> != <span class="pl-c1">null</span>)
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (!<span class="pl-s1">username</span>.<span class="pl-en">equals</span>(<span class="pl-s1">other</span>.<span class="pl-s1">username</span>))
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    
}</pre></div>
<p><strong>面试题：</strong>==和equals的区别</p>
<blockquote>
<p>从我面试的反馈，85%的求职者“理直气壮”的回答错误…</p>
</blockquote>
<ul>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ul>
<p><strong>练习1：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-s1">it</span> = <span class="pl-c1">65</span>;
<span class="pl-smi">float</span> <span class="pl-s1">fl</span> = <span class="pl-c1">65.0f</span>;
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(“<span class="pl-c1">65</span>和<span class="pl-c1">65.0f</span>是否相等？” + (<span class="pl-s1">it</span> == <span class="pl-s1">fl</span>)); <span class="pl-c">//</span>

<span class="pl-smi">char</span> <span class="pl-s1">ch1</span> = <span class="pl-s">'A'</span>; <span class="pl-smi">char</span> <span class="pl-s1">ch2</span> = <span class="pl-c1">12</span>;
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"65和'A'是否相等？"</span> + (<span class="pl-s1">it</span> == <span class="pl-s1">ch1</span>));<span class="pl-c">//</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"12和ch2是否相等？"</span> + (<span class="pl-c1">12</span> == <span class="pl-s1">ch2</span>));<span class="pl-c">//</span>

<span class="pl-smi">String</span> <span class="pl-s1">str1</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"hello"</span>);
<span class="pl-smi">String</span> <span class="pl-s1">str2</span> = <span class="pl-k">new</span> <span class="pl-smi">String</span>(<span class="pl-s">"hello"</span>);
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"str1和str2是否相等？"</span>+ (<span class="pl-s1">str1</span> == <span class="pl-s1">str2</span>));<span class="pl-c">//</span>

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"str1是否equals str2？"</span>+(<span class="pl-s1">str1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">str2</span>)));<span class="pl-c">//</span>

<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(“<span class="pl-s1">hello</span>” == <span class="pl-k">new</span> <span class="pl-smi">java</span>.<span class="pl-smi">util</span>.<span class="pl-smi">Date</span>()); <span class="pl-c">//</span></pre></div>
<p><strong>练习2：</strong></p>
<p>编写Order类，有int型的orderId，String型的orderName，相应的getter()和setter()方法，两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)，并判断测试类中创建的两个对象是否相等。</p>
<p><strong>练习3：</strong></p>
<p>请根据以下代码自行定义能满足需要的MyDate类,在MyDate类中覆盖equals方法，使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false。  public boolean equals(Object o)</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">EqualsTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">MyDate</span> <span class="pl-s1">m1</span> = <span class="pl-k">new</span> <span class="pl-smi">MyDate</span>(<span class="pl-c1">14</span>, <span class="pl-c1">3</span>, <span class="pl-c1">1976</span>);
        <span class="pl-smi">MyDate</span> <span class="pl-s1">m2</span> = <span class="pl-k">new</span> <span class="pl-smi">MyDate</span>(<span class="pl-c1">14</span>, <span class="pl-c1">3</span>, <span class="pl-c1">1976</span>);
        <span class="pl-k">if</span> (<span class="pl-s1">m1</span> == <span class="pl-s1">m2</span>) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"m1==m2"</span>);
        } <span class="pl-k">else</span> {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"m1!=m2"</span>); <span class="pl-c">// m1 != m2</span>
        }

        <span class="pl-k">if</span> (<span class="pl-s1">m1</span>.<span class="pl-en">equals</span>(<span class="pl-s1">m2</span>)) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"m1 is equal to m2"</span>);<span class="pl-c">// m1 is equal to m2</span>
        } <span class="pl-k">else</span> {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"m1 is not equal to m2"</span>);
        }
    }
}</pre></div>
<h4>2、(重点)toString()</h4>
<p>0bject类中tostring()的定义:</p>
<p>public string tostring(){</p>
<p>return getclass().getName()+ "@"+ Integer.toHexString(hashCode());</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ToStringTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">User</span> <span class="pl-s1">user</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"张三"</span>, <span class="pl-c1">20</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">user</span>.<span class="pl-en">toString</span>());
    }
    
}

<span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-c">// @Override</span>
    <span class="pl-c">// public String toString() {</span>
    <span class="pl-c">//     return "User{name='" + name + "', age=" + age + "}";</span>
    <span class="pl-c">// }</span>
}</pre></div>
<blockquote>
<p>User@5caf905d</p>
</blockquote>
<p>开发中的使用场景</p>
<blockquote>
<p>平时我们在调用System.out.println()打印对象引用变量时，其实就调用了对象的toString()</p>
</blockquote>
<p>子类使用说明:</p>
<p>自定义的类，在没有重写0bject类的tostring()的情况下，默认返回的是当前对象的地址值。</p>
<p>像String、File、Date或包装类等0bject的子类，它们都重写了0bject类的toString()，在调用tostring()时返回当前对象的实体内容。</p>
<p>开发中使用说明:</p>
<blockquote>
<p>习惯上，开发中对于自定义的类在调用toString()时，也希望显示其对象的实体内容，而非地址值。这时候，就需要重写0bject</p>
</blockquote>
<p>类中的tostring().</p>
<p>方法签名：public String toString()</p>
<p>① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"</p>
<p>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Date</span> <span class="pl-s1">now</span>=<span class="pl-k">new</span> <span class="pl-smi">Date</span>();
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(“<span class="pl-s1">now</span>=”+<span class="pl-s1">now</span>);  <span class="pl-c">//相当于</span>
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(“<span class="pl-s1">now</span>=”+<span class="pl-s1">now</span>.<span class="pl-en">toString</span>()); </pre></div>
<p>③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p>
<blockquote>
<p>因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。</p>
</blockquote>
<p>④ 可以根据需要在用户自定义类型中重写toString()方法<br>
如String 类重写了toString()方法，返回字符串的值。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-s1">s1</span>=<span class="pl-s">"hello"</span>;
<span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s1</span>);<span class="pl-c">//相当于System.out.println(s1.toString());</span></pre></div>
<p>例如自定义的Person类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span> {  
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Person{"</span> + <span class="pl-s">"name='"</span> + <span class="pl-s1">name</span> + <span class="pl-s">'\''</span> + <span class="pl-s">", age="</span> + <span class="pl-s1">age</span> + <span class="pl-s">'}'</span>;
    }
}</pre></div>
<p><strong>练习</strong>：定义两个类，父类GeometricObject代表几何形状，子类Circle代表圆形。</p>
<h4>3、clone()</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//Object类的clone()的使用</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CloneTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Animal</span> <span class="pl-s1">a1</span> = <span class="pl-k">new</span> <span class="pl-smi">Animal</span>(<span class="pl-s">"花花"</span>);
        <span class="pl-k">try</span> {
            <span class="pl-smi">Animal</span> <span class="pl-s1">a2</span> = (<span class="pl-smi">Animal</span>) <span class="pl-s1">a1</span>.<span class="pl-en">clone</span>();
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"原始对象："</span> + <span class="pl-s1">a1</span>);
            <span class="pl-s1">a2</span>.<span class="pl-en">setName</span>(<span class="pl-s">"毛毛"</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"clone之后的对象："</span> + <span class="pl-s1">a2</span>);
        } <span class="pl-k">catch</span> (<span class="pl-smi">CloneNotSupportedException</span> <span class="pl-s1">e</span>) {
            <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
        }
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Animal</span> <span class="pl-k">implements</span> <span class="pl-smi">Cloneable</span>{
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Animal</span>() {
        <span class="pl-en">super</span>();
    }

    <span class="pl-k">public</span> <span class="pl-smi">Animal</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-en">super</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Animal [name="</span> + <span class="pl-s1">name</span> + <span class="pl-s">"]"</span>;
    }
    
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">protected</span> <span class="pl-smi">Object</span> <span class="pl-en">clone</span>() <span class="pl-k">throws</span> <span class="pl-smi">CloneNotSupportedException</span> {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-k">return</span> <span class="pl-en">super</span>.<span class="pl-en">clone</span>();
    }
    
}</pre></div>
<h4>不那么重要的一些方法</h4>
<h4>4、finalize()</h4>
<ul>
<li>当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）
<ul>
<li>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li>
</ul>
</li>
<li>什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。</li>
<li>子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。
<ul>
<li>如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。</li>
</ul>
</li>
<li>在JDK 9中此方法已经被<code class="notranslate">标记为过时</code>的。</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">FinalizeTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Person</span> <span class="pl-s1">p</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>(<span class="pl-s">"Peter"</span>, <span class="pl-c1">12</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">p</span>);
        <span class="pl-s1">p</span> = <span class="pl-c1">null</span>;<span class="pl-c">//此时对象实体就是垃圾对象，等待被回收。但时间不确定。</span>
        <span class="pl-smi">System</span>.<span class="pl-en">gc</span>();<span class="pl-c">//强制性释放空间</span>
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Person</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-en">super</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">age</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setAge</span>(<span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }
    <span class="pl-c">//子类重写此方法，可在释放对象前进行某些操作</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">finalize</span>() <span class="pl-k">throws</span> <span class="pl-smi">Throwable</span> {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"对象被释放---&gt;"</span> + <span class="pl-smi">this</span>);
    }
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Person [name="</span> + <span class="pl-s1">name</span> + <span class="pl-s">", age="</span> + <span class="pl-s1">age</span> + <span class="pl-s">"]"</span>;
    }
    
}</pre></div>
<h4>5、getClass()</h4>
<p>public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p>
<blockquote>
<p>因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法</p>
</blockquote>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-s1">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
    <span class="pl-smi">Object</span> <span class="pl-s1">obj</span> = <span class="pl-k">new</span> <span class="pl-smi">Person</span>();
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">obj</span>.<span class="pl-en">getClass</span>());<span class="pl-c">//运行时类型</span>
}</pre></div>
<p>结果：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">java</span>.<span class="pl-s1">Person</span></pre></div>
<h4>6、hashCode()</h4>
<p>public int hashCode()：返回每个对象的hash值。(后续在集合框架章节重点讲解)</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-s1">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"AA"</span>.<span class="pl-en">hashCode</span>());<span class="pl-c">//2080</span>
    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"BB"</span>.<span class="pl-en">hashCode</span>());<span class="pl-c">//2112</span>
}</pre></div>
<h3>8.3 native关键字的理解</h3>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用<code class="notranslate">C/C++</code>等非Java语言实现的，并且<code class="notranslate">被编译成了DLL</code>，由Java去调用。</p>
<ul>
<li>本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体</li>
<li>在Java中定义一个native方法时，并不提供实现体。</li>
</ul>
<p><strong>1. 为什么要用native方法</strong></p>
<p>Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<p><strong>2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用</strong></p>
<p>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。</p></div>
<div style="font-size:small;margin-top:8px;float:right;">注意：转载请注明出处<br>转载前请仔细阅读此文章<a href = 'https://blog.adouzi.eu.org/post/21.html'>关于博客文章转载规则以及一些闲聊</a>`<br>个人主页<a href='https://adouzi.eu.org'>https://adouzi.eu.org</a><br>email：shiraayano@adouzi.eu.org</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script>

</html>
