<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="
## 1. 关键字：static


static 关键字的使用

static 静态的   用来修饰的结构，属性，方法：代码块，内部类；

代码示例

```java
public class ChineseTest {
    public static void main(String[] args) {
        Chinese c = new Chinese();
        c.name = '张三';
        c.age = 20;

        Chinese c2 = new Chinese();
        c2.name = '李四';
        c2.age = 30;

        System.out.println(c);
        System.out.println(c2);

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        c2.country = '中国';

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        //我们这里更改c2,可以发现c1的值也遭到了变更
        //因为country是静态变量,属于类,不属于某个对象


        //静态变量在内存中只有一份,被所有对象共享
        //非静态变量在内存中有几份,取决于对象有多少份
        //静态变量可以通过类名直接访问,也可以通过对象名访问
        //非静态变量只能通过对象名访问
        //静态变量和非静态变量,访问时,优先使用非静态变量
        
    }
}
class Chinese {//中国人 类
    //非静态变量,实例变量
    String name;
    int age;
    //静态变量,类变量

    static String country = 'China';
    //非静态方法,实例方法

    public void sayHello() {
        System.out.println('你好,我是' + name);
    }

    //快捷键alt insert
    @Override
    public String toString() {
        // TODO Auto-generated method stub
        //return super.toString();
        return 'Chinese{'+'name='+name+',age='+age+'}';
    }

    
    
    

}
```



3 2  
静态变量:类中的属性使用static进行修饰。">
<meta property="og:title" content="Java 学习笔记 基础篇 004">
<meta property="og:description" content="
## 1. 关键字：static


static 关键字的使用

static 静态的   用来修饰的结构，属性，方法：代码块，内部类；

代码示例

```java
public class ChineseTest {
    public static void main(String[] args) {
        Chinese c = new Chinese();
        c.name = '张三';
        c.age = 20;

        Chinese c2 = new Chinese();
        c2.name = '李四';
        c2.age = 30;

        System.out.println(c);
        System.out.println(c2);

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        c2.country = '中国';

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        //我们这里更改c2,可以发现c1的值也遭到了变更
        //因为country是静态变量,属于类,不属于某个对象


        //静态变量在内存中只有一份,被所有对象共享
        //非静态变量在内存中有几份,取决于对象有多少份
        //静态变量可以通过类名直接访问,也可以通过对象名访问
        //非静态变量只能通过对象名访问
        //静态变量和非静态变量,访问时,优先使用非静态变量
        
    }
}
class Chinese {//中国人 类
    //非静态变量,实例变量
    String name;
    int age;
    //静态变量,类变量

    static String country = 'China';
    //非静态方法,实例方法

    public void sayHello() {
        System.out.println('你好,我是' + name);
    }

    //快捷键alt insert
    @Override
    public String toString() {
        // TODO Auto-generated method stub
        //return super.toString();
        return 'Chinese{'+'name='+name+',age='+age+'}';
    }

    
    
    

}
```



3 2  
静态变量:类中的属性使用static进行修饰。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/14.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java 学习笔记 基础篇 004</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Java 学习笔记 基础篇 004</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>1. 关键字：static</h2>
<p>static 关键字的使用</p>
<p>static 静态的   用来修饰的结构，属性，方法：代码块，内部类；</p>
<p>代码示例</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ChineseTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c</span>.<span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-s1">c</span>.<span class="pl-s1">age</span> = <span class="pl-c1">20</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c2</span>.<span class="pl-s1">name</span> = <span class="pl-s">"李四"</span>;
        <span class="pl-s1">c2</span>.<span class="pl-s1">age</span> = <span class="pl-c1">30</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-s1">c2</span>.<span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-c">//我们这里更改c2,可以发现c1的值也遭到了变更</span>
        <span class="pl-c">//因为country是静态变量,属于类,不属于某个对象</span>


        <span class="pl-c">//静态变量在内存中只有一份,被所有对象共享</span>
        <span class="pl-c">//非静态变量在内存中有几份,取决于对象有多少份</span>
        <span class="pl-c">//静态变量可以通过类名直接访问,也可以通过对象名访问</span>
        <span class="pl-c">//非静态变量只能通过对象名访问</span>
        <span class="pl-c">//静态变量和非静态变量,访问时,优先使用非静态变量</span>
        
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {<span class="pl-c">//中国人 类</span>
    <span class="pl-c">//非静态变量,实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">//静态变量,类变量</span>

    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span> = <span class="pl-s">"China"</span>;
    <span class="pl-c">//非静态方法,实例方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sayHello</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"你好,我是"</span> + <span class="pl-s1">name</span>);
    }

    <span class="pl-c">//快捷键alt insert</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">//return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span>+<span class="pl-s">"name="</span>+<span class="pl-s1">name</span>+<span class="pl-s">",age="</span>+<span class="pl-s1">age</span>+<span class="pl-s">"}"</span>;
    }

    
    
    

}</pre></div>
<p>3 2<br>
静态变量:类中的属性使用static进行修饰。<br>
对比静态变量与实例变量:<br>
① 个数</p>
<blockquote>
<p>静态变量:在内存空间中只有一份，被类的多个对象所共享。<br>
实例变量:类的每一个实例(或对象)都保存着一份实例变量<br>
②内存位置<br>
静态变量:jdk6及之前:存放在方法区。jdk7及之后:存放在堆空间<br>
实例变量:随着对象的创建而加载，每个对象都有一份实例变量。<br>
存放在堆空间的对象实体中。<br>
③ 加载时机<br>
静态变量:随着类的加载而加载，由于类只会加载一次，所以静态变量也只要一份<br>
随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份。<br>
实例变量 随着对象的创建而被加载，每个对象拥有一份实例变量<br>
④ 调用者<br>
静态变量 可以被类直接调用，也可以使用对象调用<br>
实例变量:只能使用对象调用<br>
⑤判断是否可以调用<br>
---&gt;从生命周期的角度解释</p>
<p>类可以调用类变量 不能调用实例变量</p>
<p>对象都可以调用</p>
<p>消亡时机</p>
<p>静态变量 随着类的卸载而消亡</p>
<p>实例变量 随着对象的消亡而消亡</p>
</blockquote>
<p>static修饰方法:</p>
<p>(类方法、静态方法)</p>
<p>随着类的加载而加载</p>
<p>可以通过“类.静态方法"的方式，直接调用静态方法</p>
<p>静态方法内可以调用静态的属性和静态的方法 不可以调用非静态的结构</p>
<p>static 修饰的方法内不能使用 this 和 super</p>
<p>补充 在类的静态方法中 可以调用当前类中的静态结构（属性 方法）或非静态结构（属性 方法）</p>
<h3>静态变量（Static Variables）</h3>
<ol>
<li><strong>定义</strong>：静态变量是使用 <code class="notranslate">static</code> 关键字声明的变量，它属于类的静态成员，而不是类的某个特定对象。</li>
<li><strong>作用域</strong>：静态变量在类的所有实例之间共享，即所有实例共享同一个静态变量。</li>
<li><strong>生命周期</strong>：静态变量的生命周期与类本身相同，只要类被加载，静态变量就存在，直到程序结束。</li>
<li><strong>访问方式</strong>：可以通过类名直接访问静态变量，也可以通过实例访问。</li>
<li><strong>用途</strong>：通常用于存储类级别的信息，比如配置信息或者计数器等。</li>
</ol>
<h3>实例变量（Instance Variables）</h3>
<ol>
<li><strong>定义</strong>：实例变量是类中没有 <code class="notranslate">static</code> 关键字的成员变量，每个类的实例都有自己的一份实例变量。</li>
<li><strong>作用域</strong>：实例变量的作用域仅限于创建它的对象。</li>
<li><strong>生命周期</strong>：实例变量的生命周期与对象的生命周期相同，当对象被创建时实例变量被创建，对象被销毁时实例变量也被销毁。</li>
<li><strong>访问方式</strong>：通常通过对象的实例来访问实例变量。</li>
<li><strong>用途</strong>：用于存储对象特有的数据，每个对象的实例变量可以有不同的值。</li>
</ol>
<h3>区别</h3>
<ul>
<li><strong>存储位置</strong>：静态变量存储在方法区（或静态区），实例变量存储在堆内存中。</li>
<li><strong>访问限制</strong>：静态变量可以在没有创建类实例的情况下被访问，而实例变量必须通过对象实例来访问。</li>
<li><strong>内存分配</strong>：静态变量在内存中只有一个拷贝，而实例变量每个对象都有一个拷贝。</li>
<li><strong>使用场景</strong>：静态变量适用于不需要依赖于对象实例的数据，实例变量适用于需要依赖于对象实例的数据。</li>
<li></li>
</ul>
<p>开发中什么时候需要将属性声明为静态变量？</p>
<p>判断当前类的多个实例是否需要共享此成员变量，且此成员变量的值是相同的</p>
<p>开发中· 常将一些变量声明为静态的 比如 Math 类中的 PI</p>
<p>什么时候需要将方法声明为静态的？</p>
<p>方法内操作的变量如果都是静态变量而非实例变量 的话 则此方法建议声明为静态方法</p>
<p>开发中 常常将工具类的方法声明为静态</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ChineseTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 在没有对象前就可以调用</span>
        <span class="pl-smi">Chinese</span>.<span class="pl-en">show</span>();

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c</span>.<span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-s1">c</span>.<span class="pl-s1">age</span> = <span class="pl-c1">20</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c2</span>.<span class="pl-s1">name</span> = <span class="pl-s">"李四"</span>;
        <span class="pl-s1">c2</span>.<span class="pl-s1">age</span> = <span class="pl-c1">30</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-s1">c2</span>.<span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-c">// 我们这里更改c2,可以发现c1的值也遭到了变更</span>
        <span class="pl-c">// 因为country是静态变量,属于类,不属于某个对象</span>

        <span class="pl-c">// 静态变量在内存中只有一份,被所有对象共享</span>
        <span class="pl-c">// 非静态变量在内存中有几份,取决于对象有多少份</span>
        <span class="pl-c">// 静态变量可以通过类名直接访问,也可以通过对象名访问</span>
        <span class="pl-c">// 非静态变量只能通过对象名访问</span>
        <span class="pl-c">// 静态变量和非静态变量,访问时,优先使用非静态变量</span>

    }
}

<span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {<span class="pl-c">// 中国人 类</span>
    <span class="pl-c">// 非静态变量,实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">// 静态变量,类变量</span>

    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span> = <span class="pl-s">"China"</span>;
    <span class="pl-c">// 非静态方法,实例方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sayHello</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"你好,我是"</span> + <span class="pl-s1">name</span>);
    }

    <span class="pl-c">// 快捷键alt insert</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">// return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span> + <span class="pl-s">"name="</span> + <span class="pl-s1">name</span> + <span class="pl-s">",age="</span> + <span class="pl-s1">age</span> + <span class="pl-s">"}"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"================"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是中国人"</span>);
        <span class="pl-c">// 调用静态的结构</span>
        <span class="pl-c">// 静态方法只能访问静态的结构</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">country</span>);
        <span class="pl-en">method1</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);

        <span class="pl-c">// 调用非静态的结构测试</span>
        <span class="pl-c">// System.out.println(this.name);</span>
        <span class="pl-c">//System.out.println(name);</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * Exception in thread "main" java.lang.Error: Unresolved compilation problem:</span>
<span class="pl-c">         * Cannot use this in a static context</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * at Chinese.show(ChineseTest.java:72)</span>
<span class="pl-c">         * at ChineseTest.main(ChineseTest.java:6)</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * </span>
<span class="pl-c">         * </span>
<span class="pl-c">         * 线程“main”java.lang中出现异常。错误：未解决的编译问题：</span>
<span class="pl-c">         * 不能在静态上下文中使用它</span>
<span class="pl-c">         * 在Chinese.show（中文测试java:72）上</span>
<span class="pl-c">         * 在ChineseTest.main（ChineseTest.java:6）</span>
<span class="pl-c">         */</span>

         <span class="pl-c">//this.eat("饺子");</span>

         <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
         <span class="pl-en">method2</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method1</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是静态方法"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(<span class="pl-smi">String</span> <span class="pl-s1">food</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我正在吃"</span>+<span class="pl-s1">food</span>);
    }
    <span class="pl-c">//非静态方法可以访问静态的和非静态的</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method2</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是非静态方法"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">country</span>);
        <span class="pl-en">method1</span>();
        <span class="pl-en">eat</span>(<span class="pl-s">"面条"</span>);
    }

}</pre></div>
<p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Circle</span>{
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">radius</span>;
    <span class="pl-k">public</span> <span class="pl-smi">Circle</span>(<span class="pl-smi">double</span> <span class="pl-s1">radius</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">radius</span>=<span class="pl-s1">radius</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">findArea</span>(){
        <span class="pl-k">return</span> <span class="pl-smi">Math</span>.<span class="pl-c1">PI</span>*<span class="pl-s1">radius</span>*<span class="pl-s1">radius</span>;
    }
}</pre></div>
<p>创建两个Circle对象：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Circle</span> <span class="pl-s1">c1</span>=<span class="pl-k">new</span> <span class="pl-smi">Circle</span>(<span class="pl-c1">2.0</span>);	<span class="pl-c">//c1.radius=2.0</span>
<span class="pl-smi">Circle</span> <span class="pl-s1">c2</span>=<span class="pl-k">new</span> <span class="pl-smi">Circle</span>(<span class="pl-c1">3.0</span>);	<span class="pl-c">//c2.radius=3.0</span></pre></div>
<p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p>
<p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p>
<h3>1.1 类属性、类方法的设计思想</h3>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<code class="notranslate">某些特定的数据在内存空间里只有一份</code>。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325213629311.png"><img src="images/image-20220325213629311.png" alt="" style="max-width: 100%;"></a></p>
<p>此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为<code class="notranslate">类方法</code>，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<p>这里的类变量、类方法，只需要使用<code class="notranslate">static</code>修饰即可。所以也称为静态变量、静态方法。</p>
<h3>1.2 static关键字</h3>
<ul>
<li>使用范围：
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li>被修饰后的成员具备以下特点：
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h3>1.3 静态变量</h3>
<h4>1.3.1 语法格式</h4>
<p>使用static修饰的成员变量就是静态变量（或类变量、类属性）</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 类{
    [其他修饰符] <span class="pl-k">static</span> 数据类型 变量名;
}</pre></div>
<h4>1.3.2 静态变量的特点</h4>
<ul>
<li>静态变量的默认值规则和实例变量一样。</li>
<li>静态变量值是所有对象共享。</li>
<li>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</li>
<li>如果权限修饰符允许，在其他类中可以通过“<code class="notranslate">类名.静态变量</code>”直接访问，也可以通过“<code class="notranslate">对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</li>
<li>静态变量的get/set方法也静态的，当局部变量与静态变量<code class="notranslate">重名时</code>，使用“<code class="notranslate">类名.静态变量</code>”进行区分。</li>
</ul>
<h4>1.3.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">AccountTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Account</span> <span class="pl-s1">a1</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a1</span>);

        <span class="pl-smi">Account</span> <span class="pl-s1">a2</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a2</span>);

        <span class="pl-smi">Account</span> <span class="pl-s1">a3</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a3</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"银行存款利率为"</span> + <span class="pl-smi">Account</span>.<span class="pl-en">getInterestRate</span>());

    }
    
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Account</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">Id</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">Password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">balance</span>;<span class="pl-c">//余额</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">double</span> <span class="pl-s1">interestRate</span>;<span class="pl-c">//利率</span>

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">init</span> = <span class="pl-c1">1001</span>;<span class="pl-c">//账户数量</span>

    <span class="pl-k">public</span> <span class="pl-smi">Account</span>() {
        <span class="pl-s1">Id</span> = <span class="pl-s1">init</span>++;
        <span class="pl-s1">Password</span> = <span class="pl-s">"123456"</span>;
        <span class="pl-s1">balance</span> = <span class="pl-c1">0.0</span>;
        <span class="pl-s1">interestRate</span> = <span class="pl-c1">0.3</span>;
        
    }
    <span class="pl-k">public</span> <span class="pl-smi">Account</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>, <span class="pl-smi">double</span> <span class="pl-s1">balance</span>) {
        <span class="pl-s1">Id</span> = <span class="pl-s1">init</span>++;
        <span class="pl-s1">Password</span> = <span class="pl-s1">password</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">balance</span> = <span class="pl-s1">balance</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getId</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">Id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setId</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>) {
        <span class="pl-s1">Id</span> = <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">Password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-s1">Password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">double</span> <span class="pl-en">getInterestRate</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">interestRate</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">//return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Account {Id="</span> + <span class="pl-s1">Id</span> + <span class="pl-s">", Password="</span> + <span class="pl-s1">Password</span> + <span class="pl-s">", balance="</span> + <span class="pl-s1">balance</span> + <span class="pl-s">"}"</span>;
    }

    

}</pre></div>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Chinese</span>{
    <span class="pl-c">//实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">//类变量</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">nation</span>;<span class="pl-c">//国籍</span>

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>() {
    }

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span> +
                <span class="pl-s">"name='"</span> + <span class="pl-s1">name</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">", age="</span> + <span class="pl-s1">age</span> +
                <span class="pl-s">", nation='"</span> + <span class="pl-s1">nation</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">'}'</span>;
    }
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StaticTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c1</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"康师傅"</span>,<span class="pl-c1">36</span>);
        <span class="pl-s1">c1</span>.<span class="pl-s1">nation</span> = <span class="pl-s">"中华人民共和国"</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"老干妈"</span>,<span class="pl-c1">66</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Chinese</span>.<span class="pl-s1">nation</span>);
    }
}</pre></div>
<p>对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）</p>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Employee</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">total</span>;<span class="pl-c">//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">company</span>; <span class="pl-c">//这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问</span>
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">id</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Employee</span>() {
        <span class="pl-s1">total</span>++;
        <span class="pl-s1">id</span> = <span class="pl-s1">total</span>;<span class="pl-c">//这里使用total静态变量的值为id属性赋值</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">Employee</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setId</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">id</span> = <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getId</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getTotal</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">total</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">setTotal</span>(<span class="pl-smi">int</span> <span class="pl-s1">total</span>) {
        <span class="pl-smi">Employee</span>.<span class="pl-s1">total</span> = <span class="pl-s1">total</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Employee{company = "</span> + <span class="pl-s1">company</span> + <span class="pl-s">",id = "</span> + <span class="pl-s1">id</span> + <span class="pl-s">" ,name="</span> + <span class="pl-s1">name</span> +<span class="pl-s">"}"</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticVariable</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//静态变量total的默认值是0</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Employee.total = "</span> + <span class="pl-smi">Employee</span>.<span class="pl-en">getTotal</span>());

        <span class="pl-smi">Employee</span> <span class="pl-s1">e1</span> = <span class="pl-k">new</span> <span class="pl-smi">Employee</span>(<span class="pl-s">"张三"</span>);
        <span class="pl-smi">Employee</span> <span class="pl-s1">e2</span> = <span class="pl-k">new</span> <span class="pl-smi">Employee</span>(<span class="pl-s">"李四"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的默认值是null</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的默认值是null</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Employee.total = "</span> + <span class="pl-smi">Employee</span>.<span class="pl-en">getTotal</span>());<span class="pl-c">//静态变量total值是2</span>

        <span class="pl-smi">Employee</span>.<span class="pl-s1">company</span> = <span class="pl-s">"尚硅谷"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的值是尚硅谷</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的值是尚硅谷</span>

        <span class="pl-c">//只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问</span>
        <span class="pl-s1">e1</span>.<span class="pl-s1">company</span> = <span class="pl-s">"超级尚硅谷"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的值是超级尚硅谷</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的值是超级尚硅谷</span>
    }
}</pre></div>
<h3>1.4 静态方法</h3>
<h4>1.4.1 语法格式</h4>
<p>用static修饰的成员方法就是静态方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 类{
    [其他修饰符] <span class="pl-k">static</span> 返回值类型 方法名(形参列表){
        方法体
    }
}</pre></div>
<h4>1.4.2 静态方法的特点</h4>
<ul>
<li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li>
<li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li>
<li>静态方法可以被子类继承，但不能被子类重写。</li>
<li>静态方法的调用都只看编译时类型。</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li>
</ul>
<h4>1.4.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.method"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">fun</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.fun"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
<span class="pl-c">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">fun</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Son.fun"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticMethod</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Father</span>.<span class="pl-en">method</span>();
        <span class="pl-smi">Son</span>.<span class="pl-en">method</span>();<span class="pl-c">//继承静态方法</span>

        <span class="pl-smi">Father</span> <span class="pl-s1">f</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">f</span>.<span class="pl-en">method</span>();<span class="pl-c">//执行Father类中的method</span>
    }
}</pre></div>
<h3>1.5 练习</h3>
<p>笔试题：如下程序执行会不会报错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * @author 尚硅谷-宋红康</span>
<span class="pl-c"> * @create 14:30</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StaticTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Demo</span> <span class="pl-s1">test</span> = <span class="pl-c1">null</span>;
        <span class="pl-s1">test</span>.<span class="pl-en">hello</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Demo</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">hello</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"hello!"</span>);
    }
}</pre></div>
<p>练习：</p>
<p>编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。<code class="notranslate">账号要自动生成。</code></p>
<p>编写主类，使用银行账户类，输入、输出3个储户的上述信息。</p>
<p>考虑：哪些属性可以设计成static属性。</p>
<h2>2. 单例(Singleton)设计模式</h2>
<h3>2.1 设计模式概述</h3>
<p><strong>设计模式</strong>是在大量的<code class="notranslate">实践中总结</code>和<code class="notranslate">理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。"套路"</p>
<p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。</p>
<blockquote>
<p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版</p>
</blockquote>
<blockquote>
<p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为"四人组（Gang of Four）"，而这本书也就被称为"四人组（或 GoF）"书。</p>
</blockquote>
<p>经典的设计模式一共有 23 种</p>
<h3>2.2 何为单例模式</h3>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<h3>2.3 实现思路</h3>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code class="notranslate">类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code class="notranslate">只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code class="notranslate">该类对象的变量也必须定义成静态的</code>。</p>
<h3>2.4 单例模式的两种实现方式</h3>
<h4>2.4.1 饿汉式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Singleton</span> {
    <span class="pl-c">// 1.私有化构造器</span>
    <span class="pl-k">private</span> <span class="pl-smi">Singleton</span>() {
    }

    <span class="pl-c">// 2.内部提供一个当前类的实例</span>
    <span class="pl-c">// 4.此实例也必须静态化</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-s1">single</span> = <span class="pl-k">new</span> <span class="pl-smi">Singleton</span>();

    <span class="pl-c">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">single</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Banktest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 单例模式</span>
        <span class="pl-smi">Bank</span> <span class="pl-s1">bank</span> = <span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>();
                <span class="pl-smi">Bank</span> <span class="pl-s1">bank1</span> = <span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>();
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">bank</span> == <span class="pl-s1">bank1</span>);
                <span class="pl-c">//输出为true</span>
                
        
            }
        
        }
        <span class="pl-c">//饿汉式</span>
        <span class="pl-k">class</span> <span class="pl-smi">Bank</span> {
            <span class="pl-c">// 私有化构造方法</span>
            <span class="pl-k">private</span> <span class="pl-smi">Bank</span>() {
        
            }
        
            <span class="pl-c">// 在类中创建当前类的实例</span>
            <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">Bank</span>();
        
            <span class="pl-c">// 对外提供公共的访问方法</span>
            <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }

}</pre></div>
<h4>2.4.2 懒汉式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Singleton</span> {
    <span class="pl-c">// 1.私有化构造器</span>
    <span class="pl-k">private</span> <span class="pl-smi">Singleton</span>() {
    }
    <span class="pl-c">// 2.内部提供一个当前类的实例</span>
    <span class="pl-c">// 4.此实例也必须静态化</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-s1">single</span>;
    <span class="pl-c">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">if</span>(<span class="pl-s1">single</span> == <span class="pl-c1">null</span>) {
            <span class="pl-s1">single</span> = <span class="pl-k">new</span> <span class="pl-smi">Singleton</span>();
        }
        <span class="pl-k">return</span> <span class="pl-s1">single</span>;
    }
}</pre></div>
<h4>2.4.3 饿汉式 vs 懒汉式</h4>
<p>饿汉式：</p>
<ul>
<li>特点：<code class="notranslate">立即加载</code>，即在使用类的时候已经将对象创建完毕。</li>
<li>优点：实现起来<code class="notranslate">简单</code>；没有多线程安全问题。</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code class="notranslate">耗费内存</code>。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code class="notranslate">延迟加载</code>，即在调用静态方法时实例才被创建。</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code class="notranslate">节约内存</code>。</li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code class="notranslate">线程不安全</code>，根本不能保证单例的唯一性。
<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li>
</ul>
</li>
</ul>
<p>4.对比两种模式(特点、优缺点)<br>
特点:</p>
<blockquote>
<p>饿汉式:"立即加载”,随着类的加载，当前的唯一实例就创建了<br>
懒汉式:"延迟加载"在需要使用的时候，进行创建。<br>
优缺点:<br>
饿汉式:<br>
(优点)写法简单，由于内存中较早加载，使用更方便、更快。是线程安全的。<br>
(缺点)内存中占用时间较长。<br>
懒汉式:<br>
(缺点)线程不安全(放到多线程章节时解决)(优点)在需要的时候进行创建，节省内存空间。</p>
</blockquote>
<p>饿汉式生命周期过长，容易造成资源浪费，但是能保证线程安全，面试优先写饿汉式</p>
<h3>2.5 单例模式的优点及应用场景</h3>
<p>由于单例模式只生成一个实例，减少了<code class="notranslate">系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<p>举例：</p>
<p><strong>应用场景</strong></p>
<ul>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li>Application 也是单例的典型应用</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
</ul>
<h2>3. 理解main方法的语法</h2>
<p>由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>
<p><strong>命令行参数用法举例</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CommandPara</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"args["</span> + <span class="pl-s1">i</span> + <span class="pl-s">"] = "</span> + <span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//运行程序CommandPara.java</span>
<span class="pl-smi">java</span> <span class="pl-s1">CommandPara</span> <span class="pl-s">"Tom"</span> <span class="pl-s">"Jerry"</span> <span class="pl-s">"Shkstart"</span></pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//输出结果</span>
<span class="pl-s1">args</span>[<span class="pl-c1">0</span>] = <span class="pl-smi">Tom</span>
<span class="pl-s1">args</span>[<span class="pl-c1">1</span>] = <span class="pl-smi">Jerry</span>
<span class="pl-s1">args</span>[<span class="pl-c1">2</span>] = <span class="pl-s1">Shkstart</span></pre></div>
<p>main()方法的剖析</p>
<p>public static void main(String args[]){}</p>
<p>1.理解1:看做是一个普通的静态方法</p>
<p>理解2:看做是程序的入口，格式是固定的</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 程序的入口</span>
        <span class="pl-c">// TODO Auto-generated method stub</span>

        <span class="pl-smi">String</span>[] <span class="pl-s1">args1</span> = { <span class="pl-s">"a"</span>, <span class="pl-s">"b"</span>, <span class="pl-s">"c"</span> };
        <span class="pl-smi">MainTest</span>.<span class="pl-en">Test</span>(<span class="pl-s1">args1</span>);

    }
}

<span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 看作普通方方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }

}</pre></div>
<h3>1. <code class="notranslate">Main</code> 类（了解）</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { <span class="pl-c">// 程序的入口</span>
        <span class="pl-c">// TODO Auto-generated method stub</span>

        <span class="pl-smi">String</span>[] <span class="pl-s1">args1</span> = { <span class="pl-s">"a"</span>, <span class="pl-s">"b"</span>, <span class="pl-s">"c"</span> };
        <span class="pl-smi">MainTest</span>.<span class="pl-en">Test</span>(<span class="pl-s1">args1</span>);
    }
}</pre></div>
<ul>
<li><code class="notranslate">public class Main</code>: 定义了一个名为 <code class="notranslate">Main</code> 的公共类。在 Java 中，每个程序至少需要一个类，并且通常这个类包含 <code class="notranslate">main</code> 方法作为程序的入口点。</li>
<li><code class="notranslate">public static void main(String[] args)</code>: 这是 Java 程序的主入口点。当程序启动时，JVM 会调用这个方法。<code class="notranslate">public</code> 表示这个方法是公共的，可以从外部访问；<code class="notranslate">static</code> 表示这个方法属于类本身而不是类的实例；<code class="notranslate">void</code> 表示这个方法不返回任何值；<code class="notranslate">String[] args</code> 是一个字符串数组，用于接收命令行参数。</li>
<li><code class="notranslate">String[] args1 = { "a", "b", "c" };</code>: 定义了一个字符串数组 <code class="notranslate">args1</code>，并初始化为包含三个元素 <code class="notranslate">"a"</code>、<code class="notranslate">"b"</code> 和 <code class="notranslate">"c"</code>。</li>
<li><code class="notranslate">MainTest.Test(args1);</code>: 调用 <code class="notranslate">MainTest</code> 类中的 <code class="notranslate">Test</code> 方法，并将 <code class="notranslate">args1</code> 作为参数传递给它。</li>
</ul>
<h3>2. <code class="notranslate">MainTest</code> 类</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { <span class="pl-c">// 看作普通方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }
}</pre></div>
<ul>
<li><code class="notranslate">class MainTest</code>: 定义了一个名为 <code class="notranslate">MainTest</code> 的类。这个类不是公共的，所以只能在同一文件中访问。</li>
<li><code class="notranslate">public static void Test(String[] args)</code>: 定义了一个静态方法 <code class="notranslate">Test</code>，它接受一个字符串数组 <code class="notranslate">args</code> 作为参数。<code class="notranslate">public</code> 表示这个方法是公共的，可以从外部访问；<code class="notranslate">static</code> 表示这个方法属于类本身而不是类的实例；<code class="notranslate">void</code> 表示这个方法不返回任何值；<code class="notranslate">String[] args</code> 是一个字符串数组，用于接收传入的参数。</li>
<li><code class="notranslate">System.out.println("Main的MainTest()调用");</code>: 输出字符串 <code class="notranslate">"Main的MainTest()调用"</code> 到控制台。</li>
<li><code class="notranslate">for (int i = 0; i &lt; args.length; i++)</code>: 使用一个 <code class="notranslate">for</code> 循环遍历传入的字符串数组 <code class="notranslate">args</code>。<code class="notranslate">args.length</code> 返回数组的长度。</li>
<li><code class="notranslate">System.out.println(args[i]);</code>: 在循环体内，输出数组 <code class="notranslate">args</code> 的第 <code class="notranslate">i</code> 个元素到控制台。</li>
</ul>
<h3>总结</h3>
<ul>
<li><code class="notranslate">Main</code>** 类** 包含了程序的入口点 <code class="notranslate">main</code> 方法。在这个方法中，创建了一个字符串数组 <code class="notranslate">args1</code> 并调用了 <code class="notranslate">MainTest</code> 类中的 <code class="notranslate">Test</code> 方法。</li>
<li><code class="notranslate">MainTest</code>** 类** 包含了一个静态方法 <code class="notranslate">Test</code>，这个方法接收一个字符串数组作为参数，并打印出数组中的每一个元素。</li>
</ul>
<p>运行输出是：</p>
<pre lang="plain" class="notranslate"><code class="notranslate">Main的MainTest()调用
a
b
c
</code></pre>
<p>2.与控制台交互</p>
<p>如何从键盘获取数据？</p>
<ul>
<li>方式一 使用 Scanner</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Scanner</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">scanner</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建Scanner对象，用于获取键盘输入</span>
        <span class="pl-smi">Scanner</span> <span class="pl-s1">scanner</span> = <span class="pl-k">new</span> <span class="pl-smi">Scanner</span>(<span class="pl-smi">System</span>.<span class="pl-s1">in</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"name："</span>);
        <span class="pl-c">// 调用next()方法读取一行文本（不包括换行符）</span>
        <span class="pl-smi">String</span> <span class="pl-s1">name</span> = <span class="pl-s1">scanner</span>.<span class="pl-en">next</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"age："</span>);
        <span class="pl-c">// 调用nextInt()方法读取一个整数</span>
        <span class="pl-smi">int</span> <span class="pl-s1">age</span> = <span class="pl-s1">scanner</span>.<span class="pl-en">nextInt</span>();

        <span class="pl-c">// 输出获取到的信息</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"name："</span> + <span class="pl-s1">name</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"age："</span> + <span class="pl-s1">age</span>);
        <span class="pl-c">// 关闭Scanner对象</span>
        <span class="pl-s1">scanner</span>.<span class="pl-en">close</span>();
    }
}</pre></div>
<ul>
<li>方式二 使用 main() 的形式传递值</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 看作普通方方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }

}</pre></div>
<blockquote>
<p>javac MainTest.java</p>
<p>java MainTest "Tom" Jerry aa 11 22</p>
</blockquote>
<h4>如此 可在命令行中传参</h4>
<p>在 idea 中可以自定义启动参数 run-Edit Config。。。-Choose Class（选择类）-Program arguments</p>
<h2>4. 类的成员之四：代码块</h2>
<p>回顾:类中可以声明的结构:属性、方法、构造器:代码块(或初始化块)、内部类</p>
<p>1.代码块(或初始化块)的使用</p>
<p>用来初始化类或对象的信息(即初始化类或对象的成员变量)</p>
<p>代码块的修饰:</p>
<p>只能使用static进行修饰。</p>
<p>3.代码块的分类:</p>
<p>静态代码块:使用static修饰</p>
<p>非静态代码块:没有使用static修饰</p>
<p>具体使用:</p>
<p>4.1 静态代码块:</p>
<ul>
<li>随着类的加载而调用</li>
<li>由于类的加载只会执行一次，所以静态代码块只会执行一次</li>
<li>作用：用来初始化类的信息</li>
<li>内部类可以声明变量 调用属性或方法 编写输出语句等操作</li>
<li>声明多个静态代码块按照声明先后执行</li>
<li>静态代码块只能调用静态的结构（静态的属性，方法），不能调用非静态的结构（非静态的属性或方法）</li>
</ul>
<p>4.2 非静态代码块:</p>
<ul>
<li>随着对象的创建而执行</li>
<li>每创建当前类的一个实例就会执行一次</li>
<li>作用：用于初始化对象的信息</li>
<li>内部类可以声明变量 调用属性或方法 编写输出语句等操作</li>
<li>非静态代码块可以调用静态结构，也可以调用非静态的结构</li>
</ul>
<p><strong>静态代码块优先于非静态代码块执行</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//非静态代码块</span>
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person代码块"</span>);
    }
    <span class="pl-c">//静态代码块</span>
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person静态代码块"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//非静态代码块</span>
    <span class="pl-c">//随着对象的创建而执行</span>
    <span class="pl-c">//每创建一个对象，执行一次</span>
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person代码块"</span>);
    }

    <span class="pl-c">//静态代码块</span>
    <span class="pl-c">//随着类的加载而执行</span>
    <span class="pl-c">//只执行一次</span>
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person静态代码块"</span>);
    }
    <span class="pl-c">//静态代码块优先执行</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">info</span>=<span class="pl-s">"我是一个人"</span>;
}</pre></div>
<p>如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。</p>
<ul>
<li>代码块(或初始化块)的<code class="notranslate">作用</code>：</li>
<li>对Java类或对象进行初始化</li>
<li>代码块(或初始化块)的<code class="notranslate">分类</code>：
<ul>
<li>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)</li>
<li>没有使用static修饰的，为非静态代码块。</li>
</ul>
</li>
</ul>
<h3>4.1 静态代码块</h3>
<p>如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。</p>
<h4>4.1.1 语法格式</h4>
<p>在代码块的前面加static，就是静态代码块。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 类{
    <span class="pl-k">static</span>{
        静态代码块
    }
}</pre></div>
<h4>4.1.2 静态代码块的特点</h4>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {
<span class="pl-c">//    private static String country = "中国";</span>

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"非静态代码块，country = "</span> + <span class="pl-s1">country</span>);
    }

    <span class="pl-k">static</span> {
        <span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"静态代码块"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticBlock</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c1</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"张三"</span>);
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"李四"</span>);
    }
}</pre></div>
<h3>4.2 非静态代码块</h3>
<h4>4.2.1 语法格式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 类{
    {
        非静态代码块
    }
    【修饰符】 构造器名(){
        <span class="pl-c">// 实例初始化代码</span>
    }
    【修饰符】 构造器名(参数列表){
        <span class="pl-c">// 实例初始化代码</span>
    }
}</pre></div>
<h4>4.2.2 非静态代码块的作用</h4>
<p>和构造器一样，也是用于实例变量的初始化等操作。</p>
<h4>4.2.3 非静态代码块的意义</h4>
<p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p>
<h4>4.2.4 非静态代码块的执行特点</h4>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
<h3>4.3 举例</h3>
<p><strong>举例1：</strong></p>
<p>（1）声明User类，</p>
<ul>
<li>包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化</li>
<li>包含get/set方法，其中registrationTime没有set方法</li>
<li>包含无参构造，
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username就默认为当前系统时间值，</li>
<li>password默认为“123456”</li>
</ul>
</li>
<li>包含有参构造(String username, String password)，
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username和password由参数赋值</li>
</ul>
</li>
<li>包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”</li>
</ul>
<p>（2）编写测试类，测试类main方法的代码如下：</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-s1">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">User</span> <span class="pl-s1">u1</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">u1</span>.<span class="pl-en">getInfo</span>());

        <span class="pl-smi">User</span> <span class="pl-s1">u2</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"song"</span>,<span class="pl-s">"8888"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">u2</span>.<span class="pl-en">getInfo</span>());
    }</pre></div>
<p>如果不用非静态代码块，User类是这样的：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">block</span>.<span class="pl-s1">no</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">long</span> <span class="pl-s1">registrationTime</span>;

    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-s1">username</span> = <span class="pl-s1">registrationTime</span>+<span class="pl-s">""</span>;
        <span class="pl-s1">password</span> = <span class="pl-s">"123456"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>,<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">long</span> <span class="pl-en">getRegistrationTime</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">registrationTime</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>(){
        <span class="pl-k">return</span> <span class="pl-s">"用户名："</span> + <span class="pl-s1">username</span> + <span class="pl-s">"，密码："</span> + <span class="pl-s1">password</span> + <span class="pl-s">"，注册时间："</span> + <span class="pl-s1">registrationTime</span>;
    }
}</pre></div>
<p>如果提取构造器公共代码到非静态代码块，User类是这样的：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">block</span>.<span class="pl-s1">use</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">long</span> <span class="pl-s1">registrationTime</span>;

    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-s1">username</span> = <span class="pl-s1">registrationTime</span>+<span class="pl-s">""</span>;
        <span class="pl-s1">password</span> = <span class="pl-s">"123456"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">long</span> <span class="pl-en">getRegistrationTime</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">registrationTime</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>(){
        <span class="pl-k">return</span> <span class="pl-s">"用户名："</span> + <span class="pl-s1">username</span> + <span class="pl-s">"，密码："</span> + <span class="pl-s1">password</span> + <span class="pl-s">"，注册时间："</span> + <span class="pl-s1">registrationTime</span>;
    }
}</pre></div>
<p><strong>举例2：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">DataSource</span> <span class="pl-s1">dataSource</span> = <span class="pl-c1">null</span>;

<span class="pl-k">static</span>{
    <span class="pl-smi">InputStream</span> <span class="pl-s1">is</span> = <span class="pl-c1">null</span>;
    <span class="pl-k">try</span> {
        <span class="pl-s1">is</span> = <span class="pl-smi">DBCPTest</span>.<span class="pl-k">class</span>.<span class="pl-en">getClassLoader</span>().<span class="pl-en">getResourceAsStream</span>(<span class="pl-s">"dbcp.properties"</span>);
        <span class="pl-smi">Properties</span> <span class="pl-s1">pros</span> = <span class="pl-k">new</span> <span class="pl-smi">Properties</span>();
        <span class="pl-s1">pros</span>.<span class="pl-en">load</span>(<span class="pl-s1">is</span>);
        <span class="pl-c">//调用BasicDataSourceFactory的静态方法，获取数据源。</span>
        <span class="pl-s1">dataSource</span> = <span class="pl-smi">BasicDataSourceFactory</span>.<span class="pl-en">createDataSource</span>(<span class="pl-s1">pros</span>);
    } <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> <span class="pl-s1">e</span>) {
        <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
    }<span class="pl-k">finally</span>{
        <span class="pl-k">if</span>(<span class="pl-s1">is</span> != <span class="pl-c1">null</span>){
            <span class="pl-k">try</span> {
                <span class="pl-s1">is</span>.<span class="pl-en">close</span>();
            } <span class="pl-k">catch</span> (<span class="pl-smi">IOException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }		
        }		
    }		
}</pre></div>
<h3>4.4 小结：实例变量赋值顺序</h3>
<h3>4.5 练习</h3>
<p>练习1：分析加载顺序</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Root</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的普通初始化块"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Root</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的无参数的构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Mid</span> <span class="pl-k">extends</span> <span class="pl-smi">Root</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的普通初始化块"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Mid</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的无参数的构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Mid</span>(<span class="pl-smi">String</span> <span class="pl-s1">msg</span>){
        <span class="pl-c">//通过this调用同一类中重载的构造器</span>
        <span class="pl-smi">this</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的带参数构造器，其参数值："</span>
            + <span class="pl-s1">msg</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Leaf</span> <span class="pl-k">extends</span> <span class="pl-smi">Mid</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的普通初始化块"</span>);
    }	
    <span class="pl-k">public</span> <span class="pl-smi">Leaf</span>(){
        <span class="pl-c">//通过super调用父类中有一个字符串参数的构造器</span>
        <span class="pl-en">super</span>(<span class="pl-s">"尚硅谷"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的构造器"</span>);
    }
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">LeafTest</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-k">new</span> <span class="pl-smi">Leaf</span>(); 
        <span class="pl-c">//new Leaf();</span>
    }
}</pre></div>
<p>练习2：分析加载顺序</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">static</span> {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"11111111111"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"22222222222"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Father</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"33333333333"</span>);

    }

}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">static</span> {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"44444444444"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"55555555555"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Son</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"66666666666"</span>);
    }


    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { 
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"77777777777"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);
        <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);

        <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);
        <span class="pl-k">new</span> <span class="pl-smi">Father</span>();
    }

}</pre></div>
<p>练习3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu05</span>.<span class="pl-s1">field</span>.<span class="pl-s1">interview</span>;

<span class="pl-c">/**</span>
<span class="pl-c"> * @author 尚硅谷-宋红康</span>
<span class="pl-c"> * @create 16:04</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test04</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Zi</span> <span class="pl-s1">zi</span> = <span class="pl-k">new</span> <span class="pl-smi">Zi</span>();
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Fu</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（1）i"</span>);
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">j</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（2）j"</span>);
    <span class="pl-k">static</span>{
        <span class="pl-en">print</span>(<span class="pl-s">"（3）父类静态代码块"</span>);
    }
    {
        <span class="pl-en">print</span>(<span class="pl-s">"（4）父类非静态代码块，又称为构造代码块"</span>);
    }
    <span class="pl-smi">Fu</span>(){
        <span class="pl-en">print</span>(<span class="pl-s">"（5）父类构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span> + <span class="pl-s">"-&gt;"</span> + <span class="pl-s1">i</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getNum</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-en">print</span>(<span class="pl-s1">str</span>);
        <span class="pl-k">return</span> ++<span class="pl-s1">i</span>;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Zi</span> <span class="pl-k">extends</span> <span class="pl-smi">Fu</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">k</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（6）k"</span>);
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">h</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（7）h"</span>);
    <span class="pl-k">static</span>{
        <span class="pl-en">print</span>(<span class="pl-s">"（8）子类静态代码块"</span>);
    }
    {
        <span class="pl-en">print</span>(<span class="pl-s">"（9）子类非静态代码块，又称为构造代码块"</span>);
    }
    <span class="pl-smi">Zi</span>(){
        <span class="pl-en">print</span>(<span class="pl-s">"（10）子类构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span> + <span class="pl-s">"-&gt;"</span> + <span class="pl-s1">k</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getNum</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-en">print</span>(<span class="pl-s1">str</span>);
        <span class="pl-k">return</span> ++<span class="pl-s1">k</span>;
    }
}</pre></div>
<h3>总结 - 属性赋值的过程</h3>
<p>1.可以给类的非静态的属性(即实例变量)赋值的位置有:</p>
<p>① 默认初始化</p>
<p>② 显式初始化</p>
<p>③ 构造器中初始化</p>
<p>⑤ 代码块中初始化</p>
<p>##########################</p>
<p>④ 有了对象以后，通过"对象.属性"或"对象,方法"的方法进行赋值</p>
<p>2.执行的先后顺序:</p>
<p>1-2/5-3-4</p>
<h5>(超纲)关于字节码文件中的的简单说明:(通过插件jclasslib bytecode viewer查看)</h5>
<p>方法可以在字节码文件中看到 每个方法都有对应着一个类的构造器 （类中声明了几个构造器久游几个）</p>
<p>方法内部代码包含了实例变量的显示赋值 代码块中的赋值和构造器中的代码</p>
<p>方法用来初始化当前创建对象的信息的</p>
<p>给实例变量赋值的位置很多，开发中如何选?</p>
<p>需求分析（废话）</p>
<p>显示赋值，比较于每个对象的属性值相同的场景</p>
<p>构造器中赋值，比较适合于每个对象属性值不同的场景</p>
<h2>5. final关键字</h2>
<h3>5.1 final的意义</h3>
<p>final：最终的，不可更改的</p>
<h3>5.2 final的使用</h3>
<h4>5.2.1 final修饰类</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-c">//正常来讲可以用B继承A</span>
}
<span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">C</span>{
    
}
<span class="pl-k">class</span> <span class="pl-smi">D</span> <span class="pl-k">extends</span> <span class="pl-smi">C</span>{
    <span class="pl-c">//正常来讲可以用D继承C</span>
    <span class="pl-c">//报错</span>
    <span class="pl-c">//使用final修饰的类不能被继承</span>
}</pre></div>
<p>表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">Eunuch</span>{<span class="pl-c">//太监类</span>
    
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Eunuch</span>{<span class="pl-c">//错误</span>
    
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">E</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">show2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show2"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">F</span> <span class="pl-k">extends</span> <span class="pl-smi">E</span>{
    <span class="pl-c">//正常来讲可以用F继承E</span>
    <span class="pl-c">//使用final修饰的方法不能被重写</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show2"</span>);
    }
}</pre></div>
<h4>5.2.2 final修饰方法</h4>
<p>表示这个方法不能被子类重写。</p>
<p>例如：Object类中的getClass()</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"father"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){<span class="pl-c">//错误</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"son"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// final修饰的变量是常量</span>
<span class="pl-k">class</span> <span class="pl-smi">FinalTest2</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
        <span class="pl-c">// a=20;不能修改</span>
        <span class="pl-c">// final修饰的变量必须初始化</span>
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">b</span> = <span class="pl-c1">10</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"____________________"</span>);
        <span class="pl-s1">b</span> = <span class="pl-c1">20</span>;<span class="pl-c">// 不能修改 报错</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>);
        <span class="pl-c">/*</span>
<span class="pl-c">         * cworkspaceStorage\x5ce79013143972bf905b0cf9274b6425dd\x5credhat.java\</span>
<span class="pl-c">         * x5cjdt_ws\x5c1_6f9ffb3d\x5cbin' 'FinalTest2'</span>
<span class="pl-c">         * ;f0033315-a209-4a07-8e6e-2f27dcd3450eException in thread "main"</span>
<span class="pl-c">         * java.lang.Error: Unresolved compilatio</span>
<span class="pl-c">         * n problem:</span>
<span class="pl-c">         * The final local variable b cannot be assigned. It must be blank and not using</span>
<span class="pl-c">         * a compound assignment</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * at FinalTest2.main(FinalTest.java:45)</span>
<span class="pl-c">         * PS C:\code\java\Week2\1&gt;</span>
<span class="pl-c">         */</span>
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">FinalTest3</span> {
    <span class="pl-c">//final修饰的变量可以在初始化时赋值</span>
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">a</span>;
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">b</span> = <span class="pl-c1">10</span>;
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">c</span>;
    <span class="pl-c">//也可以在构造器中赋值</span>
    <span class="pl-k">public</span> <span class="pl-smi">FinalTest3</span>() {
        <span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
    }

    <span class="pl-c">//还可以在代码块中赋值</span>
    {
        <span class="pl-s1">c</span> = <span class="pl-c1">10</span>;
    }  
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//final和static搭配</span>
<span class="pl-c">//修饰的变量是常量，称为全局常量</span>
<span class="pl-k">class</span> <span class="pl-smi">FinalTest4</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">FinalTest4</span>.<span class="pl-c1">NUM</span>);
        <span class="pl-c">//NUM=20;不能修改</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">NUM</span> = <span class="pl-c1">10</span>;
}</pre></div>
<h4>5.2.3 final修饰变量</h4>
<p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。</p>
<p>例如：final double MY_PI = 3.14;</p>
<blockquote>
<p>如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</p>
</blockquote>
<ul>
<li>修饰成员变量</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">totalNumber</span> = <span class="pl-c1">5</span>;
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">ID</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Test</span>() {
        <span class="pl-c1">ID</span> = ++<span class="pl-s1">totalNumber</span>; <span class="pl-c">// 可在构造器中给final修饰的“变量”赋值</span>
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Test</span> <span class="pl-s1">t</span> = <span class="pl-k">new</span> <span class="pl-smi">Test</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">t</span>.<span class="pl-c1">ID</span>);
    }
}</pre></div>
<ul>
<li>修饰局部变量：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestFinal</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MIN_SCORE</span> ;
        <span class="pl-c1">MIN_SCORE</span> = <span class="pl-c1">0</span>;
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MAX_SCORE</span> = <span class="pl-c1">100</span>;
        <span class="pl-c1">MAX_SCORE</span> = <span class="pl-c1">200</span>; <span class="pl-c">//非法</span>
    }
}</pre></div>
<ul>
<li>错误演示：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span> {
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">INFO</span> = <span class="pl-s">"atguigu"</span>;  <span class="pl-c">//声明常量</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>() {
        <span class="pl-c">//The final field A.INFO cannot be  assigned</span>
        <span class="pl-c">//INFO = "尚硅谷"; </span>
    }
}</pre></div>
<h3>5.3 笔试题</h3>
<p>题1：排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Something</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">addOne</span>(<span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">x</span>) {
        <span class="pl-k">return</span> ++<span class="pl-s1">x</span>;
        <span class="pl-c">// return x + 1;</span>
    }
}</pre></div>
<p>题2：排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Something</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Other</span> <span class="pl-s1">o</span> = <span class="pl-k">new</span> <span class="pl-smi">Other</span>();
        <span class="pl-k">new</span> <span class="pl-smi">Something</span>().<span class="pl-en">addOne</span>(<span class="pl-s1">o</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">addOne</span>(<span class="pl-k">final</span> <span class="pl-smi">Other</span> <span class="pl-s1">o</span>) {
        <span class="pl-c">// o = new Other();</span>
        <span class="pl-s1">o</span>.<span class="pl-s1">i</span>++;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Other</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">i</span>;
}</pre></div>
<h2>6. 抽象类与抽象方法(或abstract关键字)</h2>
<p>让父类不能造对象，不能实例化</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">PersonTest</span> {
    <span class="pl-c">// abstact例子</span>
    <span class="pl-c">// abstract修饰类，该类就是抽象类</span>
    <span class="pl-c">// 抽象类中可以定义抽象方法，抽象方法没有方法体</span>
    <span class="pl-c">// 抽象类中可以定义非抽象方法</span>
    <span class="pl-c">// 抽象类不能实例化</span>
    <span class="pl-c">// 抽象类中可以定义构造方法</span>
    <span class="pl-c">// 抽象类的子类必须重写父类中的所有抽象方法，否则子类也是抽象类</span>

    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">PersonTest</span>() {

    }

    <span class="pl-k">public</span> <span class="pl-smi">PersonTest</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人吃饭"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人睡觉"</span>);
    }

}
<span class="pl-c">//抽象类</span>
<span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//定义抽象方法</span>
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">say</span>();


}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Student</span> <span class="pl-k">extends</span> <span class="pl-smi">PersonTest</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">school</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>() {

    }

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>, <span class="pl-smi">String</span> <span class="pl-s1">school</span>) {
        <span class="pl-en">super</span>(<span class="pl-s1">name</span>, <span class="pl-s1">age</span>);
        <span class="pl-smi">this</span>.<span class="pl-s1">school</span> = <span class="pl-s1">school</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生吃饭"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生睡觉"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">say</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是学生"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Student</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">eat</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">sleep</span>();

        <span class="pl-smi">PersonTest</span> <span class="pl-s1">P</span> = <span class="pl-k">new</span> <span class="pl-smi">PersonTest</span>();
        <span class="pl-smi">P</span>.<span class="pl-en">eat</span>();
        <span class="pl-smi">P</span>.<span class="pl-en">sleep</span>();
        
        <span class="pl-s1">s</span>.<span class="pl-en">say</span>();
    }

}</pre></div>
<p>abstract修饰类:</p>
<blockquote>
<p>此类称为抽象类<br>
抽象类不能实例化。<br>
抽象类中是包含构造器的，因为子类对象实例化时，需要直接或间接的调用到父类的构造器。<br>
抽象类中可以役有抽象方法。反之，抽象方法所在的类，一定是抽象类。</p>
</blockquote>
<p>abstract修饰方法</p>
<blockquote>
<p>此方法即为抽象方法<br>
抽象方法只有方法的声明，没有方法体。<br>
抽象方法其功能是确定的(通过方法的声明即可确定)，只是不知道如何实现，因为没有方法体</p>
<p>子类必须重写父类所有抽方法后才可实例化，否则子类仍然时一个抽象类</p>
</blockquote>
<p>abstract不能使用的场景</p>
<p>abstract 不能修饰哪些结构?<br>
属性、构造器、代码块等。<br>
abstract 不能与哪些关键字共用?(自治)<br>
不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
<blockquote>
<p>私有方法不能重写</p>
</blockquote>
<h3>6.1 由来</h3>
<p>举例1：</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325231608838.png"><img src="images/image-20220325231608838.png" alt="" style="max-width: 100%;"></a></p>
<p>举例2：</p>
<p>我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又<code class="notranslate">无法给出具体的实现</code>，而是应该交给子类各自具体实现。那么父类在声明这些方法时，<code class="notranslate">就只有方法签名，没有方法体</code>，我们把没有方法体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类必须是<strong>抽象类</strong>。</p>
<h3>6.2 语法格式</h3>
<ul>
<li><strong>抽象类</strong>：被abstract修饰的类。</li>
<li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li>
</ul>
<p>抽象类的语法格式</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[权限修饰符] <span class="pl-k">abstract</span> <span class="pl-k">class</span> 类名{
    
}
[权限修饰符] <span class="pl-k">abstract</span> <span class="pl-k">class</span> 类名 <span class="pl-k">extends</span> 父类{
    
}</pre></div>
<p>抽象方法的语法格式</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[其他修饰符] <span class="pl-k">abstract</span> 返回值类型 方法名([形参列表]);</pre></div>
<blockquote>
<p>注意：抽象方法没有方法体</p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220517204707255.png"><img src="images/image-20220517204707255.png" alt="" style="max-width: 100%;"></a></p>
<p>代码举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>();
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Cat</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span> (){
          <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"小猫吃鱼和猫粮"</span>); 
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CatTest</span> {
      <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建子类对象</span>
        <span class="pl-smi">Cat</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>(); 
       
        <span class="pl-c">// 调用eat方法</span>
        <span class="pl-s1">c</span>.<span class="pl-en">eat</span>();
      }
}</pre></div>
<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h3>6.3 使用说明</h3>
<ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</li>
</ol>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</blockquote>
<ol start="2">
<li>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。</li>
</ol>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p>
</blockquote>
<ol start="3">
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ol>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ol start="4">
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li>
</ol>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<h3>6.4 注意事项</h3>
<ul>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ul>
<h3>6.5 应用举例1</h3>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325232847872.png"><img src="images/image-20220325232847872.png" alt="" style="max-width: 100%;"></a></p>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别<code class="notranslate">计算运输工具的燃料效率</code>和<code class="notranslate">行驶距离</code>。</p>
<p>**问题：**卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</p>
<p>**解决方案：**Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//Vehicle是一个抽象类，有两个抽象方法。</span>
<span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Vehicle</span>{
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>();	<span class="pl-c">//计算燃料效率的抽象方法</span>
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">double</span> <span class="pl-en">calcTripDistance</span>();	<span class="pl-c">//计算行驶距离的抽象方法</span>
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Truck</span> <span class="pl-k">extends</span> <span class="pl-smi">Vehicle</span>{
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>( )   { <span class="pl-c">//写出计算卡车的燃料效率的具体方法   }</span>
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-s1">calcTripDistance</span>( )    {  <span class="pl-c">//写出计算卡车行驶距离的具体方法   }</span>
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">RiverBarge</span> <span class="pl-k">extends</span> <span class="pl-smi">Vehicle</span>{
     <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>( ) { <span class="pl-c">//写出计算驳船的燃料效率的具体方法  }</span>
     <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-s1">calcTripDistance</span>( )  {  <span class="pl-c">//写出计算驳船行驶距离的具体方法}</span>
}</pre></div>
<h3>6.6 应用举例2：模板方法设计模式(TemplateMethod)</h3>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li>当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<p>**类比举例：**英语六级模板</p>
<p>制作月饼的模板：</p>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Template</span> {
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">getTime</span>() {
        <span class="pl-smi">long</span> <span class="pl-s1">start</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-en">code</span>();
        <span class="pl-smi">long</span> <span class="pl-s1">end</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"执行时间是："</span> + (<span class="pl-s1">end</span> - <span class="pl-s1">start</span>));
    }

    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">code</span>();
}

<span class="pl-k">class</span> <span class="pl-smi">SubTemplate</span> <span class="pl-k">extends</span> <span class="pl-smi">Template</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">code</span>() {
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">10000</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">i</span>);
        }
    }
}</pre></div>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">java</span>;
<span class="pl-c">//抽象类的应用：模板方法的设计模式</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TemplateMethodTest</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">BankTemplateMethod</span> <span class="pl-s1">btm</span> = <span class="pl-k">new</span> <span class="pl-smi">DrawMoney</span>();
        <span class="pl-s1">btm</span>.<span class="pl-en">process</span>();

        <span class="pl-smi">BankTemplateMethod</span> <span class="pl-s1">btm2</span> = <span class="pl-k">new</span> <span class="pl-smi">ManageMoney</span>();
        <span class="pl-s1">btm2</span>.<span class="pl-en">process</span>();
    }
}
<span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-c">// 具体方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">takeNumber</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"取号排队"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>(); <span class="pl-c">// 办理具体的业务 //钩子方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">evaluate</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"反馈评分"</span>);
    }

    <span class="pl-c">// 模板方法，把基本操作组合到一起，子类一般不能重写</span>
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">process</span>() {
        <span class="pl-smi">this</span>.<span class="pl-en">takeNumber</span>();

        <span class="pl-smi">this</span>.<span class="pl-en">transact</span>();<span class="pl-c">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span>

        <span class="pl-smi">this</span>.<span class="pl-en">evaluate</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">DrawMoney</span> <span class="pl-k">extends</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我要取款！！！"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">ManageMoney</span> <span class="pl-k">extends</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我要理财！我这里有2000万美元!!"</span>);
    }
}</pre></div>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
<h3>6.7 思考与练习</h3>
<p><strong>思考：</strong></p>
<p>问题1：为什么抽象类不可以使用final关键字声明？</p>
<p>问题2：一个抽象类中可以定义构造器吗？</p>
<p>问题3：是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？</p>
<p><strong>练习1：</strong></p>
<p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。</p>
<p>对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。</p>
<p>请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p>
<p><strong>练习2：软件外包公司外派管理</strong></p>
<p>有一家软件外包公司，可以外派开发人员，该公司有两个角色：普通开发人员Developer和项目经理Manager。他们的关系如下图：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220504164925878.png"><img src="images/image-20220504164925878.png" alt="" style="max-width: 100%;"></a></p>
<p>普通开发人员的工作内容是“开发项目”，项目经理的工作内容是“项目管理”。对外的报价是普通开发人员每天500,元，超过60天每天400元。项目经理每天800元，超过60天每天700元。</p>
<p>有一家银行需要1名项目经理、2名开发人员，现场开发90天，计算银行需要付给软件公司的总金额。</p>
<p>提示：创建数组 Employee[] emps = new Employee[3]。其中存储驻场的3名员工。</p>
<p><strong>练习3：</strong></p>
<p>创建父类Shape，包含绘制形状的抽象方法draw()。</p>
<p>创建Shape的子类Circle和Rectangle，重写draw()方法，绘制圆形和矩形。</p>
<p>绘制多个圆形和矩形。</p>
<p><strong>练习4：</strong></p>
<p>1、声明抽象父类Person，包含抽象方法public abstract void eat();<br>
2、声明子类中国人Chinese，重写抽象方法，打印用筷子吃饭<br>
3、声明子类美国人American，重写抽象方法，打印用刀叉吃饭<br>
4、声明子类印度人Indian，重写抽象方法，打印用手抓饭<br>
5、声明测试类PersonTest，创建Person数组，存储各国人对象，并遍历数组，调用eat()方法</p>
<p><strong>练习5：工资系统设计</strong></p>
<p>编写工资系统，实现不同类型员工(多态)的按月发放工资。如果当月出现某个Employee对象的生日，则将该雇员的工资增加100元。</p>
<p>实验说明：</p>
<p>（1）定义一个Employee类，该类包含：</p>
<p>private成员变量name,number,birthday，其中birthday 为MyDate类的对象；</p>
<p>abstract方法earnings()；</p>
<p>toString()方法输出对象的name,number和birthday。</p>
<p>（2）MyDate类包含:</p>
<p>private成员变量year,month,day ；</p>
<p>toDateString()方法返回日期对应的字符串：xxxx年xx月xx日</p>
<p>（3）定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处理。该类包括：private成员变量monthlySalary；</p>
<p>实现父类的抽象方法earnings(),该方法返回monthlySalary值；toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（4）参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的员工处理。该类包括：</p>
<p>private成员变量wage和hour；</p>
<p>实现父类的抽象方法earnings(),该方法返回wage*hour值；</p>
<p>toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（5）定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本月是某个Employee对象的生日，还要输出增加工资信息。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//提示：</span>
<span class="pl-c">//定义People类型的数组People c1[]=new People[10];</span>
<span class="pl-c">//数组元素赋值</span>
<span class="pl-s1">c1</span>[<span class="pl-c1">0</span>]=<span class="pl-k">new</span> <span class="pl-smi">People</span>(<span class="pl-s">"John"</span>,<span class="pl-s">"0001"</span>,<span class="pl-c1">20</span>);
<span class="pl-s1">c1</span>[<span class="pl-c1">1</span>]=<span class="pl-k">new</span> <span class="pl-smi">People</span>(<span class="pl-s">"Bob"</span>,<span class="pl-s">"0002"</span>,<span class="pl-c1">19</span>);
<span class="pl-c">//若People有两个子类Student和Officer，则数组元素赋值时，可以使父类类型的数组元素指向子类。</span>
<span class="pl-s1">c1</span>[<span class="pl-c1">0</span>]=<span class="pl-k">new</span> <span class="pl-smi">Student</span>(<span class="pl-s">"John"</span>,<span class="pl-s">"0001"</span>,<span class="pl-c1">20</span>,<span class="pl-c1">85.0</span>);
<span class="pl-s1">c1</span>[<span class="pl-c1">1</span>]=<span class="pl-k">new</span> <span class="pl-smi">Officer</span>(<span class="pl-s">"Bob"</span>,<span class="pl-s">"0002"</span>,<span class="pl-c1">19</span>,<span class="pl-c1">90.5</span>);</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;">注意：转载请注明出处<br>个人主页<a href='https://adouzi.eu.org'>https://adouzi.eu.org</a><br>email：shiraayano@adouzi.eu.org</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script>

</html>
