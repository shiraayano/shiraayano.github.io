<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 1. 关键字：static


static 关键字的使用

static 静态的   用来修饰的结构，属性，方法：代码块，内部类；

代码示例

```java
public class ChineseTest {
    public static void main(String[] args) {
        Chinese c = new Chinese();
        c.name = '张三';
        c.age = 20;

        Chinese c2 = new Chinese();
        c2.name = '李四';
        c2.age = 30;

        System.out.println(c);
        System.out.println(c2);

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        c2.country = '中国';

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        //我们这里更改c2,可以发现c1的值也遭到了变更
        //因为country是静态变量,属于类,不属于某个对象


        //静态变量在内存中只有一份,被所有对象共享
        //非静态变量在内存中有几份,取决于对象有多少份
        //静态变量可以通过类名直接访问,也可以通过对象名访问
        //非静态变量只能通过对象名访问
        //静态变量和非静态变量,访问时,优先使用非静态变量
        
    }
}
class Chinese {//中国人 类
    //非静态变量,实例变量
    String name;
    int age;
    //静态变量,类变量

    static String country = 'China';
    //非静态方法,实例方法

    public void sayHello() {
        System.out.println('你好,我是' + name);
    }

    //快捷键alt insert
    @Override
    public String toString() {
        // TODO Auto-generated method stub
        //return super.toString();
        return 'Chinese{'+'name='+name+',age='+age+'}';
    }

    
    
    

}
```



3 2  
静态变量:类中的属性使用static进行修饰。">
<meta property="og:title" content="Java 学习笔记 基础篇 004">
<meta property="og:description" content="## 1. 关键字：static


static 关键字的使用

static 静态的   用来修饰的结构，属性，方法：代码块，内部类；

代码示例

```java
public class ChineseTest {
    public static void main(String[] args) {
        Chinese c = new Chinese();
        c.name = '张三';
        c.age = 20;

        Chinese c2 = new Chinese();
        c2.name = '李四';
        c2.age = 30;

        System.out.println(c);
        System.out.println(c2);

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        c2.country = '中国';

        System.out.println('++++++++++++++++++++++');
        System.out.println(c.country);
        System.out.println(c2.country);

        //我们这里更改c2,可以发现c1的值也遭到了变更
        //因为country是静态变量,属于类,不属于某个对象


        //静态变量在内存中只有一份,被所有对象共享
        //非静态变量在内存中有几份,取决于对象有多少份
        //静态变量可以通过类名直接访问,也可以通过对象名访问
        //非静态变量只能通过对象名访问
        //静态变量和非静态变量,访问时,优先使用非静态变量
        
    }
}
class Chinese {//中国人 类
    //非静态变量,实例变量
    String name;
    int age;
    //静态变量,类变量

    static String country = 'China';
    //非静态方法,实例方法

    public void sayHello() {
        System.out.println('你好,我是' + name);
    }

    //快捷键alt insert
    @Override
    public String toString() {
        // TODO Auto-generated method stub
        //return super.toString();
        return 'Chinese{'+'name='+name+',age='+age+'}';
    }

    
    
    

}
```



3 2  
静态变量:类中的属性使用static进行修饰。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/14.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java 学习笔记 基础篇 004</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>img{max-width:100%;height:auto;display:block;margin:1em auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);transition:transform .2s ease,box-shadow .2s ease;}img[data-src]{opacity:0;animation:fadeIn 1s forwards;}@keyframes fadeIn{to{opacity:1;}}img:hover{transform:scale(1.05);box-shadow:0 8px 12px rgba(0,0,0,.2);}@media(max-width:600px){img{margin:.5em auto;}}</style>



<body>
    <div id="header">
<h1 class="postTitle">Java 学习笔记 基础篇 004</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>1. 关键字：static</h2>
<p>static 关键字的使用</p>
<p>static 静态的   用来修饰的结构，属性，方法：代码块，内部类；</p>
<p>代码示例</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ChineseTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c</span>.<span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-s1">c</span>.<span class="pl-s1">age</span> = <span class="pl-c1">20</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c2</span>.<span class="pl-s1">name</span> = <span class="pl-s">"李四"</span>;
        <span class="pl-s1">c2</span>.<span class="pl-s1">age</span> = <span class="pl-c1">30</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-s1">c2</span>.<span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-c">//我们这里更改c2,可以发现c1的值也遭到了变更</span>
        <span class="pl-c">//因为country是静态变量,属于类,不属于某个对象</span>


        <span class="pl-c">//静态变量在内存中只有一份,被所有对象共享</span>
        <span class="pl-c">//非静态变量在内存中有几份,取决于对象有多少份</span>
        <span class="pl-c">//静态变量可以通过类名直接访问,也可以通过对象名访问</span>
        <span class="pl-c">//非静态变量只能通过对象名访问</span>
        <span class="pl-c">//静态变量和非静态变量,访问时,优先使用非静态变量</span>
        
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {<span class="pl-c">//中国人 类</span>
    <span class="pl-c">//非静态变量,实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">//静态变量,类变量</span>

    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span> = <span class="pl-s">"China"</span>;
    <span class="pl-c">//非静态方法,实例方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sayHello</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"你好,我是"</span> + <span class="pl-s1">name</span>);
    }

    <span class="pl-c">//快捷键alt insert</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">//return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span>+<span class="pl-s">"name="</span>+<span class="pl-s1">name</span>+<span class="pl-s">",age="</span>+<span class="pl-s1">age</span>+<span class="pl-s">"}"</span>;
    }

    
    
    

}</pre></div>
<p>3 2<br>
静态变量:类中的属性使用static进行修饰。<br>
对比静态变量与实例变量:<br>
① 个数</p>
<blockquote>
<p>静态变量:在内存空间中只有一份，被类的多个对象所共享。<br>
实例变量:类的每一个实例(或对象)都保存着一份实例变量<br>
②内存位置<br>
静态变量:jdk6及之前:存放在方法区。jdk7及之后:存放在堆空间<br>
实例变量:随着对象的创建而加载，每个对象都有一份实例变量。<br>
存放在堆空间的对象实体中。<br>
③ 加载时机<br>
静态变量:随着类的加载而加载，由于类只会加载一次，所以静态变量也只要一份<br>
随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份。<br>
实例变量 随着对象的创建而被加载，每个对象拥有一份实例变量<br>
④ 调用者<br>
静态变量 可以被类直接调用，也可以使用对象调用<br>
实例变量:只能使用对象调用<br>
⑤判断是否可以调用<br>
---&gt;从生命周期的角度解释</p>
<p>类可以调用类变量 不能调用实例变量</p>
<p>对象都可以调用</p>
<p>消亡时机</p>
<p>静态变量 随着类的卸载而消亡</p>
<p>实例变量 随着对象的消亡而消亡</p>
</blockquote>
<p>static修饰方法:</p>
<p>(类方法、静态方法)</p>
<p>随着类的加载而加载</p>
<p>可以通过“类.静态方法"的方式，直接调用静态方法</p>
<p>静态方法内可以调用静态的属性和静态的方法 不可以调用非静态的结构</p>
<p>static 修饰的方法内不能使用 this 和 super</p>
<p>补充 在类的静态方法中 可以调用当前类中的静态结构（属性 方法）或非静态结构（属性 方法）</p>
<h3>静态变量（Static Variables）</h3>
<ol>
<li><strong>定义</strong>：静态变量是使用 <code class="notranslate">static</code> 关键字声明的变量，它属于类的静态成员，而不是类的某个特定对象。</li>
<li><strong>作用域</strong>：静态变量在类的所有实例之间共享，即所有实例共享同一个静态变量。</li>
<li><strong>生命周期</strong>：静态变量的生命周期与类本身相同，只要类被加载，静态变量就存在，直到程序结束。</li>
<li><strong>访问方式</strong>：可以通过类名直接访问静态变量，也可以通过实例访问。</li>
<li><strong>用途</strong>：通常用于存储类级别的信息，比如配置信息或者计数器等。</li>
</ol>
<h3>实例变量（Instance Variables）</h3>
<ol>
<li><strong>定义</strong>：实例变量是类中没有 <code class="notranslate">static</code> 关键字的成员变量，每个类的实例都有自己的一份实例变量。</li>
<li><strong>作用域</strong>：实例变量的作用域仅限于创建它的对象。</li>
<li><strong>生命周期</strong>：实例变量的生命周期与对象的生命周期相同，当对象被创建时实例变量被创建，对象被销毁时实例变量也被销毁。</li>
<li><strong>访问方式</strong>：通常通过对象的实例来访问实例变量。</li>
<li><strong>用途</strong>：用于存储对象特有的数据，每个对象的实例变量可以有不同的值。</li>
</ol>
<h3>区别</h3>
<ul>
<li><strong>存储位置</strong>：静态变量存储在方法区（或静态区），实例变量存储在堆内存中。</li>
<li><strong>访问限制</strong>：静态变量可以在没有创建类实例的情况下被访问，而实例变量必须通过对象实例来访问。</li>
<li><strong>内存分配</strong>：静态变量在内存中只有一个拷贝，而实例变量每个对象都有一个拷贝。</li>
<li><strong>使用场景</strong>：静态变量适用于不需要依赖于对象实例的数据，实例变量适用于需要依赖于对象实例的数据。</li>
<li></li>
</ul>
<p>开发中什么时候需要将属性声明为静态变量？</p>
<p>判断当前类的多个实例是否需要共享此成员变量，且此成员变量的值是相同的</p>
<p>开发中· 常将一些变量声明为静态的 比如 Math 类中的 PI</p>
<p>什么时候需要将方法声明为静态的？</p>
<p>方法内操作的变量如果都是静态变量而非实例变量 的话 则此方法建议声明为静态方法</p>
<p>开发中 常常将工具类的方法声明为静态</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ChineseTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 在没有对象前就可以调用</span>
        <span class="pl-smi">Chinese</span>.<span class="pl-en">show</span>();

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c</span>.<span class="pl-s1">name</span> = <span class="pl-s">"张三"</span>;
        <span class="pl-s1">c</span>.<span class="pl-s1">age</span> = <span class="pl-c1">20</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>();
        <span class="pl-s1">c2</span>.<span class="pl-s1">name</span> = <span class="pl-s">"李四"</span>;
        <span class="pl-s1">c2</span>.<span class="pl-s1">age</span> = <span class="pl-c1">30</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-s1">c2</span>.<span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>.<span class="pl-s1">country</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>.<span class="pl-s1">country</span>);

        <span class="pl-c">// 我们这里更改c2,可以发现c1的值也遭到了变更</span>
        <span class="pl-c">// 因为country是静态变量,属于类,不属于某个对象</span>

        <span class="pl-c">// 静态变量在内存中只有一份,被所有对象共享</span>
        <span class="pl-c">// 非静态变量在内存中有几份,取决于对象有多少份</span>
        <span class="pl-c">// 静态变量可以通过类名直接访问,也可以通过对象名访问</span>
        <span class="pl-c">// 非静态变量只能通过对象名访问</span>
        <span class="pl-c">// 静态变量和非静态变量,访问时,优先使用非静态变量</span>

    }
}

<span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {<span class="pl-c">// 中国人 类</span>
    <span class="pl-c">// 非静态变量,实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">// 静态变量,类变量</span>

    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span> = <span class="pl-s">"China"</span>;
    <span class="pl-c">// 非静态方法,实例方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sayHello</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"你好,我是"</span> + <span class="pl-s1">name</span>);
    }

    <span class="pl-c">// 快捷键alt insert</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">// return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span> + <span class="pl-s">"name="</span> + <span class="pl-s1">name</span> + <span class="pl-s">",age="</span> + <span class="pl-s1">age</span> + <span class="pl-s">"}"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"================"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是中国人"</span>);
        <span class="pl-c">// 调用静态的结构</span>
        <span class="pl-c">// 静态方法只能访问静态的结构</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">country</span>);
        <span class="pl-en">method1</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);

        <span class="pl-c">// 调用非静态的结构测试</span>
        <span class="pl-c">// System.out.println(this.name);</span>
        <span class="pl-c">//System.out.println(name);</span>

        <span class="pl-c">/*</span>
<span class="pl-c">         * Exception in thread "main" java.lang.Error: Unresolved compilation problem:</span>
<span class="pl-c">         * Cannot use this in a static context</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * at Chinese.show(ChineseTest.java:72)</span>
<span class="pl-c">         * at ChineseTest.main(ChineseTest.java:6)</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * </span>
<span class="pl-c">         * </span>
<span class="pl-c">         * 线程“main”java.lang中出现异常。错误：未解决的编译问题：</span>
<span class="pl-c">         * 不能在静态上下文中使用它</span>
<span class="pl-c">         * 在Chinese.show（中文测试java:72）上</span>
<span class="pl-c">         * 在ChineseTest.main（ChineseTest.java:6）</span>
<span class="pl-c">         */</span>

         <span class="pl-c">//this.eat("饺子");</span>

         <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"++++++++++++++++++++++"</span>);
         <span class="pl-en">method2</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method1</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是静态方法"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>(<span class="pl-smi">String</span> <span class="pl-s1">food</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我正在吃"</span>+<span class="pl-s1">food</span>);
    }
    <span class="pl-c">//非静态方法可以访问静态的和非静态的</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method2</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是非静态方法"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">country</span>);
        <span class="pl-en">method1</span>();
        <span class="pl-en">eat</span>(<span class="pl-s">"面条"</span>);
    }

}</pre></div>
<p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Circle</span>{
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">radius</span>;
    <span class="pl-k">public</span> <span class="pl-smi">Circle</span>(<span class="pl-smi">double</span> <span class="pl-s1">radius</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">radius</span>=<span class="pl-s1">radius</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">findArea</span>(){
        <span class="pl-k">return</span> <span class="pl-smi">Math</span>.<span class="pl-c1">PI</span>*<span class="pl-s1">radius</span>*<span class="pl-s1">radius</span>;
    }
}</pre></div>
<p>创建两个Circle对象：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Circle</span> <span class="pl-s1">c1</span>=<span class="pl-k">new</span> <span class="pl-smi">Circle</span>(<span class="pl-c1">2.0</span>);	<span class="pl-c">//c1.radius=2.0</span>
<span class="pl-smi">Circle</span> <span class="pl-s1">c2</span>=<span class="pl-k">new</span> <span class="pl-smi">Circle</span>(<span class="pl-c1">3.0</span>);	<span class="pl-c">//c2.radius=3.0</span></pre></div>
<p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p>
<p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p>
<h3>1.1 类属性、类方法的设计思想</h3>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<code class="notranslate">某些特定的数据在内存空间里只有一份</code>。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325213629311.png"><img src="images/image-20220325213629311.png" alt="" style="max-width: 100%;"></a></p>
<p>此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为<code class="notranslate">类方法</code>，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<p>这里的类变量、类方法，只需要使用<code class="notranslate">static</code>修饰即可。所以也称为静态变量、静态方法。</p>
<h3>1.2 static关键字</h3>
<ul>
<li>使用范围：
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li>被修饰后的成员具备以下特点：
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h3>1.3 静态变量</h3>
<h4>1.3.1 语法格式</h4>
<p>使用static修饰的成员变量就是静态变量（或类变量、类属性）</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 类{
    [其他修饰符] <span class="pl-k">static</span> 数据类型 变量名;
}</pre></div>
<h4>1.3.2 静态变量的特点</h4>
<ul>
<li>静态变量的默认值规则和实例变量一样。</li>
<li>静态变量值是所有对象共享。</li>
<li>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</li>
<li>如果权限修饰符允许，在其他类中可以通过“<code class="notranslate">类名.静态变量</code>”直接访问，也可以通过“<code class="notranslate">对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</li>
<li>静态变量的get/set方法也静态的，当局部变量与静态变量<code class="notranslate">重名时</code>，使用“<code class="notranslate">类名.静态变量</code>”进行区分。</li>
</ul>
<h4>1.3.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">AccountTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Account</span> <span class="pl-s1">a1</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a1</span>);

        <span class="pl-smi">Account</span> <span class="pl-s1">a2</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a2</span>);

        <span class="pl-smi">Account</span> <span class="pl-s1">a3</span> = <span class="pl-k">new</span> <span class="pl-smi">Account</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">a3</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"银行存款利率为"</span> + <span class="pl-smi">Account</span>.<span class="pl-en">getInterestRate</span>());

    }
    
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Account</span> {
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">Id</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">Password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">double</span> <span class="pl-s1">balance</span>;<span class="pl-c">//余额</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">double</span> <span class="pl-s1">interestRate</span>;<span class="pl-c">//利率</span>

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">init</span> = <span class="pl-c1">1001</span>;<span class="pl-c">//账户数量</span>

    <span class="pl-k">public</span> <span class="pl-smi">Account</span>() {
        <span class="pl-s1">Id</span> = <span class="pl-s1">init</span>++;
        <span class="pl-s1">Password</span> = <span class="pl-s">"123456"</span>;
        <span class="pl-s1">balance</span> = <span class="pl-c1">0.0</span>;
        <span class="pl-s1">interestRate</span> = <span class="pl-c1">0.3</span>;
        
    }
    <span class="pl-k">public</span> <span class="pl-smi">Account</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>, <span class="pl-smi">double</span> <span class="pl-s1">balance</span>) {
        <span class="pl-s1">Id</span> = <span class="pl-s1">init</span>++;
        <span class="pl-s1">Password</span> = <span class="pl-s1">password</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">balance</span> = <span class="pl-s1">balance</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getId</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">Id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setId</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>) {
        <span class="pl-s1">Id</span> = <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">Password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-s1">Password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">double</span> <span class="pl-en">getInterestRate</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">interestRate</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-c">// TODO Auto-generated method stub</span>
        <span class="pl-c">//return super.toString();</span>
        <span class="pl-k">return</span> <span class="pl-s">"Account {Id="</span> + <span class="pl-s1">Id</span> + <span class="pl-s">", Password="</span> + <span class="pl-s1">Password</span> + <span class="pl-s">", balance="</span> + <span class="pl-s1">balance</span> + <span class="pl-s">"}"</span>;
    }

    

}</pre></div>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Chinese</span>{
    <span class="pl-c">//实例变量</span>
    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;
    <span class="pl-c">//类变量</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">nation</span>;<span class="pl-c">//国籍</span>

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>() {
    }

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Chinese{"</span> +
                <span class="pl-s">"name='"</span> + <span class="pl-s1">name</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">", age="</span> + <span class="pl-s1">age</span> +
                <span class="pl-s">", nation='"</span> + <span class="pl-s1">nation</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">'}'</span>;
    }
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StaticTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c1</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"康师傅"</span>,<span class="pl-c1">36</span>);
        <span class="pl-s1">c1</span>.<span class="pl-s1">nation</span> = <span class="pl-s">"中华人民共和国"</span>;

        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"老干妈"</span>,<span class="pl-c1">66</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c1</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c2</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Chinese</span>.<span class="pl-s1">nation</span>);
    }
}</pre></div>
<p>对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）</p>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Employee</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">total</span>;<span class="pl-c">//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">company</span>; <span class="pl-c">//这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问</span>
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">id</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Employee</span>() {
        <span class="pl-s1">total</span>++;
        <span class="pl-s1">id</span> = <span class="pl-s1">total</span>;<span class="pl-c">//这里使用total静态变量的值为id属性赋值</span>
    }

    <span class="pl-k">public</span> <span class="pl-smi">Employee</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setId</span>(<span class="pl-smi">int</span> <span class="pl-s1">id</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">id</span> = <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getId</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">id</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getTotal</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">total</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">setTotal</span>(<span class="pl-smi">int</span> <span class="pl-s1">total</span>) {
        <span class="pl-smi">Employee</span>.<span class="pl-s1">total</span> = <span class="pl-s1">total</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Employee{company = "</span> + <span class="pl-s1">company</span> + <span class="pl-s">",id = "</span> + <span class="pl-s1">id</span> + <span class="pl-s">" ,name="</span> + <span class="pl-s1">name</span> +<span class="pl-s">"}"</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticVariable</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//静态变量total的默认值是0</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Employee.total = "</span> + <span class="pl-smi">Employee</span>.<span class="pl-en">getTotal</span>());

        <span class="pl-smi">Employee</span> <span class="pl-s1">e1</span> = <span class="pl-k">new</span> <span class="pl-smi">Employee</span>(<span class="pl-s">"张三"</span>);
        <span class="pl-smi">Employee</span> <span class="pl-s1">e2</span> = <span class="pl-k">new</span> <span class="pl-smi">Employee</span>(<span class="pl-s">"李四"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的默认值是null</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的默认值是null</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Employee.total = "</span> + <span class="pl-smi">Employee</span>.<span class="pl-en">getTotal</span>());<span class="pl-c">//静态变量total值是2</span>

        <span class="pl-smi">Employee</span>.<span class="pl-s1">company</span> = <span class="pl-s">"尚硅谷"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的值是尚硅谷</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的值是尚硅谷</span>

        <span class="pl-c">//只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问</span>
        <span class="pl-s1">e1</span>.<span class="pl-s1">company</span> = <span class="pl-s">"超级尚硅谷"</span>;

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e1</span>);<span class="pl-c">//静态变量company的值是超级尚硅谷</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">e2</span>);<span class="pl-c">//静态变量company的值是超级尚硅谷</span>
    }
}</pre></div>
<h3>1.4 静态方法</h3>
<h4>1.4.1 语法格式</h4>
<p>用static修饰的成员方法就是静态方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 类{
    [其他修饰符] <span class="pl-k">static</span> 返回值类型 方法名(形参列表){
        方法体
    }
}</pre></div>
<h4>1.4.2 静态方法的特点</h4>
<ul>
<li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li>
<li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li>
<li>静态方法可以被子类继承，但不能被子类重写。</li>
<li>静态方法的调用都只看编译时类型。</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li>
</ul>
<h4>1.4.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.method"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">fun</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Father.fun"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
<span class="pl-c">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">fun</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Son.fun"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticMethod</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Father</span>.<span class="pl-en">method</span>();
        <span class="pl-smi">Son</span>.<span class="pl-en">method</span>();<span class="pl-c">//继承静态方法</span>

        <span class="pl-smi">Father</span> <span class="pl-s1">f</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">f</span>.<span class="pl-en">method</span>();<span class="pl-c">//执行Father类中的method</span>
    }
}</pre></div>
<h3>1.5 练习</h3>
<p>笔试题：如下程序执行会不会报错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * @author 尚硅谷-宋红康</span>
<span class="pl-c"> * @create 14:30</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">StaticTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Demo</span> <span class="pl-s1">test</span> = <span class="pl-c1">null</span>;
        <span class="pl-s1">test</span>.<span class="pl-en">hello</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">Demo</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">hello</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"hello!"</span>);
    }
}</pre></div>
<p>练习：</p>
<p>编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。<code class="notranslate">账号要自动生成。</code></p>
<p>编写主类，使用银行账户类，输入、输出3个储户的上述信息。</p>
<p>考虑：哪些属性可以设计成static属性。</p>
<h2>2. 单例(Singleton)设计模式</h2>
<h3>2.1 设计模式概述</h3>
<p><strong>设计模式</strong>是在大量的<code class="notranslate">实践中总结</code>和<code class="notranslate">理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。"套路"</p>
<p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。</p>
<blockquote>
<p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版</p>
</blockquote>
<blockquote>
<p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为"四人组（Gang of Four）"，而这本书也就被称为"四人组（或 GoF）"书。</p>
</blockquote>
<p>经典的设计模式一共有 23 种</p>
<h3>2.2 何为单例模式</h3>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<h3>2.3 实现思路</h3>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code class="notranslate">类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code class="notranslate">只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code class="notranslate">该类对象的变量也必须定义成静态的</code>。</p>
<h3>2.4 单例模式的两种实现方式</h3>
<h4>2.4.1 饿汉式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Singleton</span> {
    <span class="pl-c">// 1.私有化构造器</span>
    <span class="pl-k">private</span> <span class="pl-smi">Singleton</span>() {
    }

    <span class="pl-c">// 2.内部提供一个当前类的实例</span>
    <span class="pl-c">// 4.此实例也必须静态化</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-s1">single</span> = <span class="pl-k">new</span> <span class="pl-smi">Singleton</span>();

    <span class="pl-c">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">single</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Banktest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 单例模式</span>
        <span class="pl-smi">Bank</span> <span class="pl-s1">bank</span> = <span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>();
                <span class="pl-smi">Bank</span> <span class="pl-s1">bank1</span> = <span class="pl-smi">Bank</span>.<span class="pl-en">getInstance</span>();
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">bank</span> == <span class="pl-s1">bank1</span>);
                <span class="pl-c">//输出为true</span>
                
        
            }
        
        }
        <span class="pl-c">//饿汉式</span>
        <span class="pl-k">class</span> <span class="pl-smi">Bank</span> {
            <span class="pl-c">// 私有化构造方法</span>
            <span class="pl-k">private</span> <span class="pl-smi">Bank</span>() {
        
            }
        
            <span class="pl-c">// 在类中创建当前类的实例</span>
            <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-s1">instance</span> = <span class="pl-k">new</span> <span class="pl-smi">Bank</span>();
        
            <span class="pl-c">// 对外提供公共的访问方法</span>
            <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Bank</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">instance</span>;
    }

}</pre></div>
<h4>2.4.2 懒汉式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Singleton</span> {
    <span class="pl-c">// 1.私有化构造器</span>
    <span class="pl-k">private</span> <span class="pl-smi">Singleton</span>() {
    }
    <span class="pl-c">// 2.内部提供一个当前类的实例</span>
    <span class="pl-c">// 4.此实例也必须静态化</span>
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-s1">single</span>;
    <span class="pl-c">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Singleton</span> <span class="pl-en">getInstance</span>() {
        <span class="pl-k">if</span>(<span class="pl-s1">single</span> == <span class="pl-c1">null</span>) {
            <span class="pl-s1">single</span> = <span class="pl-k">new</span> <span class="pl-smi">Singleton</span>();
        }
        <span class="pl-k">return</span> <span class="pl-s1">single</span>;
    }
}</pre></div>
<h4>2.4.3 饿汉式 vs 懒汉式</h4>
<p>饿汉式：</p>
<ul>
<li>特点：<code class="notranslate">立即加载</code>，即在使用类的时候已经将对象创建完毕。</li>
<li>优点：实现起来<code class="notranslate">简单</code>；没有多线程安全问题。</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code class="notranslate">耗费内存</code>。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code class="notranslate">延迟加载</code>，即在调用静态方法时实例才被创建。</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code class="notranslate">节约内存</code>。</li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code class="notranslate">线程不安全</code>，根本不能保证单例的唯一性。
<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li>
</ul>
</li>
</ul>
<p>4.对比两种模式(特点、优缺点)<br>
特点:</p>
<blockquote>
<p>饿汉式:"立即加载”,随着类的加载，当前的唯一实例就创建了<br>
懒汉式:"延迟加载"在需要使用的时候，进行创建。<br>
优缺点:<br>
饿汉式:<br>
(优点)写法简单，由于内存中较早加载，使用更方便、更快。是线程安全的。<br>
(缺点)内存中占用时间较长。<br>
懒汉式:<br>
(缺点)线程不安全(放到多线程章节时解决)(优点)在需要的时候进行创建，节省内存空间。</p>
</blockquote>
<p>饿汉式生命周期过长，容易造成资源浪费，但是能保证线程安全，面试优先写饿汉式</p>
<h3>2.5 单例模式的优点及应用场景</h3>
<p>由于单例模式只生成一个实例，减少了<code class="notranslate">系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<p>举例：</p>
<p><strong>应用场景</strong></p>
<ul>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li>Application 也是单例的典型应用</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
</ul>
<h2>3. 理解main方法的语法</h2>
<p>由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>
<p><strong>命令行参数用法举例</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CommandPara</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"args["</span> + <span class="pl-s1">i</span> + <span class="pl-s">"] = "</span> + <span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//运行程序CommandPara.java</span>
<span class="pl-smi">java</span> <span class="pl-s1">CommandPara</span> <span class="pl-s">"Tom"</span> <span class="pl-s">"Jerry"</span> <span class="pl-s">"Shkstart"</span></pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//输出结果</span>
<span class="pl-s1">args</span>[<span class="pl-c1">0</span>] = <span class="pl-smi">Tom</span>
<span class="pl-s1">args</span>[<span class="pl-c1">1</span>] = <span class="pl-smi">Jerry</span>
<span class="pl-s1">args</span>[<span class="pl-c1">2</span>] = <span class="pl-s1">Shkstart</span></pre></div>
<p>main()方法的剖析</p>
<p>public static void main(String args[]){}</p>
<p>1.理解1:看做是一个普通的静态方法</p>
<p>理解2:看做是程序的入口，格式是固定的</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 程序的入口</span>
        <span class="pl-c">// TODO Auto-generated method stub</span>

        <span class="pl-smi">String</span>[] <span class="pl-s1">args1</span> = { <span class="pl-s">"a"</span>, <span class="pl-s">"b"</span>, <span class="pl-s">"c"</span> };
        <span class="pl-smi">MainTest</span>.<span class="pl-en">Test</span>(<span class="pl-s1">args1</span>);

    }
}

<span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 看作普通方方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }

}</pre></div>
<h3>1. <code class="notranslate">Main</code> 类（了解）</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { <span class="pl-c">// 程序的入口</span>
        <span class="pl-c">// TODO Auto-generated method stub</span>

        <span class="pl-smi">String</span>[] <span class="pl-s1">args1</span> = { <span class="pl-s">"a"</span>, <span class="pl-s">"b"</span>, <span class="pl-s">"c"</span> };
        <span class="pl-smi">MainTest</span>.<span class="pl-en">Test</span>(<span class="pl-s1">args1</span>);
    }
}</pre></div>
<ul>
<li><code class="notranslate">public class Main</code>: 定义了一个名为 <code class="notranslate">Main</code> 的公共类。在 Java 中，每个程序至少需要一个类，并且通常这个类包含 <code class="notranslate">main</code> 方法作为程序的入口点。</li>
<li><code class="notranslate">public static void main(String[] args)</code>: 这是 Java 程序的主入口点。当程序启动时，JVM 会调用这个方法。<code class="notranslate">public</code> 表示这个方法是公共的，可以从外部访问；<code class="notranslate">static</code> 表示这个方法属于类本身而不是类的实例；<code class="notranslate">void</code> 表示这个方法不返回任何值；<code class="notranslate">String[] args</code> 是一个字符串数组，用于接收命令行参数。</li>
<li><code class="notranslate">String[] args1 = { "a", "b", "c" };</code>: 定义了一个字符串数组 <code class="notranslate">args1</code>，并初始化为包含三个元素 <code class="notranslate">"a"</code>、<code class="notranslate">"b"</code> 和 <code class="notranslate">"c"</code>。</li>
<li><code class="notranslate">MainTest.Test(args1);</code>: 调用 <code class="notranslate">MainTest</code> 类中的 <code class="notranslate">Test</code> 方法，并将 <code class="notranslate">args1</code> 作为参数传递给它。</li>
</ul>
<h3>2. <code class="notranslate">MainTest</code> 类</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { <span class="pl-c">// 看作普通方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }
}</pre></div>
<ul>
<li><code class="notranslate">class MainTest</code>: 定义了一个名为 <code class="notranslate">MainTest</code> 的类。这个类不是公共的，所以只能在同一文件中访问。</li>
<li><code class="notranslate">public static void Test(String[] args)</code>: 定义了一个静态方法 <code class="notranslate">Test</code>，它接受一个字符串数组 <code class="notranslate">args</code> 作为参数。<code class="notranslate">public</code> 表示这个方法是公共的，可以从外部访问；<code class="notranslate">static</code> 表示这个方法属于类本身而不是类的实例；<code class="notranslate">void</code> 表示这个方法不返回任何值；<code class="notranslate">String[] args</code> 是一个字符串数组，用于接收传入的参数。</li>
<li><code class="notranslate">System.out.println("Main的MainTest()调用");</code>: 输出字符串 <code class="notranslate">"Main的MainTest()调用"</code> 到控制台。</li>
<li><code class="notranslate">for (int i = 0; i &lt; args.length; i++)</code>: 使用一个 <code class="notranslate">for</code> 循环遍历传入的字符串数组 <code class="notranslate">args</code>。<code class="notranslate">args.length</code> 返回数组的长度。</li>
<li><code class="notranslate">System.out.println(args[i]);</code>: 在循环体内，输出数组 <code class="notranslate">args</code> 的第 <code class="notranslate">i</code> 个元素到控制台。</li>
</ul>
<h3>总结</h3>
<ul>
<li><code class="notranslate">Main</code>** 类** 包含了程序的入口点 <code class="notranslate">main</code> 方法。在这个方法中，创建了一个字符串数组 <code class="notranslate">args1</code> 并调用了 <code class="notranslate">MainTest</code> 类中的 <code class="notranslate">Test</code> 方法。</li>
<li><code class="notranslate">MainTest</code>** 类** 包含了一个静态方法 <code class="notranslate">Test</code>，这个方法接收一个字符串数组作为参数，并打印出数组中的每一个元素。</li>
</ul>
<p>运行输出是：</p>
<pre lang="plain" class="notranslate"><code class="notranslate">Main的MainTest()调用
a
b
c
</code></pre>
<p>2.与控制台交互</p>
<p>如何从键盘获取数据？</p>
<ul>
<li>方式一 使用 Scanner</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Scanner</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">scanner</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建Scanner对象，用于获取键盘输入</span>
        <span class="pl-smi">Scanner</span> <span class="pl-s1">scanner</span> = <span class="pl-k">new</span> <span class="pl-smi">Scanner</span>(<span class="pl-smi">System</span>.<span class="pl-s1">in</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"name："</span>);
        <span class="pl-c">// 调用next()方法读取一行文本（不包括换行符）</span>
        <span class="pl-smi">String</span> <span class="pl-s1">name</span> = <span class="pl-s1">scanner</span>.<span class="pl-en">next</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"age："</span>);
        <span class="pl-c">// 调用nextInt()方法读取一个整数</span>
        <span class="pl-smi">int</span> <span class="pl-s1">age</span> = <span class="pl-s1">scanner</span>.<span class="pl-en">nextInt</span>();

        <span class="pl-c">// 输出获取到的信息</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"name："</span> + <span class="pl-s1">name</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"age："</span> + <span class="pl-s1">age</span>);
        <span class="pl-c">// 关闭Scanner对象</span>
        <span class="pl-s1">scanner</span>.<span class="pl-en">close</span>();
    }
}</pre></div>
<ul>
<li>方式二 使用 main() 的形式传递值</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">MainTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">Test</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {<span class="pl-c">// 看作普通方方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Main的MainTest()调用"</span>);
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">args</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">args</span>[<span class="pl-s1">i</span>]);
        }
    }

}</pre></div>
<blockquote>
<p>javac MainTest.java</p>
<p>java MainTest "Tom" Jerry aa 11 22</p>
</blockquote>
<h4>如此 可在命令行中传参</h4>
<p>在 idea 中可以自定义启动参数 run-Edit Config。。。-Choose Class（选择类）-Program arguments</p>
<h2>4. 类的成员之四：代码块</h2>
<p>回顾:类中可以声明的结构:属性、方法、构造器:代码块(或初始化块)、内部类</p>
<p>1.代码块(或初始化块)的使用</p>
<p>用来初始化类或对象的信息(即初始化类或对象的成员变量)</p>
<p>代码块的修饰:</p>
<p>只能使用static进行修饰。</p>
<p>3.代码块的分类:</p>
<p>静态代码块:使用static修饰</p>
<p>非静态代码块:没有使用static修饰</p>
<p>具体使用:</p>
<p>4.1 静态代码块:</p>
<ul>
<li>随着类的加载而调用</li>
<li>由于类的加载只会执行一次，所以静态代码块只会执行一次</li>
<li>作用：用来初始化类的信息</li>
<li>内部类可以声明变量 调用属性或方法 编写输出语句等操作</li>
<li>声明多个静态代码块按照声明先后执行</li>
<li>静态代码块只能调用静态的结构（静态的属性，方法），不能调用非静态的结构（非静态的属性或方法）</li>
</ul>
<p>4.2 非静态代码块:</p>
<ul>
<li>随着对象的创建而执行</li>
<li>每创建当前类的一个实例就会执行一次</li>
<li>作用：用于初始化对象的信息</li>
<li>内部类可以声明变量 调用属性或方法 编写输出语句等操作</li>
<li>非静态代码块可以调用静态结构，也可以调用非静态的结构</li>
</ul>
<p><strong>静态代码块优先于非静态代码块执行</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//非静态代码块</span>
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person代码块"</span>);
    }
    <span class="pl-c">//静态代码块</span>
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person静态代码块"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//非静态代码块</span>
    <span class="pl-c">//随着对象的创建而执行</span>
    <span class="pl-c">//每创建一个对象，执行一次</span>
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person代码块"</span>);
    }

    <span class="pl-c">//静态代码块</span>
    <span class="pl-c">//随着类的加载而执行</span>
    <span class="pl-c">//只执行一次</span>
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Person静态代码块"</span>);
    }
    <span class="pl-c">//静态代码块优先执行</span>
    <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">info</span>=<span class="pl-s">"我是一个人"</span>;
}</pre></div>
<p>如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。</p>
<ul>
<li>代码块(或初始化块)的<code class="notranslate">作用</code>：</li>
<li>对Java类或对象进行初始化</li>
<li>代码块(或初始化块)的<code class="notranslate">分类</code>：
<ul>
<li>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)</li>
<li>没有使用static修饰的，为非静态代码块。</li>
</ul>
</li>
</ul>
<h3>4.1 静态代码块</h3>
<p>如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。</p>
<h4>4.1.1 语法格式</h4>
<p>在代码块的前面加static，就是静态代码块。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 类{
    <span class="pl-k">static</span>{
        静态代码块
    }
}</pre></div>
<h4>4.1.2 静态代码块的特点</h4>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Chinese</span> {
<span class="pl-c">//    private static String country = "中国";</span>

    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">country</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"非静态代码块，country = "</span> + <span class="pl-s1">country</span>);
    }

    <span class="pl-k">static</span> {
        <span class="pl-s1">country</span> = <span class="pl-s">"中国"</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"静态代码块"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Chinese</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">keyword</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestStaticBlock</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c1</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"张三"</span>);
        <span class="pl-smi">Chinese</span> <span class="pl-s1">c2</span> = <span class="pl-k">new</span> <span class="pl-smi">Chinese</span>(<span class="pl-s">"李四"</span>);
    }
}</pre></div>
<h3>4.2 非静态代码块</h3>
<h4>4.2.1 语法格式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 类{
    {
        非静态代码块
    }
    【修饰符】 构造器名(){
        <span class="pl-c">// 实例初始化代码</span>
    }
    【修饰符】 构造器名(参数列表){
        <span class="pl-c">// 实例初始化代码</span>
    }
}</pre></div>
<h4>4.2.2 非静态代码块的作用</h4>
<p>和构造器一样，也是用于实例变量的初始化等操作。</p>
<h4>4.2.3 非静态代码块的意义</h4>
<p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p>
<h4>4.2.4 非静态代码块的执行特点</h4>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
<h3>4.3 举例</h3>
<p><strong>举例1：</strong></p>
<p>（1）声明User类，</p>
<ul>
<li>包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化</li>
<li>包含get/set方法，其中registrationTime没有set方法</li>
<li>包含无参构造，
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username就默认为当前系统时间值，</li>
<li>password默认为“123456”</li>
</ul>
</li>
<li>包含有参构造(String username, String password)，
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username和password由参数赋值</li>
</ul>
</li>
<li>包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”</li>
</ul>
<p>（2）编写测试类，测试类main方法的代码如下：</p>
<div class="highlight highlight-source-java"><pre class="notranslate">    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-s1">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">User</span> <span class="pl-s1">u1</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">u1</span>.<span class="pl-en">getInfo</span>());

        <span class="pl-smi">User</span> <span class="pl-s1">u2</span> = <span class="pl-k">new</span> <span class="pl-smi">User</span>(<span class="pl-s">"song"</span>,<span class="pl-s">"8888"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">u2</span>.<span class="pl-en">getInfo</span>());
    }</pre></div>
<p>如果不用非静态代码块，User类是这样的：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">block</span>.<span class="pl-s1">no</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">long</span> <span class="pl-s1">registrationTime</span>;

    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-s1">username</span> = <span class="pl-s1">registrationTime</span>+<span class="pl-s">""</span>;
        <span class="pl-s1">password</span> = <span class="pl-s">"123456"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>,<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">long</span> <span class="pl-en">getRegistrationTime</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">registrationTime</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>(){
        <span class="pl-k">return</span> <span class="pl-s">"用户名："</span> + <span class="pl-s1">username</span> + <span class="pl-s">"，密码："</span> + <span class="pl-s1">password</span> + <span class="pl-s">"，注册时间："</span> + <span class="pl-s1">registrationTime</span>;
    }
}</pre></div>
<p>如果提取构造器公共代码到非静态代码块，User类是这样的：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">block</span>.<span class="pl-s1">use</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">User</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">username</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">password</span>;
    <span class="pl-k">private</span> <span class="pl-smi">long</span> <span class="pl-s1">registrationTime</span>;

    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"新用户注册"</span>);
        <span class="pl-s1">registrationTime</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>() {
        <span class="pl-s1">username</span> = <span class="pl-s1">registrationTime</span>+<span class="pl-s">""</span>;
        <span class="pl-s1">password</span> = <span class="pl-s">"123456"</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">User</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>, <span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getUsername</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setUsername</span>(<span class="pl-smi">String</span> <span class="pl-s1">username</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">username</span> = <span class="pl-s1">username</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getPassword</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">setPassword</span>(<span class="pl-smi">String</span> <span class="pl-s1">password</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">password</span> = <span class="pl-s1">password</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">long</span> <span class="pl-en">getRegistrationTime</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">registrationTime</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getInfo</span>(){
        <span class="pl-k">return</span> <span class="pl-s">"用户名："</span> + <span class="pl-s1">username</span> + <span class="pl-s">"，密码："</span> + <span class="pl-s1">password</span> + <span class="pl-s">"，注册时间："</span> + <span class="pl-s1">registrationTime</span>;
    }
}</pre></div>
<p><strong>举例2：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">DataSource</span> <span class="pl-s1">dataSource</span> = <span class="pl-c1">null</span>;

<span class="pl-k">static</span>{
    <span class="pl-smi">InputStream</span> <span class="pl-s1">is</span> = <span class="pl-c1">null</span>;
    <span class="pl-k">try</span> {
        <span class="pl-s1">is</span> = <span class="pl-smi">DBCPTest</span>.<span class="pl-k">class</span>.<span class="pl-en">getClassLoader</span>().<span class="pl-en">getResourceAsStream</span>(<span class="pl-s">"dbcp.properties"</span>);
        <span class="pl-smi">Properties</span> <span class="pl-s1">pros</span> = <span class="pl-k">new</span> <span class="pl-smi">Properties</span>();
        <span class="pl-s1">pros</span>.<span class="pl-en">load</span>(<span class="pl-s1">is</span>);
        <span class="pl-c">//调用BasicDataSourceFactory的静态方法，获取数据源。</span>
        <span class="pl-s1">dataSource</span> = <span class="pl-smi">BasicDataSourceFactory</span>.<span class="pl-en">createDataSource</span>(<span class="pl-s1">pros</span>);
    } <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> <span class="pl-s1">e</span>) {
        <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
    }<span class="pl-k">finally</span>{
        <span class="pl-k">if</span>(<span class="pl-s1">is</span> != <span class="pl-c1">null</span>){
            <span class="pl-k">try</span> {
                <span class="pl-s1">is</span>.<span class="pl-en">close</span>();
            } <span class="pl-k">catch</span> (<span class="pl-smi">IOException</span> <span class="pl-s1">e</span>) {
                <span class="pl-s1">e</span>.<span class="pl-en">printStackTrace</span>();
            }		
        }		
    }		
}</pre></div>
<h3>4.4 小结：实例变量赋值顺序</h3>
<h3>4.5 练习</h3>
<p>练习1：分析加载顺序</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Root</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的普通初始化块"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Root</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Root的无参数的构造器"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Mid</span> <span class="pl-k">extends</span> <span class="pl-smi">Root</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的普通初始化块"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Mid</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的无参数的构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Mid</span>(<span class="pl-smi">String</span> <span class="pl-s1">msg</span>){
        <span class="pl-c">//通过this调用同一类中重载的构造器</span>
        <span class="pl-smi">this</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Mid的带参数构造器，其参数值："</span>
            + <span class="pl-s1">msg</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Leaf</span> <span class="pl-k">extends</span> <span class="pl-smi">Mid</span>{
    <span class="pl-k">static</span>{
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的静态初始化块"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的普通初始化块"</span>);
    }	
    <span class="pl-k">public</span> <span class="pl-smi">Leaf</span>(){
        <span class="pl-c">//通过super调用父类中有一个字符串参数的构造器</span>
        <span class="pl-en">super</span>(<span class="pl-s">"尚硅谷"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Leaf的构造器"</span>);
    }
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">LeafTest</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-k">new</span> <span class="pl-smi">Leaf</span>(); 
        <span class="pl-c">//new Leaf();</span>
    }
}</pre></div>
<p>练习2：分析加载顺序</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">static</span> {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"11111111111"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"22222222222"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Father</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"33333333333"</span>);

    }

}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">static</span> {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"44444444444"</span>);
    }
    {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"55555555555"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">Son</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"66666666666"</span>);
    }


    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) { 
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"77777777777"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);
        <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);

        <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"************************"</span>);
        <span class="pl-k">new</span> <span class="pl-smi">Father</span>();
    }

}</pre></div>
<p>练习3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu05</span>.<span class="pl-s1">field</span>.<span class="pl-s1">interview</span>;

<span class="pl-c">/**</span>
<span class="pl-c"> * @author 尚硅谷-宋红康</span>
<span class="pl-c"> * @create 16:04</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test04</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Zi</span> <span class="pl-s1">zi</span> = <span class="pl-k">new</span> <span class="pl-smi">Zi</span>();
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Fu</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（1）i"</span>);
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">j</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（2）j"</span>);
    <span class="pl-k">static</span>{
        <span class="pl-en">print</span>(<span class="pl-s">"（3）父类静态代码块"</span>);
    }
    {
        <span class="pl-en">print</span>(<span class="pl-s">"（4）父类非静态代码块，又称为构造代码块"</span>);
    }
    <span class="pl-smi">Fu</span>(){
        <span class="pl-en">print</span>(<span class="pl-s">"（5）父类构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span> + <span class="pl-s">"-&gt;"</span> + <span class="pl-s1">i</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getNum</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-en">print</span>(<span class="pl-s1">str</span>);
        <span class="pl-k">return</span> ++<span class="pl-s1">i</span>;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Zi</span> <span class="pl-k">extends</span> <span class="pl-smi">Fu</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">k</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（6）k"</span>);
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">h</span> = <span class="pl-en">getNum</span>(<span class="pl-s">"（7）h"</span>);
    <span class="pl-k">static</span>{
        <span class="pl-en">print</span>(<span class="pl-s">"（8）子类静态代码块"</span>);
    }
    {
        <span class="pl-en">print</span>(<span class="pl-s">"（9）子类非静态代码块，又称为构造代码块"</span>);
    }
    <span class="pl-smi">Zi</span>(){
        <span class="pl-en">print</span>(<span class="pl-s">"（10）子类构造器"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">str</span> + <span class="pl-s">"-&gt;"</span> + <span class="pl-s1">k</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-en">getNum</span>(<span class="pl-smi">String</span> <span class="pl-s1">str</span>){
        <span class="pl-en">print</span>(<span class="pl-s1">str</span>);
        <span class="pl-k">return</span> ++<span class="pl-s1">k</span>;
    }
}</pre></div>
<h3>总结 - 属性赋值的过程</h3>
<p>1.可以给类的非静态的属性(即实例变量)赋值的位置有:</p>
<p>① 默认初始化</p>
<p>② 显式初始化</p>
<p>③ 构造器中初始化</p>
<p>⑤ 代码块中初始化</p>
<p>##########################</p>
<p>④ 有了对象以后，通过"对象.属性"或"对象,方法"的方法进行赋值</p>
<p>2.执行的先后顺序:</p>
<p>1-2/5-3-4</p>
<h5>(超纲)关于字节码文件中的的简单说明:(通过插件jclasslib bytecode viewer查看)</h5>
<p>方法可以在字节码文件中看到 每个方法都有对应着一个类的构造器 （类中声明了几个构造器久游几个）</p>
<p>方法内部代码包含了实例变量的显示赋值 代码块中的赋值和构造器中的代码</p>
<p>方法用来初始化当前创建对象的信息的</p>
<p>给实例变量赋值的位置很多，开发中如何选?</p>
<p>需求分析（废话）</p>
<p>显示赋值，比较于每个对象的属性值相同的场景</p>
<p>构造器中赋值，比较适合于每个对象属性值不同的场景</p>
<h2>5. final关键字</h2>
<h3>5.1 final的意义</h3>
<p>final：最终的，不可更改的</p>
<h3>5.2 final的使用</h3>
<h4>5.2.1 final修饰类</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span>{
    
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> <span class="pl-k">extends</span> <span class="pl-smi">A</span>{
    <span class="pl-c">//正常来讲可以用B继承A</span>
}
<span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">C</span>{
    
}
<span class="pl-k">class</span> <span class="pl-smi">D</span> <span class="pl-k">extends</span> <span class="pl-smi">C</span>{
    <span class="pl-c">//正常来讲可以用D继承C</span>
    <span class="pl-c">//报错</span>
    <span class="pl-c">//使用final修饰的类不能被继承</span>
}</pre></div>
<p>表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">Eunuch</span>{<span class="pl-c">//太监类</span>
    
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Eunuch</span>{<span class="pl-c">//错误</span>
    
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">E</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">show2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show2"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">F</span> <span class="pl-k">extends</span> <span class="pl-smi">E</span>{
    <span class="pl-c">//正常来讲可以用F继承E</span>
    <span class="pl-c">//使用final修饰的方法不能被重写</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"show2"</span>);
    }
}</pre></div>
<h4>5.2.2 final修饰方法</h4>
<p>表示这个方法不能被子类重写。</p>
<p>例如：Object类中的getClass()</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"father"</span>);
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){<span class="pl-c">//错误</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"son"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// final修饰的变量是常量</span>
<span class="pl-k">class</span> <span class="pl-smi">FinalTest2</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
        <span class="pl-c">// a=20;不能修改</span>
        <span class="pl-c">// final修饰的变量必须初始化</span>
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">b</span> = <span class="pl-c1">10</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"____________________"</span>);
        <span class="pl-s1">b</span> = <span class="pl-c1">20</span>;<span class="pl-c">// 不能修改 报错</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">b</span>);
        <span class="pl-c">/*</span>
<span class="pl-c">         * cworkspaceStorage\x5ce79013143972bf905b0cf9274b6425dd\x5credhat.java\</span>
<span class="pl-c">         * x5cjdt_ws\x5c1_6f9ffb3d\x5cbin' 'FinalTest2'</span>
<span class="pl-c">         * ;f0033315-a209-4a07-8e6e-2f27dcd3450eException in thread "main"</span>
<span class="pl-c">         * java.lang.Error: Unresolved compilatio</span>
<span class="pl-c">         * n problem:</span>
<span class="pl-c">         * The final local variable b cannot be assigned. It must be blank and not using</span>
<span class="pl-c">         * a compound assignment</span>
<span class="pl-c">         * </span>
<span class="pl-c">         * at FinalTest2.main(FinalTest.java:45)</span>
<span class="pl-c">         * PS C:\code\java\Week2\1&gt;</span>
<span class="pl-c">         */</span>
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">FinalTest3</span> {
    <span class="pl-c">//final修饰的变量可以在初始化时赋值</span>
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">a</span>;
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">b</span> = <span class="pl-c1">10</span>;
    <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">c</span>;
    <span class="pl-c">//也可以在构造器中赋值</span>
    <span class="pl-k">public</span> <span class="pl-smi">FinalTest3</span>() {
        <span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
    }

    <span class="pl-c">//还可以在代码块中赋值</span>
    {
        <span class="pl-s1">c</span> = <span class="pl-c1">10</span>;
    }  
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//final和static搭配</span>
<span class="pl-c">//修饰的变量是常量，称为全局常量</span>
<span class="pl-k">class</span> <span class="pl-smi">FinalTest4</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">FinalTest4</span>.<span class="pl-c1">NUM</span>);
        <span class="pl-c">//NUM=20;不能修改</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">NUM</span> = <span class="pl-c1">10</span>;
}</pre></div>
<h4>5.2.3 final修饰变量</h4>
<p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。</p>
<p>例如：final double MY_PI = 3.14;</p>
<blockquote>
<p>如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</p>
</blockquote>
<ul>
<li>修饰成员变量</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">int</span> <span class="pl-s1">totalNumber</span> = <span class="pl-c1">5</span>;
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">ID</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Test</span>() {
        <span class="pl-c1">ID</span> = ++<span class="pl-s1">totalNumber</span>; <span class="pl-c">// 可在构造器中给final修饰的“变量”赋值</span>
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Test</span> <span class="pl-s1">t</span> = <span class="pl-k">new</span> <span class="pl-smi">Test</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">t</span>.<span class="pl-c1">ID</span>);
    }
}</pre></div>
<ul>
<li>修饰局部变量：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestFinal</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MIN_SCORE</span> ;
        <span class="pl-c1">MIN_SCORE</span> = <span class="pl-c1">0</span>;
        <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MAX_SCORE</span> = <span class="pl-c1">100</span>;
        <span class="pl-c1">MAX_SCORE</span> = <span class="pl-c1">200</span>; <span class="pl-c">//非法</span>
    }
}</pre></div>
<ul>
<li>错误演示：</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">A</span> {
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">INFO</span> = <span class="pl-s">"atguigu"</span>;  <span class="pl-c">//声明常量</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">print</span>() {
        <span class="pl-c">//The final field A.INFO cannot be  assigned</span>
        <span class="pl-c">//INFO = "尚硅谷"; </span>
    }
}</pre></div>
<h3>5.3 笔试题</h3>
<p>题1：排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Something</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">addOne</span>(<span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">x</span>) {
        <span class="pl-k">return</span> ++<span class="pl-s1">x</span>;
        <span class="pl-c">// return x + 1;</span>
    }
}</pre></div>
<p>题2：排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Something</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Other</span> <span class="pl-s1">o</span> = <span class="pl-k">new</span> <span class="pl-smi">Other</span>();
        <span class="pl-k">new</span> <span class="pl-smi">Something</span>().<span class="pl-en">addOne</span>(<span class="pl-s1">o</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">addOne</span>(<span class="pl-k">final</span> <span class="pl-smi">Other</span> <span class="pl-s1">o</span>) {
        <span class="pl-c">// o = new Other();</span>
        <span class="pl-s1">o</span>.<span class="pl-s1">i</span>++;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Other</span> {
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">i</span>;
}</pre></div>
<h2>6. 抽象类与抽象方法(或abstract关键字)</h2>
<p>让父类不能造对象，不能实例化</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">PersonTest</span> {
    <span class="pl-c">// abstact例子</span>
    <span class="pl-c">// abstract修饰类，该类就是抽象类</span>
    <span class="pl-c">// 抽象类中可以定义抽象方法，抽象方法没有方法体</span>
    <span class="pl-c">// 抽象类中可以定义非抽象方法</span>
    <span class="pl-c">// 抽象类不能实例化</span>
    <span class="pl-c">// 抽象类中可以定义构造方法</span>
    <span class="pl-c">// 抽象类的子类必须重写父类中的所有抽象方法，否则子类也是抽象类</span>

    <span class="pl-smi">String</span> <span class="pl-s1">name</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">age</span>;

    <span class="pl-k">public</span> <span class="pl-smi">PersonTest</span>() {

    }

    <span class="pl-k">public</span> <span class="pl-smi">PersonTest</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">age</span> = <span class="pl-s1">age</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人吃饭"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"人睡觉"</span>);
    }

}
<span class="pl-c">//抽象类</span>
<span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Person</span>{
    <span class="pl-c">//定义抽象方法</span>
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">say</span>();


}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Student</span> <span class="pl-k">extends</span> <span class="pl-smi">PersonTest</span> {
    <span class="pl-smi">String</span> <span class="pl-s1">school</span>;

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>() {

    }

    <span class="pl-k">public</span> <span class="pl-smi">Student</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>, <span class="pl-smi">int</span> <span class="pl-s1">age</span>, <span class="pl-smi">String</span> <span class="pl-s1">school</span>) {
        <span class="pl-en">super</span>(<span class="pl-s1">name</span>, <span class="pl-s1">age</span>);
        <span class="pl-smi">this</span>.<span class="pl-s1">school</span> = <span class="pl-s1">school</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生吃饭"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">sleep</span>() {<span class="pl-c">/* ... */</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"学生睡觉"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">say</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我是学生"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Student</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Student</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">eat</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">sleep</span>();

        <span class="pl-smi">PersonTest</span> <span class="pl-s1">P</span> = <span class="pl-k">new</span> <span class="pl-smi">PersonTest</span>();
        <span class="pl-smi">P</span>.<span class="pl-en">eat</span>();
        <span class="pl-smi">P</span>.<span class="pl-en">sleep</span>();
        
        <span class="pl-s1">s</span>.<span class="pl-en">say</span>();
    }

}</pre></div>
<p>abstract修饰类:</p>
<blockquote>
<p>此类称为抽象类<br>
抽象类不能实例化。<br>
抽象类中是包含构造器的，因为子类对象实例化时，需要直接或间接的调用到父类的构造器。<br>
抽象类中可以役有抽象方法。反之，抽象方法所在的类，一定是抽象类。</p>
</blockquote>
<p>abstract修饰方法</p>
<blockquote>
<p>此方法即为抽象方法<br>
抽象方法只有方法的声明，没有方法体。<br>
抽象方法其功能是确定的(通过方法的声明即可确定)，只是不知道如何实现，因为没有方法体</p>
<p>子类必须重写父类所有抽方法后才可实例化，否则子类仍然时一个抽象类</p>
</blockquote>
<p>abstract不能使用的场景</p>
<p>abstract 不能修饰哪些结构?<br>
属性、构造器、代码块等。<br>
abstract 不能与哪些关键字共用?(自治)<br>
不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
<blockquote>
<p>私有方法不能重写</p>
</blockquote>
<h3>6.1 由来</h3>
<p>举例1：</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325231608838.png"><img src="images/image-20220325231608838.png" alt="" style="max-width: 100%;"></a></p>
<p>举例2：</p>
<p>我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又<code class="notranslate">无法给出具体的实现</code>，而是应该交给子类各自具体实现。那么父类在声明这些方法时，<code class="notranslate">就只有方法签名，没有方法体</code>，我们把没有方法体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类必须是<strong>抽象类</strong>。</p>
<h3>6.2 语法格式</h3>
<ul>
<li><strong>抽象类</strong>：被abstract修饰的类。</li>
<li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li>
</ul>
<p>抽象类的语法格式</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[权限修饰符] <span class="pl-k">abstract</span> <span class="pl-k">class</span> 类名{
    
}
[权限修饰符] <span class="pl-k">abstract</span> <span class="pl-k">class</span> 类名 <span class="pl-k">extends</span> 父类{
    
}</pre></div>
<p>抽象方法的语法格式</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[其他修饰符] <span class="pl-k">abstract</span> 返回值类型 方法名([形参列表]);</pre></div>
<blockquote>
<p>注意：抽象方法没有方法体</p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220517204707255.png"><img src="images/image-20220517204707255.png" alt="" style="max-width: 100%;"></a></p>
<p>代码举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span>();
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Cat</span> <span class="pl-k">extends</span> <span class="pl-smi">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">eat</span> (){
          <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"小猫吃鱼和猫粮"</span>); 
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">CatTest</span> {
      <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">// 创建子类对象</span>
        <span class="pl-smi">Cat</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">Cat</span>(); 
       
        <span class="pl-c">// 调用eat方法</span>
        <span class="pl-s1">c</span>.<span class="pl-en">eat</span>();
      }
}</pre></div>
<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h3>6.3 使用说明</h3>
<ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</li>
</ol>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</blockquote>
<ol start="2">
<li>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。</li>
</ol>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p>
</blockquote>
<ol start="3">
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ol>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ol start="4">
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li>
</ol>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<h3>6.4 注意事项</h3>
<ul>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ul>
<h3>6.5 应用举例1</h3>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220325232847872.png"><img src="images/image-20220325232847872.png" alt="" style="max-width: 100%;"></a></p>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别<code class="notranslate">计算运输工具的燃料效率</code>和<code class="notranslate">行驶距离</code>。</p>
<p>**问题：**卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</p>
<p>**解决方案：**Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//Vehicle是一个抽象类，有两个抽象方法。</span>
<span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Vehicle</span>{
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>();	<span class="pl-c">//计算燃料效率的抽象方法</span>
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">double</span> <span class="pl-en">calcTripDistance</span>();	<span class="pl-c">//计算行驶距离的抽象方法</span>
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Truck</span> <span class="pl-k">extends</span> <span class="pl-smi">Vehicle</span>{
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>( )   { <span class="pl-c">//写出计算卡车的燃料效率的具体方法   }</span>
    <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-s1">calcTripDistance</span>( )    {  <span class="pl-c">//写出计算卡车行驶距离的具体方法   }</span>
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">RiverBarge</span> <span class="pl-k">extends</span> <span class="pl-smi">Vehicle</span>{
     <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-en">calcFuelEfficiency</span>( ) { <span class="pl-c">//写出计算驳船的燃料效率的具体方法  }</span>
     <span class="pl-k">public</span> <span class="pl-smi">double</span> <span class="pl-s1">calcTripDistance</span>( )  {  <span class="pl-c">//写出计算驳船行驶距离的具体方法}</span>
}</pre></div>
<h3>6.6 应用举例2：模板方法设计模式(TemplateMethod)</h3>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li>当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<p>**类比举例：**英语六级模板</p>
<p>制作月饼的模板：</p>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Template</span> {
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">getTime</span>() {
        <span class="pl-smi">long</span> <span class="pl-s1">start</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-en">code</span>();
        <span class="pl-smi">long</span> <span class="pl-s1">end</span> = <span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"执行时间是："</span> + (<span class="pl-s1">end</span> - <span class="pl-s1">start</span>));
    }

    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">code</span>();
}

<span class="pl-k">class</span> <span class="pl-smi">SubTemplate</span> <span class="pl-k">extends</span> <span class="pl-smi">Template</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">code</span>() {
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-c1">10000</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">i</span>);
        }
    }
}</pre></div>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">java</span>;
<span class="pl-c">//抽象类的应用：模板方法的设计模式</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TemplateMethodTest</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">BankTemplateMethod</span> <span class="pl-s1">btm</span> = <span class="pl-k">new</span> <span class="pl-smi">DrawMoney</span>();
        <span class="pl-s1">btm</span>.<span class="pl-en">process</span>();

        <span class="pl-smi">BankTemplateMethod</span> <span class="pl-s1">btm2</span> = <span class="pl-k">new</span> <span class="pl-smi">ManageMoney</span>();
        <span class="pl-s1">btm2</span>.<span class="pl-en">process</span>();
    }
}
<span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-c">// 具体方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">takeNumber</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"取号排队"</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>(); <span class="pl-c">// 办理具体的业务 //钩子方法</span>

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">evaluate</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"反馈评分"</span>);
    }

    <span class="pl-c">// 模板方法，把基本操作组合到一起，子类一般不能重写</span>
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">process</span>() {
        <span class="pl-smi">this</span>.<span class="pl-en">takeNumber</span>();

        <span class="pl-smi">this</span>.<span class="pl-en">transact</span>();<span class="pl-c">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span>

        <span class="pl-smi">this</span>.<span class="pl-en">evaluate</span>();
    }
}

<span class="pl-k">class</span> <span class="pl-smi">DrawMoney</span> <span class="pl-k">extends</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我要取款！！！"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">ManageMoney</span> <span class="pl-k">extends</span> <span class="pl-smi">BankTemplateMethod</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">transact</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"我要理财！我这里有2000万美元!!"</span>);
    }
}</pre></div>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
<h3>6.7 思考与练习</h3>
<p><strong>思考：</strong></p>
<p>问题1：为什么抽象类不可以使用final关键字声明？</p>
<p>问题2：一个抽象类中可以定义构造器吗？</p>
<p>问题3：是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？</p>
<p><strong>练习1：</strong></p>
<p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。</p>
<p>对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。</p>
<p>请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p>
<p><strong>练习2：软件外包公司外派管理</strong></p>
<p>有一家软件外包公司，可以外派开发人员，该公司有两个角色：普通开发人员Developer和项目经理Manager。他们的关系如下图：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220504164925878.png"><img src="images/image-20220504164925878.png" alt="" style="max-width: 100%;"></a></p>
<p>普通开发人员的工作内容是“开发项目”，项目经理的工作内容是“项目管理”。对外的报价是普通开发人员每天500,元，超过60天每天400元。项目经理每天800元，超过60天每天700元。</p>
<p>有一家银行需要1名项目经理、2名开发人员，现场开发90天，计算银行需要付给软件公司的总金额。</p>
<p>提示：创建数组 Employee[] emps = new Employee[3]。其中存储驻场的3名员工。</p>
<p><strong>练习3：</strong></p>
<p>创建父类Shape，包含绘制形状的抽象方法draw()。</p>
<p>创建Shape的子类Circle和Rectangle，重写draw()方法，绘制圆形和矩形。</p>
<p>绘制多个圆形和矩形。</p>
<p><strong>练习4：</strong></p>
<p>1、声明抽象父类Person，包含抽象方法public abstract void eat();<br>
2、声明子类中国人Chinese，重写抽象方法，打印用筷子吃饭<br>
3、声明子类美国人American，重写抽象方法，打印用刀叉吃饭<br>
4、声明子类印度人Indian，重写抽象方法，打印用手抓饭<br>
5、声明测试类PersonTest，创建Person数组，存储各国人对象，并遍历数组，调用eat()方法</p>
<p><strong>练习5：工资系统设计</strong></p>
<p>编写工资系统，实现不同类型员工(多态)的按月发放工资。如果当月出现某个Employee对象的生日，则将该雇员的工资增加100元。</p>
<p>实验说明：</p>
<p>（1）定义一个Employee类，该类包含：</p>
<p>private成员变量name,number,birthday，其中birthday 为MyDate类的对象；</p>
<p>abstract方法earnings()；</p>
<p>toString()方法输出对象的name,number和birthday。</p>
<p>（2）MyDate类包含:</p>
<p>private成员变量year,month,day ；</p>
<p>toDateString()方法返回日期对应的字符串：xxxx年xx月xx日</p>
<p>（3）定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处理。该类包括：private成员变量monthlySalary；</p>
<p>实现父类的抽象方法earnings(),该方法返回monthlySalary值；toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（4）参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的员工处理。该类包括：</p>
<p>private成员变量wage和hour；</p>
<p>实现父类的抽象方法earnings(),该方法返回wage*hour值；</p>
<p>toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（5）定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本月是某个Employee对象的生日，还要输出增加工资信息。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//提示：</span>
<span class="pl-c">//定义People类型的数组People c1[]=new People[10];</span>
<span class="pl-c">//数组元素赋值</span>
<span class="pl-s1">c1</span>[<span class="pl-c1">0</span>]=<span class="pl-k">new</span> <span class="pl-smi">People</span>(<span class="pl-s">"John"</span>,<span class="pl-s">"0001"</span>,<span class="pl-c1">20</span>);
<span class="pl-s1">c1</span>[<span class="pl-c1">1</span>]=<span class="pl-k">new</span> <span class="pl-smi">People</span>(<span class="pl-s">"Bob"</span>,<span class="pl-s">"0002"</span>,<span class="pl-c1">19</span>);
<span class="pl-c">//若People有两个子类Student和Officer，则数组元素赋值时，可以使父类类型的数组元素指向子类。</span>
<span class="pl-s1">c1</span>[<span class="pl-c1">0</span>]=<span class="pl-k">new</span> <span class="pl-smi">Student</span>(<span class="pl-s">"John"</span>,<span class="pl-s">"0001"</span>,<span class="pl-c1">20</span>,<span class="pl-c1">85.0</span>);
<span class="pl-s1">c1</span>[<span class="pl-c1">1</span>]=<span class="pl-k">new</span> <span class="pl-smi">Officer</span>(<span class="pl-s">"Bob"</span>,<span class="pl-s">"0002"</span>,<span class="pl-c1">19</span>,<span class="pl-c1">90.5</span>);</pre></div>
<h2>7. 接口(interface)</h2>
<p>1，接口的理解:接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。<br>
2.定义接口的关键字:interface<br>
3.接口内部结构的说明:</p>
<blockquote>
<p>可以声明:<br>
属性:必须使用public static final修饰<br>
方法:jdk8之前:声明抽象方法，修饰为public abstract<br>
idk8:声明静态方法、默认方法<br>
jdk9:声明私有方法</p>
<p>不可以声明构造器 代码块等</p>
</blockquote>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InterfaceTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Flyable</span>.<span class="pl-c1">MIN_SPEED</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Flyable</span>.<span class="pl-c1">MAX_SPEED</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Flyable</span>.<span class="pl-c1">MAX_SPEED2</span>);
        <span class="pl-c">// MAX_SPEED2 = 1000;//报错 不能更改</span>
        <span class="pl-c">// System.out.println(Flyable.MAX_SPEED2);</span>
    }

}

<span class="pl-k">interface</span> <span class="pl-smi">Flyable</span> {
    <span class="pl-c">// 全局变量</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MIN_SPEED</span> = <span class="pl-c1">10</span>;
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">MAX_SPEED</span> = <span class="pl-c1">100</span>;

    <span class="pl-c">// 可以省略public static final</span>
    <span class="pl-smi">int</span> <span class="pl-c1">MAX_SPEED2</span> = <span class="pl-c1">100</span>;

    <span class="pl-c">// 抽象方法</span>
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">fly</span>();

    <span class="pl-c">// 可以简写</span>
    <span class="pl-smi">void</span> <span class="pl-en">fly2</span>();

}</pre></div>
<p>接口与类的关系，实现关系</p>
<p>格式 class A implements B,C{ }</p>
<p>A 相较于 SuperA 来讲叫做子类</p>
<p>A 相较于 B，C 来讲 叫做实现类</p>
<p>满足此关系之后，说明:</p>
<p>类可以实现多个接口。</p>
<p>类针对于接口的多实现，一定程度上就弥补了类的单继承的局限性。</p>
<p>类必须将实现接口中的所有方法都重写（或实现），方可实例化。否则，此实现类必须声明为抽象类</p>
<p>接口与接口间的关系：继承关系，且可以多继承</p>
<p>接口的多态性 ： 接口名 变量名 = new 实现类对象;</p>
<p>面试题 区分抽象类和接口</p>
<p>共性 都可以声明抽象方法 都不能实例化</p>
<p>不同</p>
<blockquote>
<p>抽象类一定有构造器 接口没有构造器</p>
<p>类与类之间继承关系 类与接口之间时实现关系 接口与接口之间时多继承关系</p>
</blockquote>
<h3>7.1 类比</h3>
<p>生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？</p>
<pre lang="plain" class="notranslate"><code class="notranslate"> USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。
</code></pre>
<p>其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是<code class="notranslate">遵循了USB规范</code>的一种具体设备而已。</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/bbcc80f541000c71b81650cfaa770c86.png"><img src="images/bbcc80f541000c71b81650cfaa770c86.png" alt="" style="max-width: 100%;"></a></p>
<p>只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。</p>
<p>Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种<code class="notranslate">面向接口</code>的<code class="notranslate">低耦合</code>，为系统提供更好的可扩展性和可维护性。</p>
<h3>7.2 概述</h3>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。继承是一个"是不是"的is-a关系，而接口实现则是 "能不能"的<code class="notranslate">has-a</code>关系。</p>
<ul>
<li>例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范</li>
<li>例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范</li>
</ul>
<blockquote>
<p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p>
</blockquote>
<h3>7.3 定义格式</h3>
<p>接口的定义，它与定义类方式相似，但是使用 <code class="notranslate">interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，枚举，接口，注解。</p>
</blockquote>
<h4>7.3.1 接口的声明格式</h4>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">interface</span> 接口名{
    <span class="pl-c">//接口的成员列表：</span>
    <span class="pl-c">// 公共的静态常量</span>
    <span class="pl-c">// 公共的抽象方法</span>
    
    <span class="pl-c">// 公共的默认方法（JDK1.8以上）</span>
    <span class="pl-c">// 公共的静态方法（JDK1.8以上）</span>
    <span class="pl-c">// 私有方法（JDK1.9以上）</span>
}</pre></div>
<p>示例代码：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">USB3</span>{
    <span class="pl-c">//静态常量</span>
    <span class="pl-smi">long</span> <span class="pl-c1">MAX_SPEED</span> = <span class="pl-c1">500</span>*<span class="pl-c1">1024</span>*<span class="pl-c1">1024</span>;<span class="pl-c">//500MB/s</span>

    <span class="pl-c">//抽象方法</span>
    <span class="pl-smi">void</span> <span class="pl-en">in</span>();
    <span class="pl-smi">void</span> <span class="pl-en">out</span>();

    <span class="pl-c">//默认方法</span>
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"开始"</span>);
    }
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"结束"</span>);
    }

    <span class="pl-c">//静态方法</span>
    <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"USB 3.0可以同步全速地进行读写操作"</span>);
    }
}</pre></div>
<h4>7.3.2 接口的成员说明</h4>
<p><strong>在JDK8.0 之前</strong>，接口中只允许出现：</p>
<p>（1）公共的静态的常量：其中<code class="notranslate">public static final</code>可以省略</p>
<p>（2）公共的抽象的方法：其中<code class="notranslate">public abstract</code>可以省略</p>
<blockquote>
<p>理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现</p>
</blockquote>
<p><strong>在JDK8.0 时</strong>，接口中允许声明<code class="notranslate">默认方法</code>和<code class="notranslate">静态方法</code>：</p>
<p>（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略</p>
<p>（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略</p>
<p><strong>在JDK9.0 时</strong>，接口又增加了：</p>
<p>（5）私有方法</p>
<p>除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。</p>
<h3>7.4 接口的使用规则</h3>
<p><strong>1、类实现接口（implements）</strong></p>
<p>接口<strong>不能创建对象</strong>，但是可以被类实现（<code class="notranslate">implements</code> ，类似于被继承）。</p>
<p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code class="notranslate"> implements</code>关键字。</p>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 实现类  <span class="pl-k">implements</span> 接口{
    <span class="pl-c">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span>
      <span class="pl-c">// 重写接口中默认方法【可选】</span>
}

【修饰符】 <span class="pl-k">class</span> 实现类 <span class="pl-k">extends</span> 父类 <span class="pl-k">implements</span> 接口{
    <span class="pl-c">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span>
      <span class="pl-c">// 重写接口中默认方法【可选】</span>
}</pre></div>
<p>注意：</p>
<ol>
<li>如果接口的实现类是非抽象类，那么必须<code class="notranslate">重写接口中所有抽象方法</code>。</li>
<li>默认方法可以选择保留，也可以重写。</li>
</ol>
<blockquote>
<p>重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了</p>
</blockquote>
<ol start="3">
<li>接口中的静态方法不能被继承也不能被重写</li>
</ol>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">USB</span>{		<span class="pl-c">// </span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>() ;
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>() ;	
}
<span class="pl-k">class</span> <span class="pl-smi">Computer</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(<span class="pl-smi">USB</span> <span class="pl-s1">usb</span>){	
        <span class="pl-s1">usb</span>.<span class="pl-en">start</span>() ;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"=========== USB 设备工作 ========"</span>) ;
        <span class="pl-s1">usb</span>.<span class="pl-en">stop</span>() ;
    }
};
<span class="pl-k">class</span> <span class="pl-smi">Flash</span> <span class="pl-k">implements</span> <span class="pl-smi">USB</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>(){	<span class="pl-c">// 重写方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"U盘开始工作。"</span>) ;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>(){		<span class="pl-c">// 重写方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"U盘停止工作。"</span>) ;
    }
};
<span class="pl-k">class</span> <span class="pl-smi">Print</span> <span class="pl-k">implements</span> <span class="pl-smi">USB</span>{
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>(){	<span class="pl-c">// 重写方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"打印机开始工作。"</span>) ;
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>(){		<span class="pl-c">// 重写方法</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"打印机停止工作。"</span>) ;
    }
};
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">InterfaceDemo</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span> <span class="pl-s1">args</span>[]){
        <span class="pl-smi">Computer</span>.<span class="pl-en">show</span>(<span class="pl-k">new</span> <span class="pl-smi">Flash</span>()) ;
        <span class="pl-smi">Computer</span>.<span class="pl-en">show</span>(<span class="pl-k">new</span> <span class="pl-smi">Print</span>()) ;

        <span class="pl-s1">c</span>.<span class="pl-en">show</span>(<span class="pl-k">new</span> <span class="pl-smi">USB</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"移动硬盘开始运行"</span>);
            }
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"移动硬盘停止运行"</span>);
            }
        });
    }
};</pre></div>
<p><strong>2、接口的多实现（implements）</strong></p>
<p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<code class="notranslate">多实现</code>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<p>实现格式：</p>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">class</span> 实现类  <span class="pl-k">implements</span> 接口<span class="pl-c1">1</span>，接口<span class="pl-c1">2</span>，接口<span class="pl-c1">3</span>。。。{
    <span class="pl-c">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span>
      <span class="pl-c">// 重写接口中默认方法【可选】</span>
}

【修饰符】 <span class="pl-k">class</span> 实现类 <span class="pl-k">extends</span> 父类 <span class="pl-k">implements</span> 接口<span class="pl-c1">1</span>，接口<span class="pl-c1">2</span>，接口<span class="pl-c1">3</span>。。。{
    <span class="pl-c">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span>
      <span class="pl-c">// 重写接口中默认方法【可选】</span>
}</pre></div>
<blockquote>
<p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次</strong>。</p>
</blockquote>
<p>举例：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/1562216188519.png"><img src="images/1562216188519.png" alt="" style="max-width: 100%;"></a></p>
<p>定义多个接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">A</span> {
    <span class="pl-smi">void</span> <span class="pl-en">showA</span>();
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">B</span> {
    <span class="pl-smi">void</span> <span class="pl-en">showB</span>();
}</pre></div>
<p>定义实现类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">C</span> <span class="pl-k">implements</span> <span class="pl-smi">A</span>,<span class="pl-smi">B</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">showA</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"showA"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">showB</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"showB"</span>);
    }
}</pre></div>
<p>测试类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestC</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">C</span> <span class="pl-s1">c</span> = <span class="pl-k">new</span> <span class="pl-smi">C</span>();
        <span class="pl-s1">c</span>.<span class="pl-en">showA</span>();
        <span class="pl-s1">c</span>.<span class="pl-en">showB</span>();
    }
}</pre></div>
<p><strong>3、接口的多继承(extends)</strong></p>
<p>一个接口能继承另一个或者多个接口，接口的继承也使用 <code class="notranslate">extends</code> 关键字，子接口继承父接口的方法。</p>
<p>定义父接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">Chargeable</span> {
    <span class="pl-smi">void</span> <span class="pl-en">charge</span>();
    <span class="pl-smi">void</span> <span class="pl-en">in</span>();
    <span class="pl-smi">void</span> <span class="pl-en">out</span>();
}</pre></div>
<p>定义子接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">UsbC</span> <span class="pl-k">extends</span> <span class="pl-smi">Chargeable</span>,<span class="pl-smi">USB3</span> {
    <span class="pl-smi">void</span> <span class="pl-en">reverse</span>();
}</pre></div>
<p>定义子接口的实现类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TypeCConverter</span> <span class="pl-k">implements</span> <span class="pl-smi">UsbC</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">reverse</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"正反面都支持"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">charge</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"可充电"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">in</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"接收数据"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">out</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"输出数据"</span>);
    }
}</pre></div>
<blockquote>
<p>所有父接口的抽象方法都有重写。</p>
<p>方法签名相同的抽象方法只需要实现一次。</p>
</blockquote>
<p><strong>4、接口与实现类对象构成多态引用</strong></p>
<p>实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。</p>
<p>接口的不同实现类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Mouse</span> <span class="pl-k">implements</span> <span class="pl-smi">USB3</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">out</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"发送脉冲信号"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">in</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"不接收信号"</span>);
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">KeyBoard</span> <span class="pl-k">implements</span> <span class="pl-smi">USB3</span>{
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">in</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"不接收信号"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">out</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"发送按键信号"</span>);
    }
}</pre></div>
<p>测试类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestComputer</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Computer</span> <span class="pl-s1">computer</span> = <span class="pl-k">new</span> <span class="pl-smi">Computer</span>();
        <span class="pl-smi">USB3</span> <span class="pl-s1">usb</span> = <span class="pl-k">new</span> <span class="pl-smi">Mouse</span>();
        <span class="pl-s1">computer</span>.<span class="pl-en">setUsb</span>(<span class="pl-s1">usb</span>);
        <span class="pl-s1">usb</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">out</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">in</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">stop</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"--------------------------"</span>);

        <span class="pl-s1">usb</span> = <span class="pl-k">new</span> <span class="pl-smi">KeyBoard</span>();
        <span class="pl-s1">computer</span>.<span class="pl-en">setUsb</span>(<span class="pl-s1">usb</span>);
        <span class="pl-s1">usb</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">out</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">in</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">stop</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"--------------------------"</span>);

        <span class="pl-s1">usb</span> = <span class="pl-k">new</span> <span class="pl-smi">MobileHDD</span>();
        <span class="pl-s1">computer</span>.<span class="pl-en">setUsb</span>(<span class="pl-s1">usb</span>);
        <span class="pl-s1">usb</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">out</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">in</span>();
        <span class="pl-s1">usb</span>.<span class="pl-en">stop</span>();
    }
}</pre></div>
<p><strong>5、使用接口的静态成员</strong></p>
<p>接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestUSB3</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)</span>
        <span class="pl-smi">USB3</span>.<span class="pl-en">show</span>();
        <span class="pl-c">//通过“接口名.”直接使用接口的静态常量</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">USB3</span>.<span class="pl-c1">MAX_SPEED</span>);
    }
}</pre></div>
<p><strong>6、使用接口的非静态方法</strong></p>
<ul>
<li>对于接口的静态方法，直接使用“<code class="notranslate">接口名.</code>”进行调用即可
<ul>
<li>也只能使用“接口名."进行调用，不能通过实现类的对象进行调用</li>
</ul>
</li>
<li>对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用
<ul>
<li>接口不能直接创建对象，只能创建实现类的对象</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestMobileHDD</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//创建实现类对象</span>
        <span class="pl-smi">MobileHDD</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">MobileHDD</span>();

        <span class="pl-c">//通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法</span>
        <span class="pl-s1">b</span>.<span class="pl-en">start</span>();
        <span class="pl-s1">b</span>.<span class="pl-en">in</span>();
        <span class="pl-s1">b</span>.<span class="pl-en">stop</span>();

        <span class="pl-c">//通过接口名调用接口的静态方法</span>
<span class="pl-c">//        MobileHDD.show();</span>
<span class="pl-c">//        b.show();</span>
        <span class="pl-smi">Usb3</span>.<span class="pl-en">show</span>();
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {

    <span class="pl-c">//在JDK8以前，接口中只能定义全局常量和抽象方法</span>
    <span class="pl-c">//JDK8以后，接口中可以定义静态方法和默认方法</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//接口中的静态方法只能通过接口名调用</span>
        <span class="pl-smi">MyInterface1</span>.<span class="pl-en">method1</span>();
        <span class="pl-c">//接口中的默认方法可以通过实现类对象调用，也可以通过接口名调用</span>
        <span class="pl-smi">MyInterface1</span>.<span class="pl-en">method2</span>();
                <span class="pl-k">new</span> <span class="pl-smi">MyInterface1Impl</span>().<span class="pl-en">method2</span>();
            }
        
        }
        <span class="pl-k">interface</span> <span class="pl-smi">MyInterface1</span>{
            <span class="pl-c">//全局常量</span>
            <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-c1">NUM</span> = <span class="pl-c1">10</span>;
            <span class="pl-c">//抽象方法</span>
            <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>();
            <span class="pl-c">//静态方法</span>
            <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method1</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"静态方法"</span>);
            }
            <span class="pl-c">//默认方法</span>
            <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">method2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"默认方法"</span>);
    }

}
<span class="pl-k">class</span> <span class="pl-smi">MyInterface1Impl</span> <span class="pl-k">implements</span> <span class="pl-smi">MyInterface1</span>{

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"抽象方法"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method2</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"实现类重写的默认方法"</span>);
    }

}
<span class="pl-c">//接口中的静态方法只能通过接口名调用，不能通过实现类对象调用</span>
<span class="pl-c">//接口中的默认方法可以通过实现类对象调用，也可以通过接口名调用</span>
<span class="pl-c">//接口中声明的默认方法可以实现类继承，实现类在没有重写的情况下，默认使用接口中的默认方法,如果实现类重写了此方法，则使用实现类重写的方法</span>
<span class="pl-c">//类实现了两个接口，而两个接口中都有默认方法，则类必须重写此方法，否则编译报错</span></pre></div>
<h3>7.5 JDK8中相关冲突问题</h3>
<h4>7.5.1 默认方法冲突问题</h4>
<p><strong>（1）类优先原则</strong></p>
<p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下：</p>
<p>定义接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">Friend</span> {
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">date</span>(){<span class="pl-c">//约会</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"吃喝玩乐"</span>);
    }
}</pre></div>
<p>定义父类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Father</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">date</span>(){<span class="pl-c">//约会</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"爸爸约吃饭"</span>);
    }
}</pre></div>
<p>定义子类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Son</span> <span class="pl-k">extends</span> <span class="pl-smi">Father</span> <span class="pl-k">implements</span> <span class="pl-smi">Friend</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">date</span>() {
        <span class="pl-c">//(1)不重写默认保留父类的</span>
        <span class="pl-c">//(2)调用父类被重写的</span>
<span class="pl-c">//        super.date();</span>
        <span class="pl-c">//(3)保留父接口的</span>
<span class="pl-c">//        Friend.super.date();</span>
        <span class="pl-c">//(4)完全重写</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"跟康师傅学Java"</span>);
    }
}</pre></div>
<p>定义测试类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestSon</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Son</span> <span class="pl-s1">s</span> = <span class="pl-k">new</span> <span class="pl-smi">Son</span>();
        <span class="pl-s1">s</span>.<span class="pl-en">date</span>();
    }
}</pre></div>
<p><strong>（2）接口冲突（左右为难）</strong></p>
<ul>
<li>当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="images/%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE.jpg"><img src="images/%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE.jpg" alt="" style="max-width: 100%;"></a></p>
<p>无论你多难抉择，最终都是要做出选择的。</p>
<p>声明接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">BoyFriend</span> {
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">date</span>(){<span class="pl-c">//约会</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"神秘约会"</span>);
    }
}</pre></div>
<p>选择保留其中一个，通过“<code class="notranslate">接口名.super.方法名</code>"的方法选择保留哪个接口的默认方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Girl</span> <span class="pl-k">implements</span> <span class="pl-smi">Friend</span>,<span class="pl-smi">BoyFriend</span>{

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">date</span>() {
        <span class="pl-c">//(1)保留其中一个父接口的</span>
<span class="pl-c">//        Friend.super.date();</span>
<span class="pl-c">//        BoyFriend.super.date();</span>
        <span class="pl-c">//(2)完全重写</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"跟康师傅学Java"</span>);
    }

}</pre></div>
<p>测试类</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestGirl</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Girl</span> <span class="pl-s1">girl</span> = <span class="pl-k">new</span> <span class="pl-smi">Girl</span>();
        <span class="pl-s1">girl</span>.<span class="pl-en">date</span>();
    }
}</pre></div>
<ul>
<li>当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p>另一个父接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">USB2</span> {
    <span class="pl-c">//静态常量</span>
    <span class="pl-smi">long</span> <span class="pl-c1">MAX_SPEED</span> = <span class="pl-c1">60</span>*<span class="pl-c1">1024</span>*<span class="pl-c1">1024</span>;<span class="pl-c">//60MB/s</span>

    <span class="pl-c">//抽象方法</span>
    <span class="pl-smi">void</span> <span class="pl-en">in</span>();
    <span class="pl-smi">void</span> <span class="pl-en">out</span>();

    <span class="pl-c">//默认方法</span>
    <span class="pl-k">public</span> <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"开始"</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"结束"</span>);
    }

    <span class="pl-c">//静态方法</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"USB 2.0可以高速地进行读写操作"</span>);
    }
}</pre></div>
<p>子接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">USB</span> <span class="pl-k">extends</span> <span class="pl-smi">USB2</span>,<span class="pl-smi">USB3</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">start</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Usb.start"</span>);
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">stop</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Usb.stop"</span>);
    }
}</pre></div>
<blockquote>
<p>小贴士：</p>
<p>子接口重写默认方法时，default关键字可以保留。</p>
<p>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<h4>7.5.2 常量冲突问题</h4>
<ul>
<li>当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。</li>
<li>当子类同时实现多个接口，而多个接口存在相同同名常量。</li>
</ul>
<p>此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。</p>
<p>父类和父接口：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">SuperClass</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">1</span>;
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">SuperInterface</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">2</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">y</span> = <span class="pl-c1">2</span>;
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">MotherInterface</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">3</span>;
}</pre></div>
<p>子类：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">interfacetype</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">SubClass</span> <span class="pl-k">extends</span> <span class="pl-smi">SuperClass</span> <span class="pl-k">implements</span> <span class="pl-smi">SuperInterface</span>,<span class="pl-smi">MotherInterface</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
<span class="pl-c">//        System.out.println("x = " + x);//模糊不清</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"super.x = "</span> + <span class="pl-en">super</span>.<span class="pl-s1">x</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"SuperInterface.x = "</span> + <span class="pl-smi">SuperInterface</span>.<span class="pl-s1">x</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"MotherInterface.x = "</span> + <span class="pl-smi">MotherInterface</span>.<span class="pl-s1">x</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"y = "</span> + <span class="pl-s1">y</span>);<span class="pl-c">//没有重名问题，可以直接访问</span>
    }
}</pre></div>
<h3>7.6 接口的总结与面试题</h3>
<ul>
<li>接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。</li>
<li>声明接口用interface，接口的成员声明有限制：
<ul>
<li>（1）公共的静态常量</li>
<li>（2）公共的抽象方法</li>
<li>（3）公共的默认方法（JDK8.0 及以上）</li>
<li>（4）公共的静态方法（JDK8.0 及以上）</li>
<li>（5）私有方法（JDK9.0 及以上）</li>
</ul>
</li>
<li>类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。</li>
<li>接口可以继承接口，关键字是extends，而且支持多继承。</li>
<li>接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。</li>
<li>接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。</li>
</ul>
<p><strong>面试题</strong></p>
<p><strong>1、为什么接口中只能声明公共的静态的常量？</strong></p>
<p>因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。</p>
<p>例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA</p>
<pre class="notranslate"><code class="notranslate">       USB3.0规范中规定最大传输速率是5Gbps(500MB/s)，最大输出电流是5V/900mA
</code></pre>
<p>例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。</p>
<p><strong>2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</strong></p>
<p><code class="notranslate">静态方法</code>：因为之前的标准类库设计中，有很多Collection/Colletions或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p>
<p><code class="notranslate">默认方法</code>：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。</p>
<p><strong>3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。</strong></p>
<p><strong>私有方法</strong>：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。</p>
<h3>7.7 接口与抽象类之间的对比</h3>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220328002053452.png"><img src="images/image-20220328002053452.png" alt="" style="max-width: 100%;"></a></p>
<blockquote>
<p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p>
</blockquote>
<h3>7.8 练习</h3>
<p>**笔试题：**排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">A</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">0</span>;
}
<span class="pl-k">class</span> <span class="pl-smi">B</span> {
    <span class="pl-smi">int</span> <span class="pl-s1">x</span> = <span class="pl-c1">1</span>;
}
<span class="pl-k">class</span> <span class="pl-smi">C</span> <span class="pl-k">extends</span> <span class="pl-smi">B</span> <span class="pl-k">implements</span> <span class="pl-smi">A</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">pX</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">x</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">C</span>().<span class="pl-en">pX</span>();
    }
}</pre></div>
<p>**笔试题：**排错</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">Playable</span> {
    <span class="pl-smi">void</span> <span class="pl-en">play</span>();
}

<span class="pl-k">interface</span> <span class="pl-smi">Bounceable</span> {
    <span class="pl-smi">void</span> <span class="pl-en">play</span>();
}

<span class="pl-k">interface</span> <span class="pl-smi">Rollable</span> <span class="pl-k">extends</span> <span class="pl-smi">Playable</span>, <span class="pl-smi">Bounceable</span> {
    <span class="pl-smi">Ball</span> <span class="pl-s1">ball</span> = <span class="pl-k">new</span> <span class="pl-smi">Ball</span>(<span class="pl-s">"PingPang"</span>);

}

<span class="pl-k">class</span> <span class="pl-smi">Ball</span> <span class="pl-k">implements</span> <span class="pl-smi">Rollable</span> {
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>;

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Ball</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">name</span> = <span class="pl-s1">name</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">play</span>() {
        <span class="pl-s1">ball</span> = <span class="pl-k">new</span> <span class="pl-smi">Ball</span>(<span class="pl-s">"Football"</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">ball</span>.<span class="pl-en">getName</span>());
    }
}</pre></div>
<p><strong>练习1：</strong></p>
<p>定义一个接口用来实现两个对象的比较。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">CompareObject</span>{
    <span class="pl-c">//若返回值是 0 , 代表相等; 若为正数，代表当前对象大；负数代表当前对象小</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">compareTo</span>(<span class="pl-smi">Object</span> <span class="pl-s1">o</span>);  
}</pre></div>
<p>定义一个Circle类，声明redius属性，提供getter和setter方法</p>
<p>定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。</p>
<p>定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。</p>
<p>思考：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类中给出compareTo方法的实现，比较两个矩形的面积大小。</p>
<p><strong>练习2：交通工具案例</strong></p>
<p>阿里的一个工程师，声明的属性和方法如下：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220504172547709.png"><img src="images/image-20220504172547709.png" alt="" style="max-width: 100%;"></a></p>
<p>其中，有一个乘坐交通工具的方法takingVehicle()，在此方法中调用交通工具的run()。为了出行方便，他买了一辆捷安特自行车、一辆雅迪电动车和一辆奔驰轿车。这里涉及到的相关类及接口关系如下：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20220504172918861.png"><img src="images/image-20220504172918861.png" alt="" style="max-width: 100%;"></a></p>
<p>其中，电动车增加动力的方式是充电，轿车增加动力的方式是加油。在具体交通工具的run()中调用其所在类的相关属性信息。</p>
<p>请编写相关代码，并测试。</p>
<p>提示：创建Vehicle[]数组，保存阿里工程师的三辆交通工具，并分别在工程师的takingVehicle()中调用。</p>
<h2>8. 内部类（InnerClass)</h2>
<h3>8.1 概述</h3>
<p>内部类举例</p>
<p>thread 类声明了 State 类 ，表示线程生命周期</p>
<p>SashMap 类声明了 Node 类 表示封装 key 和 value</p>
<p>4.内部类的分类:(参考变量的分类)<br>
成员内部类:直接声明在外部类的里面。<br>
使用static修饰的:静态的成员内部类</p>
<blockquote>
<p>不使用static修饰的:非静态的成员内部类<br>
局部内部类:声明在方法内、构造器内、代码块内的内部类<br>
匿名的局部内部类<br>
非匿名的局部内部类</p>
</blockquote>
<p>内部类这节要讲的知识:</p>
<blockquote>
<p>成员内部类的理解</p>
</blockquote>
<blockquote>
<p>如何创建成员内部类的实例</p>
</blockquote>
<blockquote>
<p>如何在成员内部类中调用外部类的结构</p>
</blockquote>
<blockquote>
<p>局部内部类的基本使用</p>
</blockquote>
<p>关于成员内部类的理解</p>
<blockquote>
<p>从类的角度看:<br>
内部可以声明属性、方法、构造器、代码块、内部类等结构<br>
此内部类可以声明父类，可以实现接口<br>
可以使用final修饰<br>
可以使用abstract修饰</p>
</blockquote>
<blockquote>
<p>从外部类的成员的角度看:<br>
在内部可以调用外部类的结构。比如:属性、方法等<br>
除了使用public、缺省权限修饰之外，还可以使用private、protected修饰<br>
可以使用static修饰</p>
</blockquote>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">OutherClassTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">SubA</span> <span class="pl-s1">subA</span> = <span class="pl-k">new</span> <span class="pl-smi">SubA</span>();
        <span class="pl-s1">subA</span>.<span class="pl-en">method</span>();

        <span class="pl-c">// 其它写法</span>

        <span class="pl-c">//方法1 提供接口 匿名实现类的对象</span>
        <span class="pl-smi">A</span> <span class="pl-s1">a</span> = <span class="pl-k">new</span> <span class="pl-smi">A</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"匿名实现类的方法"</span>);
            }
        };
        <span class="pl-s1">a</span>.<span class="pl-en">method</span>(); <span class="pl-c">// 调用匿名内部类的方法</span>

        <span class="pl-c">//方法2</span>
        <span class="pl-k">new</span> <span class="pl-smi">SubA</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"匿名实现类的方法"</span>);
            }
        }
        .<span class="pl-en">method</span>(); <span class="pl-c">// 调用匿名内部类的方法</span>
    }
}

<span class="pl-k">interface</span> <span class="pl-smi">A</span> {
    <span class="pl-smi">void</span> <span class="pl-en">method</span>();
}

<span class="pl-k">class</span> <span class="pl-smi">SubA</span> <span class="pl-k">implements</span> <span class="pl-smi">A</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"SubA"</span>);
    }
}</pre></div>
<h3>8.1.1 什么是内部类</h3>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">OutherClassTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">SubA</span> <span class="pl-s1">subA</span> = <span class="pl-k">new</span> <span class="pl-smi">SubA</span>();
        <span class="pl-s1">subA</span>.<span class="pl-en">method</span>();

        <span class="pl-c">// 其它写法</span>

        <span class="pl-c">//方法1 提供接口 匿名实现类的对象</span>
        <span class="pl-smi">A</span> <span class="pl-s1">a</span> = <span class="pl-k">new</span> <span class="pl-smi">A</span>() {
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"匿名实现类的方法"</span>);
            }
        };
        <span class="pl-s1">a</span>.<span class="pl-en">method</span>(); <span class="pl-c">// 调用匿名内部类的方法</span>

        <span class="pl-c">//方法2</span>
        <span class="pl-k">new</span> <span class="pl-smi">SubA</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"匿名实现类的方法"</span>);
            }
        }
        .<span class="pl-en">method</span>(); <span class="pl-c">// 调用匿名内部类的方法</span>

        <span class="pl-c">//方法3</span>
        <span class="pl-smi">C</span> <span class="pl-s1">s1</span> = <span class="pl-k">new</span> <span class="pl-smi">C</span>();
        <span class="pl-s1">s1</span>.<span class="pl-en">method</span>();

        <span class="pl-c">//方法4 提供了继承于抽象类的匿名子类的对象</span>
        <span class="pl-smi">B</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">B</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"继承于抽象类的子类调用的方法"</span>);
            }
        };

        <span class="pl-s1">b</span>.<span class="pl-en">method</span>();

        <span class="pl-c">//方法5  </span>
        <span class="pl-k">new</span> <span class="pl-smi">B</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"继承于抽象类的子类调用的方法"</span>);
            }
        }
        .<span class="pl-en">method</span>(); <span class="pl-c">// 调用匿名内部类的方法</span>

        <span class="pl-c">//方法6</span>
        <span class="pl-smi">D</span> <span class="pl-s1">d</span> = <span class="pl-k">new</span> <span class="pl-smi">D</span>();
        <span class="pl-s1">d</span>.<span class="pl-en">method</span>();

        <span class="pl-c">//方法7</span>
        <span class="pl-smi">D</span> <span class="pl-s1">f</span> = <span class="pl-k">new</span> <span class="pl-smi">D</span>(){
            
        };
        <span class="pl-s1">f</span>.<span class="pl-en">method</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">f</span>.<span class="pl-en">getClass</span>());
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">f</span>.<span class="pl-en">getClass</span>().<span class="pl-en">getSuperclass</span>());

        <span class="pl-smi">D</span> <span class="pl-s1">f2</span> = <span class="pl-k">new</span> <span class="pl-smi">D</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"继承于抽象类的子类调用的方法"</span>);
            }
        };
        <span class="pl-s1">f2</span>.<span class="pl-en">method</span>();
    }
    
}

<span class="pl-k">interface</span> <span class="pl-smi">A</span> {
    <span class="pl-smi">void</span> <span class="pl-en">method</span>();
}

<span class="pl-k">class</span> <span class="pl-smi">SubA</span> <span class="pl-k">implements</span> <span class="pl-smi">A</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"SubA"</span>);
    }
}

<span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">B</span> {
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>();
    <span class="pl-c">//抽象类</span>
    
}

<span class="pl-k">class</span> <span class="pl-smi">C</span> <span class="pl-k">extends</span> <span class="pl-smi">B</span> {
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"C"</span>);
    }
}

<span class="pl-k">class</span> <span class="pl-smi">D</span> {
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"D"</span>);
    }
}</pre></div>
<p>将一个类A定义在另一个类B里面，里面的那个类A就称为<code class="notranslate">内部类（InnerClass）</code>，类B则称为<code class="notranslate">外部类（OuterClass）</code>。</p>
<h4>8.1.2 为什么要声明内部类呢</h4>
<p>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。</p>
<p>总的来说，遵循<code class="notranslate">高内聚、低耦合</code>的面向对象开发原则。</p>
<h4>8.1.3 内部类的分类</h4>
<p>根据内部类声明的位置（如同变量的分类），我们可以分为：</p>
<p><a target="_blank" rel="noopener noreferrer" href="images/image-20221124223912529.png"><img src="images/image-20221124223912529.png" alt="" style="max-width: 100%;"></a></p>
<h3>8.2 成员内部类</h3>
<h4>8.2.1 概述</h4>
<p>如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。</p>
<p><strong>语法格式：</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 外部类{
    [其他修饰符] [<span class="pl-k">static</span>] <span class="pl-k">class</span> 内部类{
    }
}</pre></div>
<p><strong>成员内部类的使用特征，概括来讲有如下两种角色：</strong></p>
<ul>
<li>成员内部类作为<code class="notranslate">类的成员的角色</code>：
<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li>成员内部类作为<code class="notranslate">类的角色</code>：
<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的，表示不能被继承</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ol start="2">
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ol>
<h4>8.2.2 创建成员内部类对象</h4>
<ul>
<li>实例化静态内部类</li>
</ul>
<pre lang="plain" class="notranslate"><code class="notranslate">外部类名.静态内部类名 变量 = 外部类名.静态内部类名();
变量.非静态方法();
</code></pre>
<ul>
<li>实例化非静态内部类</li>
</ul>
<pre lang="plain" class="notranslate"><code class="notranslate">外部类名 变量1 = new 外部类();
外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();
变量2.非静态方法();
</code></pre>
<h4>8.2.3 举例</h4>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestMemberInnerClass</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//创建静态内部类实例，并调用方法</span>
        <span class="pl-smi">Outer</span>.<span class="pl-smi">StaticInner</span> <span class="pl-s1">inner</span> = <span class="pl-k">new</span> <span class="pl-smi">Outer</span>.<span class="pl-smi">StaticInner</span>();
        <span class="pl-s1">inner</span>.<span class="pl-en">inFun</span>();
        <span class="pl-c">//调用静态内部类静态方法</span>
        <span class="pl-smi">Outer</span>.<span class="pl-s1">StaticInner</span>.<span class="pl-en">inMethod</span>();

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"*****************************"</span>);
        
        <span class="pl-c">//创建非静态内部类实例（方式1），并调用方法</span>
        <span class="pl-smi">Outer</span> <span class="pl-s1">outer</span> = <span class="pl-k">new</span> <span class="pl-smi">Outer</span>();
        <span class="pl-smi">Outer</span>.<span class="pl-smi">NoStaticInner</span> <span class="pl-s1">inner1</span> = <span class="pl-s1">outer</span>.<span class="pl-k">new</span> <span class="pl-smi">NoStaticInner</span>();
        <span class="pl-s1">inner1</span>.<span class="pl-en">inFun</span>();

        <span class="pl-c">//创建非静态内部类实例（方式2）</span>
        <span class="pl-smi">Outer</span>.<span class="pl-smi">NoStaticInner</span> <span class="pl-s1">inner2</span> = <span class="pl-s1">outer</span>.<span class="pl-en">getNoStaticInner</span>();
        <span class="pl-s1">inner1</span>.<span class="pl-en">inFun</span>();
    }
}
<span class="pl-k">class</span> <span class="pl-smi">Outer</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">a</span> = <span class="pl-s">"外部类的静态a"</span>;
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">b</span>  = <span class="pl-s">"外部类的静态b"</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">c</span> = <span class="pl-s">"外部类对象的非静态c"</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">d</span> = <span class="pl-s">"外部类对象的非静态d"</span>;

    <span class="pl-k">static</span> <span class="pl-k">class</span> <span class="pl-smi">StaticInner</span>{
        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-s1">a</span> =<span class="pl-s">"静态内部类的静态a"</span>;
        <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">c</span> = <span class="pl-s">"静态内部类对象的非静态c"</span>;
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">inMethod</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Inner.a = "</span> + <span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Outer.a = "</span> + <span class="pl-smi">Outer</span>.<span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-s1">b</span>);
        }
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">inFun</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Inner.inFun"</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Outer.a = "</span> + <span class="pl-smi">Outer</span>.<span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Inner.a = "</span> + <span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-s1">b</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"c = "</span> + <span class="pl-s1">c</span>);
<span class="pl-c">//            System.out.println("d = " + d);//不能访问外部类的非静态成员</span>
        }
    }

    <span class="pl-k">class</span> <span class="pl-smi">NoStaticInner</span>{
        <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">a</span> = <span class="pl-s">"非静态内部类对象的非静态a"</span>;
        <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">c</span> = <span class="pl-s">"非静态内部类对象的非静态c"</span>;

        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">inFun</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"NoStaticInner.inFun"</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Outer.a = "</span> + <span class="pl-smi">Outer</span>.<span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"a = "</span> + <span class="pl-s1">a</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"b = "</span> + <span class="pl-s1">b</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Outer.c = "</span> + <span class="pl-smi">Outer</span>.<span class="pl-smi">this</span>.<span class="pl-s1">c</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"c = "</span> + <span class="pl-s1">c</span>);
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"d = "</span> + <span class="pl-s1">d</span>);
        }
    }


    <span class="pl-k">public</span> <span class="pl-smi">NoStaticInner</span> <span class="pl-en">getNoStaticInner</span>(){
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">NoStaticInner</span>();
    }
}</pre></div>
<h3>8.3 局部内部类</h3>
<h4>8.3.1 非匿名局部内部类</h4>
<p>语法格式：</p>
<div class="highlight highlight-source-java"><pre class="notranslate">[修饰符] <span class="pl-k">class</span> 外部类{
    [修饰符] 返回值类型  方法名(形参列表){<span class="pl-s1"></span>
            [<span class="pl-s1">final</span>/<span class="pl-s1">abstract</span>] <span class="pl-s1">class</span> 内部类{
        }
    }    
}</pre></div>
<ul>
<li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。
<ul>
<li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li>
</ul>
</li>
<li>和成员内部类不同的是，它前面不能有权限修饰符等</li>
<li>局部内部类如同局部变量一样，有作用域</li>
<li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li>
</ul>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * ClassName: TestLocalInner</span>
<span class="pl-c"> * @Author 尚硅谷-宋红康</span>
<span class="pl-c"> * @Create 17:19</span>
<span class="pl-c"> * @Version 1.0</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestLocalInner</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Outer</span>.<span class="pl-en">outMethod</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"-------------------"</span>);

        <span class="pl-smi">Outer</span> <span class="pl-s1">out</span> = <span class="pl-k">new</span> <span class="pl-smi">Outer</span>();
        <span class="pl-s1">out</span>.<span class="pl-en">outTest</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"-------------------"</span>);

        <span class="pl-smi">Runner</span> <span class="pl-s1">runner</span> = <span class="pl-smi">Outer</span>.<span class="pl-en">getRunner</span>();
        <span class="pl-s1">runner</span>.<span class="pl-en">run</span>();

    }
}
<span class="pl-k">class</span> <span class="pl-smi">Outer</span>{

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">outMethod</span>(){
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Outer.outMethod"</span>);
        <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">c</span> = <span class="pl-s">"局部变量c"</span>;
        <span class="pl-k">class</span> <span class="pl-smi">Inner</span>{
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">inMethod</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Inner.inMethod"</span>);
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">c</span>);
            }
        }

        <span class="pl-smi">Inner</span> <span class="pl-s1">in</span> = <span class="pl-k">new</span> <span class="pl-smi">Inner</span>();
        <span class="pl-s1">in</span>.<span class="pl-en">inMethod</span>();
    }

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">outTest</span>(){
        <span class="pl-k">class</span> <span class="pl-smi">Inner</span>{
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">inMethod1</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"Inner.inMethod1"</span>);
            }
        }

        <span class="pl-smi">Inner</span> <span class="pl-s1">in</span> = <span class="pl-k">new</span> <span class="pl-smi">Inner</span>();
        <span class="pl-s1">in</span>.<span class="pl-en">inMethod1</span>();
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">Runner</span> <span class="pl-en">getRunner</span>(){
        <span class="pl-k">class</span> <span class="pl-smi">LocalRunner</span> <span class="pl-k">implements</span> <span class="pl-smi">Runner</span>{
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"LocalRunner.run"</span>);
            }
        }
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">LocalRunner</span>();
    }

}
<span class="pl-k">interface</span> <span class="pl-smi">Runner</span>{
    <span class="pl-smi">void</span> <span class="pl-en">run</span>();
}</pre></div>
<h4>8.3.2 匿名内部类</h4>
<p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">new</span> 父类([实参列表]){
    重写方法...
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">new</span> 父接口(){
    重写方法...
}</pre></div>
<p>举例1：使用匿名内部类的对象直接调用方法：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">void</span> <span class="pl-en">a</span>();
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-k">new</span> <span class="pl-smi">A</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">a</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"aaaa"</span>);
            }
        }.<span class="pl-en">a</span>();
    }
}</pre></div>
<p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">void</span> <span class="pl-en">a</span>();
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-smi">A</span> <span class="pl-s1">obj</span> = <span class="pl-k">new</span> <span class="pl-smi">A</span>(){
            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">a</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"aaaa"</span>);
            }
        };
        <span class="pl-s1">obj</span>.<span class="pl-en">a</span>();
    }
}</pre></div>
<p>举例3：匿名内部类的对象作为实参</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">A</span>{
    <span class="pl-smi">void</span> <span class="pl-en">method</span>();
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">test</span>(<span class="pl-smi">A</span> <span class="pl-s1">a</span>){
        <span class="pl-s1">a</span>.<span class="pl-en">method</span>();
    }
    
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>){
        <span class="pl-en">test</span>(<span class="pl-k">new</span> <span class="pl-smi">A</span>(){

            <span class="pl-c1">@</span><span class="pl-c1">Override</span>
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">method</span>() {
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"aaaa"</span>);
            }
        });
    }   
}</pre></div>
<h3>8.4 练习</h3>
<p>练习：判断输出结果为何？</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test</span> {
    <span class="pl-k">public</span> <span class="pl-smi">Test</span>() {
        <span class="pl-smi">Inner</span> <span class="pl-s1">s1</span> = <span class="pl-k">new</span> <span class="pl-smi">Inner</span>();
        <span class="pl-s1">s1</span>.<span class="pl-s1">a</span> = <span class="pl-c1">10</span>;
        <span class="pl-smi">Inner</span> <span class="pl-s1">s2</span> = <span class="pl-k">new</span> <span class="pl-smi">Inner</span>();
        <span class="pl-s1">s2</span>.<span class="pl-s1">a</span> = <span class="pl-c1">20</span>;
        <span class="pl-smi">Test</span>.<span class="pl-smi">Inner</span> <span class="pl-s1">s3</span> = <span class="pl-k">new</span> <span class="pl-smi">Test</span>.<span class="pl-smi">Inner</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">s3</span>.<span class="pl-s1">a</span>);
    }
    <span class="pl-k">class</span> <span class="pl-smi">Inner</span> {
        <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">a</span> = <span class="pl-c1">5</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Test</span> <span class="pl-s1">t</span> = <span class="pl-k">new</span> <span class="pl-smi">Test</span>();
        <span class="pl-smi">Inner</span> <span class="pl-s1">r</span> = <span class="pl-s1">t</span>.<span class="pl-k">new</span> <span class="pl-smi">Inner</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">r</span>.<span class="pl-s1">a</span>);
    }
}</pre></div>
<p>练习2：</p>
<p>编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印尚硅谷。</p>
<p>请编写代码调用这个方法。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">test01</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">Test01</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-k">new</span> <span class="pl-smi">Object</span>(){
            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">test</span>(){
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"尚硅谷"</span>);
            }
        }.<span class="pl-en">test</span>();
    }
}</pre></div>
<h2>9. 枚举类</h2>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">SeasonTest</span> {
    <span class="pl-c">//枚举类</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Season</span> <span class="pl-s1">spring</span> = <span class="pl-smi">Season</span>.<span class="pl-c1">SPRING</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">spring</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Season</span>.<span class="pl-c1">SPRING</span>.<span class="pl-en">getSeasonName</span>());
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Season</span>.<span class="pl-c1">SPRING</span>.<span class="pl-en">getSeasonDesc</span>());

    }
}

<span class="pl-k">enum</span> <span class="pl-smi">Season</span> {
    <span class="pl-c1">SPRING</span>(<span class="pl-s">"春天"</span>, <span class="pl-s">"春暖花开"</span>),
    <span class="pl-c1">SUMMER</span>(<span class="pl-s">"夏天"</span>, <span class="pl-s">"夏日炎炎"</span>),
    <span class="pl-c1">AUTUMN</span>(<span class="pl-s">"秋天"</span>, <span class="pl-s">"秋高气爽"</span>),
    <span class="pl-c1">WINTER</span>(<span class="pl-s">"冬天"</span>, <span class="pl-s">"冰天雪地"</span>);

    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>;

    <span class="pl-k">private</span> <span class="pl-smi">Season</span>(<span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>, <span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">seasonName</span> = <span class="pl-s1">seasonName</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">seasonDesc</span> = <span class="pl-s1">seasonDesc</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSeasonName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">seasonName</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSeasonDesc</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">seasonDesc</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>   
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Season{"</span> +
                <span class="pl-s">"seasonName='"</span> + <span class="pl-s1">seasonName</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">", seasonDesc='"</span> + <span class="pl-s1">seasonDesc</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">'}'</span>;
    }
}

<span class="pl-c">//枚举类</span>
<span class="pl-c">//枚举类是一种特殊的类，它用于表示一组常量。在Java中，枚举类使用关键字enum来定义。</span>
<span class="pl-c">//枚举类中的每个常量都是一个枚举类型的实例，它们都是public static final的，可以直接通过枚举类名来访问。</span>
<span class="pl-c">//枚举类可以包含构造方法、成员变量、成员方法和静态方法等。</span></pre></div>
<h3>9.1 概述</h3>
<ul>
<li>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</li>
<li>枚举类的例子举不胜举：
<ul>
<li><code class="notranslate">星期</code>：Monday(星期一)......Sunday(星期天)</li>
<li><code class="notranslate">性别</code>：Man(男)、Woman(女)</li>
<li><code class="notranslate">月份</code>：January(1月)......December(12月)</li>
<li><code class="notranslate">季节</code>：Spring(春节)......Winter(冬天)</li>
<li><code class="notranslate">三原色</code>：red(红色)、green(绿色)、blue(蓝色)</li>
<li><code class="notranslate">支付方式</code>：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</li>
<li><code class="notranslate">就职状态</code>：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)</li>
<li><code class="notranslate">订单状态</code>：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）</li>
<li><code class="notranslate">线程状态</code>：创建、就绪、运行、阻塞、死亡</li>
</ul>
</li>
<li><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></li>
<li>枚举类的实现：
<ul>
<li>在JDK5.0 之前，需要程序员自定义枚举类型。</li>
<li>在JDK5.0 之后，Java支持<code class="notranslate">enum</code>关键字来快速定义枚举类型。</li>
</ul>
</li>
</ul>
<p>开发中，如果针对某个类其实例是确定个数的，则推荐使用枚举类</p>
<p>如果枚举类的实例只有一个，则可以看作是单类的形式</p>
<h3>9.2 定义枚举类（JDK5.0 之前）</h3>
<p>在JDK5.0 之前如何声明枚举类呢？</p>
<ul>
<li><code class="notranslate">私有化</code>类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例。声明为：<code class="notranslate">public static final</code> ，对外暴露这些常量对象</li>
<li>对象如果有<code class="notranslate">实例变量</code>，应该声明为<code class="notranslate">private final</code>（建议，不是必须），并在构造器中初始化</li>
</ul>
<p>示例代码：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-smi">Season</span>{
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">SEASONNAME</span>;<span class="pl-c">//季节的名称</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">SEASONDESC</span>;<span class="pl-c">//季节的描述</span>
    <span class="pl-k">private</span> <span class="pl-smi">Season</span>(<span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>,<span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>){
        <span class="pl-smi">this</span>.<span class="pl-c1">SEASONNAME</span> = <span class="pl-s1">seasonName</span>;
        <span class="pl-smi">this</span>.<span class="pl-c1">SEASONDESC</span> = <span class="pl-s1">seasonDesc</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Season</span> <span class="pl-c1">SPRING</span> = <span class="pl-k">new</span> <span class="pl-smi">Season</span>(<span class="pl-s">"春天"</span>, <span class="pl-s">"春暖花开"</span>);
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Season</span> <span class="pl-c1">SUMMER</span> = <span class="pl-k">new</span> <span class="pl-smi">Season</span>(<span class="pl-s">"夏天"</span>, <span class="pl-s">"夏日炎炎"</span>);
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Season</span> <span class="pl-c1">AUTUMN</span> = <span class="pl-k">new</span> <span class="pl-smi">Season</span>(<span class="pl-s">"秋天"</span>, <span class="pl-s">"秋高气爽"</span>);
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Season</span> <span class="pl-c1">WINTER</span> = <span class="pl-k">new</span> <span class="pl-smi">Season</span>(<span class="pl-s">"冬天"</span>, <span class="pl-s">"白雪皑皑"</span>);

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Season{"</span> +
                <span class="pl-s">"SEASONNAME='"</span> + <span class="pl-c1">SEASONNAME</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">", SEASONDESC='"</span> + <span class="pl-c1">SEASONDESC</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">'}'</span>;
    }
}
<span class="pl-k">class</span> <span class="pl-smi">SeasonTest</span>{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-smi">Season</span>.<span class="pl-c1">AUTUMN</span>);
    }
}</pre></div>
<h3>9.3 定义枚举类（JDK5.0 之后）</h3>
<h4>9.3.1 enum关键字声明枚举</h4>
<div class="highlight highlight-source-java"><pre class="notranslate">【修饰符】 <span class="pl-k">enum</span> 枚举类名{
    常量对象列表
}

【修饰符】 <span class="pl-k">enum</span> 枚举类名{
    常量对象列表;
    
    对象的实例变量列表;
}</pre></div>
<p>举例1：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">enumeration</span>;

<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Week</span> {
    <span class="pl-c1">MONDAY</span>,<span class="pl-c1">TUESDAY</span>,<span class="pl-c1">WEDNESDAY</span>,<span class="pl-c1">THURSDAY</span>,<span class="pl-c1">FRIDAY</span>,<span class="pl-c1">SATURDAY</span>,<span class="pl-c1">SUNDAY</span>;
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestEnum</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Season</span> <span class="pl-s1">spring</span> = <span class="pl-smi">Season</span>.<span class="pl-c1">SPRING</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">spring</span>);
    }
}</pre></div>
<p><code class="notranslate">enum</code> 关键字用于定义枚举类型。枚举是一种特殊的类，它用于定义一组常量。枚举类型是固定的，一旦定义就不能被修改，这使得枚举类型非常适合用于表示一组有限的、固定的常量集合，比如一周的天数、月份、方向等。</p>
<p>以下是<code class="notranslate">enum</code>关键字的一些基本特性和用法：</p>
<ol>
<li><strong>定义枚举</strong>：<br>
使用<code class="notranslate">enum</code>关键字来定义一个枚举类型，枚举类型的名称通常以大写字母开头，以区分于类名。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Day</span> {
    <span class="pl-c1">MONDAY</span>, <span class="pl-c1">TUESDAY</span>, <span class="pl-c1">WEDNESDAY</span>, <span class="pl-c1">THURSDAY</span>, <span class="pl-c1">FRIDAY</span>, <span class="pl-c1">SATURDAY</span>, <span class="pl-c1">SUNDAY</span>
}</pre></div>
<ol start="2">
<li><strong>枚举成员</strong>：<br>
枚举类型的每个常量称为枚举成员，它们是枚举类型的实例。</li>
<li><strong>构造函数</strong>：<br>
枚举可以有自己的构造函数，并且可以传递参数给构造函数。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Day</span> {
    <span class="pl-c1">MONDAY</span>(<span class="pl-c1">1</span>), <span class="pl-c1">TUESDAY</span>(<span class="pl-c1">2</span>), <span class="pl-c1">WEDNESDAY</span>(<span class="pl-c1">3</span>), <span class="pl-c1">THURSDAY</span>(<span class="pl-c1">4</span>), <span class="pl-c1">FRIDAY</span>(<span class="pl-c1">5</span>), <span class="pl-c1">SATURDAY</span>(<span class="pl-c1">6</span>), <span class="pl-c1">SUNDAY</span>(<span class="pl-c1">7</span>);
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">dayNumber</span>;
    <span class="pl-k">private</span> <span class="pl-smi">Day</span>(<span class="pl-smi">int</span> <span class="pl-s1">number</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">dayNumber</span> = <span class="pl-s1">number</span>;
    }
}</pre></div>
<ol start="4">
<li><strong>方法</strong>：<br>
枚举可以有自己的方法，包括静态方法和实例方法。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Day</span> {
    <span class="pl-c1">MONDAY</span>, <span class="pl-c1">TUESDAY</span>, <span class="pl-c1">WEDNESDAY</span>, <span class="pl-c1">THURSDAY</span>, <span class="pl-c1">FRIDAY</span>, <span class="pl-c1">SATURDAY</span>, <span class="pl-c1">SUNDAY</span>;
    <span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-en">isWeekday</span>() {
        <span class="pl-k">return</span> <span class="pl-smi">this</span> != <span class="pl-c1">SATURDAY</span> &amp;&amp; <span class="pl-smi">this</span> != <span class="pl-c1">SUNDAY</span>;
    }
}</pre></div>
<ol start="5">
<li><strong>实现接口</strong>：<br>
枚举类型可以实现接口。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">Color</span> {
    <span class="pl-smi">boolean</span> <span class="pl-en">isDark</span>();
}
<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Day</span> <span class="pl-k">implements</span> <span class="pl-smi">Color</span> {
    <span class="pl-c1">MONDAY</span>, <span class="pl-c1">TUESDAY</span>, <span class="pl-c1">WEDNESDAY</span>, <span class="pl-c1">THURSDAY</span>, <span class="pl-c1">FRIDAY</span>, <span class="pl-c1">SATURDAY</span>, <span class="pl-c1">SUNDAY</span>;
    <span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-en">isDark</span>() {
        <span class="pl-k">return</span> <span class="pl-smi">this</span> == <span class="pl-c1">SATURDAY</span> || <span class="pl-smi">this</span> == <span class="pl-c1">SUNDAY</span>;
    }
}</pre></div>
<ol start="6">
<li><strong>switch语句</strong>：<br>
枚举类型非常适合在<code class="notranslate">switch</code>语句中使用。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-smi">Day</span> <span class="pl-s1">d</span></pre></div>
<h4>9.3.2 enum方式定义的要求和特点</h4>
<ul>
<li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。</li>
<li>列出的实例系统会自动添加 public static final 修饰。</li>
<li>如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。</li>
<li>编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数</li>
<li>如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。</li>
<li>枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。</li>
<li>JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。</li>
</ul>
<p>举例2：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">SeasonEnum</span> {
    <span class="pl-c1">SPRING</span>(<span class="pl-s">"春天"</span>,<span class="pl-s">"春风又绿江南岸"</span>),
    <span class="pl-c1">SUMMER</span>(<span class="pl-s">"夏天"</span>,<span class="pl-s">"映日荷花别样红"</span>),
    <span class="pl-c1">AUTUMN</span>(<span class="pl-s">"秋天"</span>,<span class="pl-s">"秋水共长天一色"</span>),
    <span class="pl-c1">WINTER</span>(<span class="pl-s">"冬天"</span>,<span class="pl-s">"窗含西岭千秋雪"</span>);

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>;
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>;
    
    <span class="pl-k">private</span> <span class="pl-smi">SeasonEnum</span>(<span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>, <span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">seasonName</span> = <span class="pl-s1">seasonName</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">seasonDesc</span> = <span class="pl-s1">seasonDesc</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSeasonName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">seasonName</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSeasonDesc</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">seasonDesc</span>;
    }
}</pre></div>
<p>举例3：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">enumeration</span>;

<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-smi">Week</span> {
    <span class="pl-c1">MONDAY</span>(<span class="pl-s">"星期一"</span>),
    <span class="pl-c1">TUESDAY</span>(<span class="pl-s">"星期二"</span>),
    <span class="pl-c1">WEDNESDAY</span>(<span class="pl-s">"星期三"</span>),
    <span class="pl-c1">THURSDAY</span>(<span class="pl-s">"星期四"</span>),
    <span class="pl-c1">FRIDAY</span>(<span class="pl-s">"星期五"</span>),
    <span class="pl-c1">SATURDAY</span>(<span class="pl-s">"星期六"</span>),
    <span class="pl-c1">SUNDAY</span>(<span class="pl-s">"星期日"</span>);

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">description</span>;

    <span class="pl-k">private</span> <span class="pl-smi">Week</span>(<span class="pl-smi">String</span> <span class="pl-s1">description</span>){
        <span class="pl-smi">this</span>.<span class="pl-s1">description</span> = <span class="pl-s1">description</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-en">super</span>.<span class="pl-en">toString</span>() +<span class="pl-s">":"</span>+ <span class="pl-s1">description</span>;
    }
}</pre></div>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">enumeration</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestWeek</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Week</span> <span class="pl-s1">week</span> = <span class="pl-smi">Week</span>.<span class="pl-c1">MONDAY</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">week</span>);

        <span class="pl-k">switch</span> (<span class="pl-s1">week</span>){
            <span class="pl-k">case</span> <span class="pl-c1">MONDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"怀念周末，困意很浓"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">TUESDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"进入学习状态"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">WEDNESDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"死撑"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">THURSDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"小放松"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">FRIDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"又信心满满"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">SATURDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"开始盼周末，无心学习"</span>);<span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">SUNDAY</span>:
                <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"一觉到下午"</span>);<span class="pl-k">break</span>;
        }
    }
}</pre></div>
<blockquote>
<p>经验之谈：</p>
<p>开发中，当需要定义一组常量时，强烈建议使用枚举类。</p>
</blockquote>
<h3>9.4 enum中常用方法</h3>
<pre lang="plain" class="notranslate"><code class="notranslate">String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
    
static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
    
static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
    
String name():得到当前枚举常量的名称。建议优先使用toString()。
    
int ordinal():返回当前枚举常量的次序号，默认从0开始

</code></pre>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">com</span>.<span class="pl-s1">atguigu</span>.<span class="pl-s1">enumeration</span>;

<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Scanner</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TestEnumMethod</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-c">//values()</span>
        <span class="pl-smi">Week</span>[] <span class="pl-s1">values</span> = <span class="pl-smi">Week</span>.<span class="pl-en">values</span>();
        <span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> = <span class="pl-c1">0</span>; <span class="pl-s1">i</span> &lt; <span class="pl-s1">values</span>.<span class="pl-s1">length</span>; <span class="pl-s1">i</span>++) {
            <span class="pl-c">//ordinal()、name()</span>
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>((<span class="pl-s1">values</span>[<span class="pl-s1">i</span>].<span class="pl-en">ordinal</span>()+<span class="pl-c1">1</span>) + <span class="pl-s">"-&gt;"</span> + <span class="pl-s1">values</span>[<span class="pl-s1">i</span>].<span class="pl-en">name</span>());
        }
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"------------------------"</span>);

        <span class="pl-smi">Scanner</span> <span class="pl-s1">input</span> = <span class="pl-k">new</span> <span class="pl-smi">Scanner</span>(<span class="pl-smi">System</span>.<span class="pl-s1">in</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>(<span class="pl-s">"请输入星期值："</span>);
        <span class="pl-smi">int</span> <span class="pl-s1">weekValue</span> = <span class="pl-s1">input</span>.<span class="pl-en">nextInt</span>();
        <span class="pl-smi">Week</span> <span class="pl-s1">week</span> = <span class="pl-s1">values</span>[<span class="pl-s1">weekValue</span>-<span class="pl-c1">1</span>];
        <span class="pl-c">//toString()</span>
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">week</span>);

        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>(<span class="pl-s">"请输入星期名："</span>);
        <span class="pl-smi">String</span> <span class="pl-s1">weekName</span> = <span class="pl-s1">input</span>.<span class="pl-en">next</span>();
        <span class="pl-c">//valueOf()</span>
        <span class="pl-s1">week</span> = <span class="pl-smi">Week</span>.<span class="pl-en">valueOf</span>(<span class="pl-s1">weekName</span>);
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">week</span>);

        <span class="pl-s1">input</span>.<span class="pl-en">close</span>();
    }
}</pre></div>
<h3>9.5 实现接口的枚举类</h3>
<ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<p>语法：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！</span>
<span class="pl-k">enum</span> <span class="pl-smi">A</span> <span class="pl-k">implements</span> 接口<span class="pl-c1">1</span>，接口<span class="pl-c1">2</span>{
    <span class="pl-c">//抽象方法的实现</span>
}

<span class="pl-c">//2、如果枚举类的常量可以继续重写抽象方法!</span>
<span class="pl-k">enum</span> <span class="pl-smi">A</span> <span class="pl-k">implements</span> 接口<span class="pl-c1">1</span>，接口<span class="pl-c1">2</span>{
    常量名<span class="pl-c1">1</span>(参数){
        <span class="pl-c">//抽象方法的实现或重写</span>
    },
    常量名<span class="pl-c1">2</span>(参数){
        <span class="pl-c">//抽象方法的实现或重写</span>
    },
    <span class="pl-c">//...</span>
}</pre></div>
<p>举例：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">interface</span> <span class="pl-smi">Info</span>{
    <span class="pl-smi">void</span> <span class="pl-en">show</span>();
}

<span class="pl-c">//使用enum关键字定义枚举类</span>
<span class="pl-k">enum</span> <span class="pl-smi">Season1</span> <span class="pl-k">implements</span> <span class="pl-smi">Info</span>{
    <span class="pl-c">//1. 创建枚举类中的对象,声明在enum枚举类的首位</span>
    <span class="pl-c1">SPRING</span>(<span class="pl-s">"春天"</span>,<span class="pl-s">"春暖花开"</span>){
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"春天在哪里？"</span>);
        }
    },
    <span class="pl-c1">SUMMER</span>(<span class="pl-s">"夏天"</span>,<span class="pl-s">"夏日炎炎"</span>){
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"宁静的夏天"</span>);
        }
    },
    <span class="pl-c1">AUTUMN</span>(<span class="pl-s">"秋天"</span>,<span class="pl-s">"秋高气爽"</span>){
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"秋天是用来分手的季节"</span>);
        }
    },
    <span class="pl-c1">WINTER</span>(<span class="pl-s">"冬天"</span>,<span class="pl-s">"白雪皑皑"</span>){
        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">show</span>(){
            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"2002年的第一场雪"</span>);
        }
    };
    
    <span class="pl-c">//2. 声明每个对象拥有的属性:private final修饰</span>
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">SEASON_NAME</span>;
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">SEASON_DESC</span>;
    
    <span class="pl-c">//3. 私有化类的构造器</span>
    <span class="pl-k">private</span> <span class="pl-smi">Season1</span>(<span class="pl-smi">String</span> <span class="pl-s1">seasonName</span>,<span class="pl-smi">String</span> <span class="pl-s1">seasonDesc</span>){
        <span class="pl-smi">this</span>.<span class="pl-c1">SEASON_NAME</span> = <span class="pl-s1">seasonName</span>;
        <span class="pl-smi">this</span>.<span class="pl-c1">SEASON_DESC</span> = <span class="pl-s1">seasonDesc</span>;
    }
    
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSEASON_NAME</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">SEASON_NAME</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getSEASON_DESC</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">SEASON_DESC</span>;
    }
}</pre></div>
<h4>注意</h4>
<p>使用 enmu 关键字定义的枚举类，其父类是 java.kang.Enmu 类</p>
<p>使用 enmu 关键字定义的枚举类，不要再显示的定义其父类，否则报错</p>
<h4>熟悉 enmu 常用的方法</h4>
<ol>
<li><strong>values()</strong>：返回枚举类型的所有值的数组。这是一个静态方法，可以直接通过枚举类型调用，而不需要实例。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">E</span>[] <span class="pl-s1">values</span>();</pre></div>
<ol start="2">
<li><strong>valueOf(String name)</strong>：返回一个指定名称的枚举常量。这也是一个静态方法，如果找不到匹配的常量，则抛出<code class="notranslate">IllegalArgumentException</code>。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">E</span> <span class="pl-s1">valueOf</span>(<span class="pl-smi">String</span> <span class="pl-s1">name</span>);</pre></div>
<ol start="3">
<li><strong>ordinal()</strong>：返回枚举常量的序号，序号从0开始。这是实例方法。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">ordinal</span>();</pre></div>
<ol start="4">
<li><strong>name()</strong>：返回枚举常量的名称。这是实例方法。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-s1">name</span>();</pre></div>
<ol start="5">
<li><strong>compareTo(E o)</strong>：比较两个枚举常量的顺序。如果调用对象的序号小于参数的序号，则返回负数；如果相等，则返回0；如果大于，则返回正数。这是实例方法。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">int</span> <span class="pl-s1">compareTo</span>(<span class="pl-smi">E</span> <span class="pl-s1">o</span>);</pre></div>
<ol start="6">
<li><strong>equals(Object obj)</strong> 和 <strong>hashCode()</strong>：这些方法通常被重写以提供基于枚举常量名称的相等性和哈希码。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Override</span>
<span class="pl-k">public</span> <span class="pl-smi">boolean</span> <span class="pl-s1">equals</span>(<span class="pl-smi">Object</span> <span class="pl-s1">obj</span>);
<span class="pl-c1">@</span><span class="pl-c1">Override</span>
<span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">hashCode</span>();</pre></div>
<ol start="7">
<li><strong>toString()</strong>：返回枚举常量的字符串表示，通常就是它的名称。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Override</span>
<span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-s1">toString</span>();</pre></div>
<ol start="8">
<li><strong>clone()</strong>：由于枚举是单例的，所以<code class="notranslate">clone()</code>方法总是抛出<code class="notranslate">CloneNotSupportedException</code>。</li>
</ol>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">Override</span>
<span class="pl-k">protected</span> <span class="pl-k">final</span> <span class="pl-smi">Object</span> <span class="pl-s1">clone</span>() <span class="pl-k">throws</span> <span class="pl-s1">CloneNotSupportedException</span>;</pre></div>
<p>枚举类接口操作</p>
<p>情况 1： 枚举类实现接口，在枚举类中重写接口中的抽象方法，当通过不同的枚举类对象调用此方法时，执行同一个方法。</p>
<p>情况 2：让枚举类的每一个对象重写接口的抽象方法，当通过不同的枚举类对象调用此方法时，执行的是不同的实现方法</p>
<p>练习</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">ColorTest</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
        <span class="pl-smi">Color</span> <span class="pl-s1">color</span> = <span class="pl-smi">Color</span>.<span class="pl-c1">RED</span>;
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">color</span>);
    
    }
    
}
<span class="pl-k">enum</span> <span class="pl-smi">Color</span> {
    <span class="pl-c1">RED</span>(<span class="pl-c1">255</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-s">"红色"</span>),
    <span class="pl-c1">GREEN</span>(<span class="pl-c1">0</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>,<span class="pl-s">"绿色"</span>),
    <span class="pl-c1">BLUE</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">255</span>,<span class="pl-s">"蓝色"</span>);

    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">redValue</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">greenValue</span>;
    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">blueValue</span>;
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">colorName</span>;

    <span class="pl-k">private</span> <span class="pl-smi">Color</span>(<span class="pl-smi">int</span> <span class="pl-s1">redValue</span>, <span class="pl-smi">int</span> <span class="pl-s1">greenValue</span>, <span class="pl-smi">int</span> <span class="pl-s1">blueValue</span>, <span class="pl-smi">String</span> <span class="pl-s1">colorName</span>) {
        <span class="pl-smi">this</span>.<span class="pl-s1">redValue</span> = <span class="pl-s1">redValue</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">greenValue</span> = <span class="pl-s1">greenValue</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">blueValue</span> = <span class="pl-s1">blueValue</span>;
        <span class="pl-smi">this</span>.<span class="pl-s1">colorName</span> = <span class="pl-s1">colorName</span>;
    }
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getColorName</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">colorName</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getRedValue</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">redValue</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getGreenValue</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">greenValue</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-en">getBlueValue</span>() {
        <span class="pl-k">return</span> <span class="pl-s1">blueValue</span>;
    }

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {
        <span class="pl-k">return</span> <span class="pl-s">"Color{"</span> +
                <span class="pl-s">"redValue="</span> + <span class="pl-s1">redValue</span> +
                <span class="pl-s">", greenValue="</span> + <span class="pl-s1">greenValue</span> +
                <span class="pl-s">", blueValue="</span> + <span class="pl-s1">blueValue</span> +
                <span class="pl-s">", colorName='"</span> + <span class="pl-s1">colorName</span> + <span class="pl-s">'\''</span> +
                <span class="pl-s">'}'</span>;
    }
}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"><P>注意：转载请注明出处<br>转载前请仔细阅读此文章<a href = 'https://blog.adouzi.eu.org/post/21.html'>关于博客文章转载规则以及一些闲聊</a><br>个人主页<a href='https://adouzi.eu.org'>https://adouzi.eu.org</a><br>email：shiraayano@adouzi.eu.org</p><br></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2"><span id="filingNum"><a href="https://beian.miit.gov.cn/" target="_blank"><a href='https://icp.gov.moe/?keyword=20240287' target='_blank'>萌ICP备20240287号</a></a> • </span>
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script>

</html>
