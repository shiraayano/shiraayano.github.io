<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/69860501?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="### BS架构（Browser-Server架构）
**BS架构**，即Browser-Server架构，是一种基于浏览器和服务器的架构模式。">
<meta property="og:title" content="Java 学习笔记 基础篇 015 网络">
<meta property="og:description" content="### BS架构（Browser-Server架构）
**BS架构**，即Browser-Server架构，是一种基于浏览器和服务器的架构模式。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.adouzi.eu.org/post/26.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java 学习笔记 基础篇 015 网络</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}

</style>
<style>img{max-width:100%;height:auto;display:block;margin:1em auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);transition:transform .2s ease,box-shadow .2s ease;}img[data-src]{opacity:0;animation:fadeIn 1s forwards;}@keyframes fadeIn{to{opacity:1;}}img:hover{transform:scale(1.05);box-shadow:0 8px 12px rgba(0,0,0,.2);}@media(max-width:600px){img{margin:.5em auto;}}</style>



<body>
    <div id="header">
<h1 class="postTitle">Java 学习笔记 基础篇 015 网络</h1>
<div class="title-right">
    <a href="https://blog.adouzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shiraayano/shiraayano.github.io/issues/26" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h3>BS架构（Browser-Server架构）</h3>
<p><strong>BS架构</strong>，即Browser-Server架构，是一种基于浏览器和服务器的架构模式。它的主要特点是：</p>
<ol>
<li><strong>客户端</strong>：用户通过浏览器访问应用程序，无需安装专门的软件。</li>
<li><strong>服务器端</strong>：所有的业务逻辑和数据处理都在服务器端完成，客户端只负责显示和交互。</li>
<li><strong>优点</strong>：
<ul>
<li>易于维护和升级：只需在服务器端进行更新，客户端无需任何操作。</li>
<li>跨平台：只要有浏览器，就可以访问应用程序，无论是PC、手机还是平板。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>对网络依赖较强：需要稳定的网络连接。</li>
<li>性能受限：由于所有操作都在服务器端完成，可能会受到服务器性能和网络带宽的限制。</li>
</ul>
</li>
</ol>
<h3>CS架构（Client-Server架构）</h3>
<p><strong>CS架构</strong>，即Client-Server架构，是一种基于客户端和服务器的架构模式。它的主要特点是：</p>
<ol>
<li><strong>客户端</strong>：用户需要安装专门的软件，客户端负责部分业务逻辑和数据处理。</li>
<li><strong>服务器端</strong>：服务器负责主要的业务逻辑和数据处理，客户端与服务器进行数据交互。</li>
<li><strong>优点</strong>：
<ul>
<li>性能较好：客户端可以分担部分计算任务，减轻服务器压力。</li>
<li>功能丰富：客户端软件可以提供更丰富的功能和更好的用户体验。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>维护和升级较复杂：需要在每个客户端进行更新。</li>
<li>跨平台性较差：不同平台需要开发不同版本的客户端软件。</li>
</ul>
</li>
</ol>
<h3>总结</h3>
<ul>
<li><strong>BS架构</strong>适用于需要频繁更新和跨平台访问的应用，如Web应用、在线服务等。</li>
<li><strong>CS架构</strong>适用于需要高性能和丰富功能的应用，如桌面软件、企业内部系统等。</li>
</ul>
<h3>实现网络传输的三个要素</h3>
<ol>
<li><strong>使用IP地址</strong>：准确地定位网络上一台或多台主机。</li>
<li><strong>使用端口号</strong>：定位主机上的特定应用。</li>
<li><strong>规范网络通信协议</strong>：可靠、高效地进行数据传输。</li>
</ol>
<h3>通信要素1：IP地址</h3>
<h4>3.1 作用</h4>
<p>IP地址用来给网络中的一台计算机设备做唯一的编号。</p>
<h4>3.2 IP地址分类</h4>
<ol>
<li><strong>IPv4</strong>：
<ul>
<li>占用4个字节。</li>
<li>例如：192.168.0.1</li>
</ul>
</li>
<li><strong>IPv6</strong>：
<ul>
<li>占用16个字节。</li>
<li>例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334</li>
</ul>
</li>
</ol>
<h3>IP地址分类方式2</h3>
<ol>
<li><strong>公网地址</strong>：
<ul>
<li>用于万维网（Internet）。</li>
<li>例如：8.8.8.8（Google的公共DNS服务器）。</li>
</ul>
</li>
<li><strong>私有地址</strong>：
<ul>
<li>用于局域网（LAN）。</li>
<li>例如：192.168.0.1（常见的路由器地址）。</li>
</ul>
</li>
</ol>
<h3>本地回路地址</h3>
<ul>
<li><strong>127.0.0.1</strong>：本地回路地址，用于测试本机网络配置和网络应用。</li>
</ul>
<h3>域名</h3>
<p>域名是便捷的记录IP地址的方式，便于人们记忆和使用。例如：</p>
<ul>
<li><a href="http://www.baidu.com" rel="nofollow">www.baidu.com</a></li>
<li><a href="http://www.atguigu.com" rel="nofollow">www.atguigu.com</a></li>
<li><a href="http://www.bilibili.com" rel="nofollow">www.bilibili.com</a></li>
<li><a href="http://www.id.com" rel="nofollow">www.id.com</a></li>
<li><a href="http://www.mi.com" rel="nofollow">www.mi.com</a></li>
<li><a href="http://www.vip.com" rel="nofollow">www.vip.com</a></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0fc78675fa0ff7ae9d41e9e4853a9cfbd5157581d8a7287ccf93b6db93df14a7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313834313430313734382d62353235646633352d653239632d346534312d383539382d3232643438623664356639302e706e67"><img src="https://camo.githubusercontent.com/0fc78675fa0ff7ae9d41e9e4853a9cfbd5157581d8a7287ccf93b6db93df14a7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313834313430313734382d62353235646633352d653239632d346534312d383539382d3232643438623664356639302e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731841401748-b525df35-e29c-4e41-8598-22d48b6d5f90.png" style="max-width: 100%;"></a></p>
<h3>通信要素2：端口号</h3>
<h4>作用</h4>
<ul>
<li>端口号可以唯一标识主机中的进程（应用程序）。</li>
<li>不同的进程分配不同的端口号。</li>
<li>端口号的范围是0~65535。</li>
</ul>
<h3>InetAddress的使用</h3>
<h4>5.1 作用</h4>
<ul>
<li><code class="notranslate">InetAddress</code>类的一个实例就代表一个具体的IP地址。</li>
</ul>
<h4>5.2 实例化方式</h4>
<ol>
<li><code class="notranslate">InetAddress getByName(String host)</code>：获取指定IP对应的<code class="notranslate">InetAddress</code>的实例。</li>
<li><code class="notranslate">InetAddress getLocalHost()</code>：获取本地IP对应的<code class="notranslate">InetAddress</code>的实例。</li>
</ol>
<h4>5.3 常用方法</h4>
<ol>
<li><code class="notranslate">getHostName()</code>：获取主机名。</li>
<li><code class="notranslate">getHostAddress()</code>：获取IP地址</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressExample {
    public static void main(String[] args) {
        try {
            // 获取指定IP地址的InetAddress对象
            InetAddress inet1 = InetAddress.getByName("192.168.23.31");
            System.out.println(inet1);

            // 获取指定域名的InetAddress对象
            InetAddress inet2 = InetAddress.getByName("www.atguigu.com");
            System.out.println(inet2); // www.atguigu.com/122.228.95.175

            // 获取本地主机的InetAddress对象
            InetAddress inet3 = InetAddress.getLocalHost();
            System.out.println(inet3); // DESKTOP-QCP2QPI/192.168.21.107

        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}

</code></pre>
<h3>TCP协议</h3>
<ol>
<li><strong>通信的两个应用进程</strong>：客户端、服务端。</li>
<li><strong>建立连接</strong>：使用TCP协议前，须先建立TCP连接，形成基于字节流的传输数据通道。</li>
<li><strong>三次握手</strong>：传输前，采用“三次握手”方式，点对点通信，是可靠的。</li>
<li><strong>重发机制</strong>：TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到确认信息，则会再次重复发送消息。</li>
<li><strong>大数据量传输</strong>：在连接中可进行大数据量的传输。</li>
<li><strong>释放连接</strong>：传输完毕，需释放已建立的连接，效率较低。</li>
</ol>
<h3>UDP协议</h3>
<ol>
<li><strong>通信的两个应用进程</strong>：发送端、接收端。</li>
<li><strong>数据包</strong>：将数据、源、目的封装成数据包（传输的基本单位），不需要建立连接。</li>
<li><strong>不可靠传输</strong>：发送不管对方是否准备好，接收方收到也不确认，不能保证数据的完整性，故是不可靠的。</li>
<li><strong>数据报大小限制</strong>：每个数据报的大小限制在64K内。</li>
<li><strong>无需释放资源</strong>：发送数据结束时无需释放资源，开销小，通信效率高。</li>
<li><strong>适用场景</strong>：适用于音频、视频和普通数据的传输，例如视频会议。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/db2e31e9bbb695ed8daddd4ffe72b8659906e36894066562f412ede2f63622b7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303433343932372d65313033396365612d653662372d346164642d383335392d6631623265633233653161322e706e67"><img src="https://camo.githubusercontent.com/db2e31e9bbb695ed8daddd4ffe72b8659906e36894066562f412ede2f63622b7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303433343932372d65313033396365612d653662372d346164642d383335392d6631623265633233653161322e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731850434927-e1039cea-e6b7-4add-8359-f1b2ec23e1a2.png" style="max-width: 100%;"></a></p>
<h3>TCP三次握手</h3>
<p><strong>三次握手</strong>是TCP协议在建立连接时使用的过程，确保双方都准备好进行通信。具体步骤如下：</p>
<ol>
<li><strong>第一次握手</strong>：
<ul>
<li>客户端发送一个SYN（同步序列编号）包到服务器，表示客户端希望建立连接。</li>
<li>服务器接收到SYN包后，进入SYN-RECEIVED状态。</li>
</ul>
</li>
<li><strong>第二次握手</strong>：
<ul>
<li>服务器发送一个SYN-ACK（同步确认）包到客户端，表示服务器同意建立连接，并确认客户端的SYN包。</li>
<li>客户端接收到SYN-ACK包后，进入SYN-RECEIVED状态。</li>
</ul>
</li>
<li><strong>第三次握手</strong>：
<ul>
<li>客户端发送一个ACK（确认）包到服务器，表示客户端确认服务器的SYN-ACK包。</li>
<li>服务器接收到ACK包后，进入ESTABLISHED状态，连接建立完成。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fd86bd617ddce43485d12878566c2224c95c2f0d17a3a2a22ca37ecd15090ffc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303437333737372d32303035363461642d393836342d343235612d393331322d3532643939316361343965332e706e67"><img src="https://camo.githubusercontent.com/fd86bd617ddce43485d12878566c2224c95c2f0d17a3a2a22ca37ecd15090ffc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303437333737372d32303035363461642d393836342d343235612d393331322d3532643939316361343965332e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731850473777-200564ad-9864-425a-9312-52d991ca49e3.png" style="max-width: 100%;"></a></p>
<h3>TCP四次挥手</h3>
<p><strong>四次挥手</strong>是TCP协议在断开连接时使用的过程，确保双方都能正常关闭连接。具体步骤如下：</p>
<ol>
<li><strong>第一次挥手</strong>：
<ul>
<li>客户端发送一个FIN（结束）包到服务器，表示客户端希望断开连接。</li>
<li>服务器接收到FIN包后，进入CLOSE-WAIT状态。</li>
</ul>
</li>
<li><strong>第二次挥手</strong>：
<ul>
<li>服务器发送一个ACK（确认）包到客户端，表示服务器确认客户端的FIN包。</li>
<li>客户端接收到ACK包后，进入FIN-WAIT-2状态。</li>
</ul>
</li>
<li><strong>第三次挥手</strong>：
<ul>
<li>服务器发送一个FIN包到客户端，表示服务器也希望断开连接。</li>
<li>客户端接收到FIN包后，进入CLOSING状态。</li>
</ul>
</li>
<li><strong>第四次挥手</strong>：
<ul>
<li>客户端发送一个ACK包到服务器，表示客户端确认服务器的FIN包。</li>
<li>服务器接收到ACK包后，进入CLOSED状态，连接断开完成。</li>
</ul>
</li>
</ol>
<h3>Socket类</h3>
<p><strong>Socket</strong>类是网络编程中用于实现通信的基本单元。网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符——套接字（Socket）。利用套接字开发网络应用程序早已被广泛采用，成为事实上的标准。网络通信其实就是Socket间的通信。</p>
<h4>主要特点</h4>
<ul>
<li><strong>通信的两端都要有Socket</strong>：是两台机器间通信的端点。</li>
<li><strong>数据传输</strong>：Socket允许程序把网络连接当成一个流，数据在两个Socket间通过I/O传输。</li>
<li><strong>客户端和服务端</strong>：一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</li>
</ul>
<h4>Socket分类</h4>
<ol>
<li><strong>流套接字（Stream Socket）</strong>：
<ul>
<li>使用TCP提供可依赖的字节流服务。</li>
<li><strong>ServerSocket</strong>：实现TCP服务器套接字，等待请求通过网络传入。</li>
<li><strong>Socket</strong>：实现客户端套接字，是两台机器间通信的端点。</li>
</ul>
</li>
<li><strong>数据报套接字（Datagram Socket）</strong>：
<ul>
<li>使用UDP提供“尽力而为”的数据报服务。</li>
<li><strong>DatagramSocket</strong>：用于发送和接收UDP数据报包的套接字。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b97447836c835c4cf59469fc996e03e80441e825035e9ae23c01611ebb8b1b26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303637363133302d30636137393139392d333133362d346264322d626163612d6432616133386638643939372e706e67"><img src="https://camo.githubusercontent.com/b97447836c835c4cf59469fc996e03e80441e825035e9ae23c01611ebb8b1b26/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835303637363133302d30636137393139392d333133362d346264322d626163612d6432616133386638643939372e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731850676130-0ca79199-3136-4bd2-baca-d2aa38f8d997.png" style="max-width: 100%;"></a></p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TCPTest1 {
    // 客户端
    public void client() {
        try {
            // 创建一个Socket连接到服务器
            Socket socket = new Socket("localhost", 8888);
            System.out.println("客户端已连接到服务器");

            // 发送数据到服务器
            OutputStream outputStream = socket.getOutputStream();
            String message = "Hello, Server!";
            outputStream.write(message.getBytes());

            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 服务端
    public void server() {
        try {
            // 创建一个ServerSocket
            ServerSocket serverSocket = new ServerSocket(8888);
            System.out.println("服务器已启动，等待客户端连接...");
            // 调用accept() 接收客户端的Socket
            Socket socket = serverSocket.accept();
            System.out.println("客户端已连接");

            // 接收数据
            InputStream inputStream = socket.getInputStream();
            byte[] buffer = new byte[1024];
            int len = inputStream.read(buffer);
            while (len != -1) {
                System.out.println(new String(buffer, 0, len));
                len = inputStream.read(buffer);
            }

            socket.close();
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        TCPTest1 test = new TCPTest1();
        // 启动服务端
        new Thread(() -&gt; test.server()).start();
        // 启动客户端
        new Thread(() -&gt; test.client()).start();
    }
}

</code></pre>
<ul>
<li>需要注意 使用 byte 传输时有可能会出现汉字乱码，这时候我们可以使用 ByteArrayOutputStream</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a3d26e6b11358e3b2c987a518bae5313e2888372bd17af7e3e04d033f2845811/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835313731343031312d65323634316264332d303130332d343665342d613735332d6266323766643333633232622e706e67"><img src="https://camo.githubusercontent.com/a3d26e6b11358e3b2c987a518bae5313e2888372bd17af7e3e04d033f2845811/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835313731343031312d65323634316264332d303130332d343665342d613735332d6266323766643333633232622e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731851714011-e2641bd3-0103-46e4-a753-bf27fd33c22b.png" style="max-width: 100%;"></a></p>
<h3>客户端代码</h3>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.*;
import java.net.Socket;

public class FileClient {
    public static void main(String[] args) {
        try {
            // 创建一个Socket连接到服务器
            Socket socket = new Socket("localhost", 8888);
            System.out.println("客户端已连接到服务器");

            // 发送文件到服务器
            File file = new File("path/to/your/file.txt");
            FileInputStream fis = new FileInputStream(file);
            OutputStream os = socket.getOutputStream();

            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }

            fis.close();
            os.close();
            socket.close();
            System.out.println("文件发送成功");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3>服务端代码</h3>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class FileServer {
    public static void main(String[] args) {
        try {
            // 创建一个ServerSocket
            ServerSocket serverSocket = new ServerSocket(8888);
            System.out.println("服务器已启动，等待客户端连接...");

            // 接收客户端的连接
            Socket socket = serverSocket.accept();
            System.out.println("客户端已连接");

            // 接收文件
            InputStream is = socket.getInputStream();
            FileOutputStream fos = new FileOutputStream("path/to/save/received_file.txt");

            byte[] buffer = new byte[1024];
            int len;
            while ((len = is.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }

            fos.close();
            is.close();
            socket.close();
            serverSocket.close();
            System.out.println("文件接收成功");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3>说明</h3>
<ol>
<li><strong>客户端</strong>：
<ul>
<li>创建一个Socket连接到服务器。</li>
<li>读取文件并通过Socket的输出流发送到服务器。</li>
</ul>
</li>
<li><strong>服务端</strong>：
<ul>
<li>创建一个ServerSocket等待客户端连接。</li>
<li>接收客户端发送的文件并保存到指定路径。</li>
</ul>
</li>
</ol>
<p>聊天室</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7c30f11ad18ac3062407494cfcca64f8add3e3dff5c01ec75a8c406d7c7256df/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835323938343130312d62353931336138392d306539622d346561342d613039392d3233666331666432333738642e706e67"><img src="https://camo.githubusercontent.com/7c30f11ad18ac3062407494cfcca64f8add3e3dff5c01ec75a8c406d7c7256df/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f34393435353431312f313733313835323938343130312d62353931336138392d306539622d346561342d613039392d3233666331666432333738642e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/49455411/1731852984101-b5913a89-0e9b-4ea4-a099-23fc1fd2378d.png" style="max-width: 100%;"></a></p>
<p>UDP</p>
<h3>发送端代码</h3>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPTest {
    public void sender() throws Exception {
        // 1. 创建DatagramSocket的实例
        DatagramSocket ds = new DatagramSocket();

        // 2. 将数据、目的地的IP，目的地的端口号都封装在DatagramPacket数据报中
        InetAddress inetAddress = InetAddress.getByName("127.0.0.1");
        int port = 9090;
        byte[] bytes = "我是发送端".getBytes("UTF-8");
        DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length, inetAddress, port);

        // 发送数据
        ds.send(packet);
        ds.close();
        System.out.println("数据发送成功");
    }
}
</code></pre>
<h3>接收端代码</h3>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class UDPTest {
    @Test
    public void receiver() throws Exception {
        // 1. 创建DatagramSocket的实例
        int port = 9090;
        DatagramSocket ds = new DatagramSocket(port);

        // 接收数据
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        ds.receive(packet);

        // 处理接收到的数据
        String receivedData = new String(packet.getData(), 0, packet.getLength(), "UTF-8");
        System.out.println("接收到的数据: " + receivedData);

        ds.close();
    }
}
</code></pre>
<h3>说明</h3>
<ol>
<li><strong>发送端</strong>：
<ul>
<li>创建一个 <code class="notranslate">DatagramSocket</code> 实例。</li>
<li>将数据、目的地的IP地址和端口号封装在 <code class="notranslate">DatagramPacket</code> 数据报中。</li>
<li>发送数据报并关闭 <code class="notranslate">DatagramSocket</code>。</li>
</ul>
</li>
<li><strong>接收端</strong>：
<ul>
<li>创建一个 <code class="notranslate">DatagramSocket</code> 实例并绑定到指定端口。</li>
<li>接收数据报并处理接收到的数据。</li>
<li>关闭 <code class="notranslate">DatagramSocket</code>。</li>
</ul>
</li>
</ol>
<h3>URL (Uniform Resource Locator)</h3>
<h4>1. 作用</h4>
<p>一个具体的URL就对应着互联网上某一资源的地址。它是定位和访问网络资源的关键。</p>
<h4>2. URL的格式</h4>
<p>一个URL的典型格式如下：</p>
<pre lang="plain" class="notranslate"><code class="notranslate">http://192.168.21.107:8080/examples/abcd.jpg?name=Tom
</code></pre>
<ul>
<li><strong>应用层协议</strong>：<code class="notranslate">http</code></li>
<li><strong>IP地址</strong>：<code class="notranslate">192.168.21.107</code></li>
<li><strong>端口号</strong>：<code class="notranslate">8080</code></li>
<li><strong>资源地址</strong>：<code class="notranslate">/examples/abcd.jpg</code></li>
<li><strong>参数列表</strong>：<code class="notranslate">?name=Tom</code></li>
</ul>
<h3>URL类的实例化及常用方法</h3>
<h4>实例化方式</h4>
<p><strong>通过字符串创建URL对象</strong>：</p>
<ol>
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">URL url = new URL("http://www.example.com");
</code></pre>
<p><strong>通过协议、主机、文件路径创建URL对象</strong>：</p>
<ol start="2">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">URL url = new URL("http", "www.example.com", "/index.html");
</code></pre>
<p><strong>通过协议、主机、端口、文件路径创建URL对象</strong>：</p>
<ol start="3">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">URL url = new URL("http", "www.example.com", 80, "/index.html");
</code></pre>
<h4>常用方法</h4>
<p><strong>获取协议</strong>：</p>
<ol>
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">String protocol = url.getProtocol();
</code></pre>
<p><strong>获取主机名</strong>：</p>
<ol start="2">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">String host = url.getHost();
</code></pre>
<p><strong>获取端口号</strong>：</p>
<ol start="3">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">int port = url.getPort();
</code></pre>
<p><strong>获取文件路径</strong>：</p>
<ol start="4">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">String path = url.getPath();
</code></pre>
<p><strong>获取查询参数</strong>：</p>
<ol start="5">
<li>java</li>
</ol>
<pre lang="plain" class="notranslate"><code class="notranslate">String query = url.getQuery();
</code></pre>
<h3>端口号</h3>
<p><strong>作用</strong>：</p>
<ul>
<li>用于区分同一台主机上的不同进程。</li>
<li>不同的进程分配不同的端口号。</li>
</ul>
<p><strong>范围</strong>：</p>
<ul>
<li>0-65535</li>
</ul>
<h3>网络通信协议</h3>
<p>网络通信协议有两套参考模型：</p>
<ol>
<li><strong>OSI参考模型</strong>：
<ul>
<li>模型过于理想化，未能在因特网上进行广泛推广。</li>
</ul>
</li>
<li><strong>TCP/IP参考模型（或TCP/IP协议）</strong>：
<ul>
<li>事实上的国际标准。</li>
</ul>
</li>
</ol>
<p>在传输层中涉及到两个协议：TCP和UDP。二者的对比如下：</p>
<h4>TCP协议</h4>
<ul>
<li><strong>可靠的连接</strong>：发送数据前，需要三次握手，断开连接时需要四次挥手。</li>
<li><strong>大数据量传输</strong>：适合进行大数据量的传输。</li>
<li><strong>效率低</strong>：由于需要建立连接和确认数据的接收，效率较低。</li>
</ul>
<h4>UDP协议</h4>
<ul>
<li><strong>不可靠的连接</strong>：发送前不需要确认对方是否在，接收方也不确认数据的接收。</li>
<li><strong>数据报传输</strong>：每个数据报的大小限制在64KB以内。</li>
<li><strong>效率高</strong>：发送数据结束时无需释放资源，开销小，通信效率高。</li>
<li><strong>适用场景</strong>：适用于音频、视频和普通数据的传输，例如视频会议。</li>
</ul>
<h3>TCP的三次握手和四次挥手</h3>
<p><strong>三次握手</strong>：</p>
<ol>
<li>客户端发送SYN包到服务器，表示希望建立连接。</li>
<li>服务器发送SYN-ACK包到客户端，表示同意建立连接。</li>
<li>客户端发送ACK包到服务器，确认连接建立。</li>
</ol>
<p><strong>四次挥手</strong>：</p>
<ol>
<li>客户端发送FIN包到服务器，表示希望断开连接。</li>
<li>服务器发送ACK包到客户端，确认收到断开请求。</li>
<li>服务器发送FIN包到客户端，表示也希望断开连接。</li>
<li>客户端发送ACK包到服务器，确认断开连接。</li>
</ol>
<h3>TCP网络编程</h3>
<p>TCP网络编程涉及到使用<code class="notranslate">Socket</code>和<code class="notranslate">ServerSocket</code>类来实现客户端和服务端之间的通信。客户端主动发起连接，服务端等待连接请求。</p>
<h3>UDP网络编程</h3>
<p>UDP网络编程涉及到使用<code class="notranslate">DatagramSocket</code>和<code class="notranslate">DatagramPacket</code>类来实现数据报的发送和接收。UDP不需要建立连接，适合快速传输小数据量的场景</p>
<h3>TCP网络编程</h3>
<h4>例题1：客户端发送内容给服务端，服务端将内容打印到控制台上</h4>
<p><strong>客户端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.OutputStream;
import java.net.Socket;

public class TCPClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 8888);
            OutputStream os = socket.getOutputStream();
            os.write("Hello, Server!".getBytes());
            os.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>服务端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TCPServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(8888);
            Socket socket = serverSocket.accept();
            InputStream is = socket.getInputStream();
            byte[] buffer = new byte[1024];
            int len = is.read(buffer);
            System.out.println(new String(buffer, 0, len));
            is.close();
            socket.close();
            serverSocket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4>例题2：客户端发送文件给服务端，服务端将文件保存在本地</h4>
<p><strong>客户端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.FileInputStream;
import java.io.OutputStream;
import java.net.Socket;

public class FileClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 8888);
            FileInputStream fis = new FileInputStream("path/to/your/file.txt");
            OutputStream os = socket.getOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }
            fis.close();
            os.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>服务端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class FileServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(8888);
            Socket socket = serverSocket.accept();
            InputStream is = socket.getInputStream();
            FileOutputStream fos = new FileOutputStream("path/to/save/received_file.txt");
            byte[] buffer = new byte[1024];
            int len;
            while ((len = is.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
            fos.close();
            is.close();
            socket.close();
            serverSocket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4>例题3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端</h4>
<p><strong>客户端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class FileClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 8888);
            FileInputStream fis = new FileInputStream("path/to/your/file.txt");
            OutputStream os = socket.getOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }
            socket.shutdownOutput();

            InputStream is = socket.getInputStream();
            byte[] response = new byte[1024];
            int responseLen = is.read(response);
            System.out.println(new String(response, 0, responseLen));

            fis.close();
            os.close();
            is.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>服务端代码</strong>：</p>
<p>java</p>
<pre lang="plain" class="notranslate"><code class="notranslate">import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class FileServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(8888);
            Socket socket = serverSocket.accept();
            InputStream is = socket.getInputStream();
            FileOutputStream fos = new FileOutputStream("path/to/save/received_file.txt");
            byte[] buffer = new byte[1024];
            int len;
            while ((len = is.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
            fos.close();

            OutputStream os = socket.getOutputStream();
            os.write("发送成功".getBytes());

            is.close();
            os.close();
            socket.close();
            serverSocket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3>UDP网络编程</h3>
<p>UDP网络编程涉及到使用<code class="notranslate">DatagramSocket</code>和<code class="notranslate">DatagramPacket</code>类来实现数据报的发送和接收。UDP不需要建立连接，适合快速传输小数据量的场景。</p>
<h3>URL编程</h3>
<p><strong>Java后台</strong>：将写好的Java程序部署在Tomcat服务器，启动Tomcat服务器。</p>
<p><strong>前台</strong>：使用浏览器进行访问，需要使用URL（HTML+CSS+JavaScript）。</p>
<p><strong>URL的作用</strong>：定位互联网上某一资源的地址。</p>
<p><strong>URL的格式</strong>：</p>
<pre lang="plain" class="notranslate"><code class="notranslate">http://192.168.21.107:8080/examples/abcd.jpg?name=Tom
</code></pre>
<ul>
<li><strong>应用层协议</strong>：<code class="notranslate">http</code></li>
<li><strong>IP地址</strong>：<code class="notranslate">192.168.21.107</code></li>
<li><strong>端口号</strong>：<code class="notranslate">8080</code></li>
<li><strong>资源地址</strong>：<code class="notranslate">/examples/abcd.jpg</code></li>
<li><strong>参数列表</strong>：<code class="notranslate">?name=Tom</code></li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"><footer style="padding:10px 15px;text-align:left;font-size:14px;color:#555;border-top:1px solid #e0e0e0;line-height:1.8;font-family:Arial,sans-serif"><span>注意：转载请注明出处 <br> 转载请先阅读以下文章 </span><a href="https://blog.adouzi.eu.org/post/21.html" style="color:#0078d7;text-decoration:none">关于博客文章转载规则以及一些闲聊</a> <br><br> <span>  个人主页：<a href="https://adouzi.eu.org" style="color:#0078d7;text-decoration:none">https://adouzi.eu.org</a></span><span> | Email：<a href="mailto:shiraayano@adouzi.eu.org" style="color:#0078d7;text-decoration:none">shiraayano@adouzi.eu.org</a><br><br><br>支持笔者：<a href="https://www.profitableratecpm.com/euxxr69t?key=f815bdc51cd258ab9f699175b0ef4446" style="color:#0078d7;text-decoration:none">点击广告</a><br>广告收入是本站唯一的收入，若本站内容帮到了您，可以点击广告支持笔者。</span><script async data-cfasync="false" src="//pl27420049.profitableratecpm.com/0f4f9e716ea5257a380097bb2d39a0bb/invoke.js"></script><div id="container-0f4f9e716ea5257a380097bb2d39a0bb"></div><br><script type="text/javascript">
atOptions = {
	'key' : '7a765266e94fd2cc53f429f1806bfa33',
	'format' : 'iframe',
	'height' : 90,
	'width' : 728,
	'params' : {}
}; </script><script type='text/javascript' src='//www.highperformanceformat.com/7a765266e94fd2cc53f429f1806bfa33/invoke.js'></script></footer></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://blog.adouzi.eu.org">白綾乃的博客</a></div>
<div id="footer2"><span id="filingNum"><a href="https://beian.miit.gov.cn/" target="_blank"><a href='https://icp.gov.moe/?keyword=20240287' target='_blank'>萌ICP备20240287号</a></a> • </span>
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("07/12/2024"!=""){
    var startSite=new Date("07/12/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shiraayano/shiraayano.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}



</script>
<script>document.addEventListener('visibilitychange',function(){const o=document.title;const i=['不来看看咱喵~？','喵喵喵~？'];if(document.visibilityState==='hidden'){document.title=i[Math.floor(Math.random()*i.length)];}else{document.title='欢迎回来喵~';setTimeout(function(){document.title=o;},1000);}});</script><script src='https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js'></script><script>document.addEventListener('visibilitychange',function(){if(!window.originalTitle){window.originalTitle=document.title;}const h=['不来看看咱喵~？','喵喵喵~？'];if(document.visibilityState==='hidden'){document.title=h[Math.floor(Math.random()*h.length)];}else{document.title='欢迎回来喵~';setTimeout(()=>{document.title=window.originalTitle;},1000);}});</script>

</html>
